/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../node_modules/almond/almond", function(){});

define('uuid', [], function () {
	var floor = Math.floor,
		random = Math.random
	;


	function s4() {
		return floor(random() * 0x10000 /* 65536 */).toString(16);
	}


	/**
	 * UUID — http://ru.wikipedia.org/wiki/UUID
	 * @function uuid
	 * @returns {String}
	 */
	return function uuid() {
		return (s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4());
	};
});

/*!
 * jQuery JavaScript Library v1.8.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Thu Sep 20 2012 21:13:05 GMT-0400 (Eastern Daylight Time)
 */
(function( window, undefined ) {
var
	// A central reference to the root jQuery(document)
	rootjQuery,

	// The deferred used on DOM ready
	readyList,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,
	navigator = window.navigator,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// Save a reference to some core methods
	core_push = Array.prototype.push,
	core_slice = Array.prototype.slice,
	core_indexOf = Array.prototype.indexOf,
	core_toString = Object.prototype.toString,
	core_hasOwn = Object.prototype.hasOwnProperty,
	core_trim = String.prototype.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

	// Used for detecting and trimming whitespace
	core_rnotwhite = /\S/,
	core_rspace = /\s+/,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// The ready event handler and self cleanup method
	DOMContentLoaded = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			jQuery.ready();
		} else if ( document.readyState === "complete" ) {
			// we're here because readyState === "complete" in oldIE
			// which is good enough for us to call the dom ready!
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	},

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context && context.nodeType ? context.ownerDocument || context : document );

					// scripts is true for back-compat
					selector = jQuery.parseHTML( match[1], doc, true );
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						this.attr.call( selector, context, true );
					}

					return jQuery.merge( this, selector );

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.8.2",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ),
			"slice", core_slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready, 1 );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ core_toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// scripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, scripts ) {
		var parsed;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			scripts = context;
			context = 0;
		}
		context = context || document;

		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
			(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
	},

	parseJSON: function( data ) {
		if ( !data || typeof data !== "string") {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && core_rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var name,
			i = 0,
			length = obj.length,
			isObj = length === undefined || jQuery.isFunction( obj );

		if ( args ) {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.apply( obj[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( obj[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var type,
			ret = results || [];

		if ( arr != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			type = jQuery.type( arr );

			if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
				core_push.call( ret, arr );
			} else {
				jQuery.merge( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key,
			ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready, 1 );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" && ( !options.unique || !self.has( arg ) ) ) {
								list.push( arg );
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				return jQuery.inArray( fn, list ) > -1;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
								function() {
									var returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								} :
								newDefer[ action ]
							);
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ] = list.fire
			deferred[ tuple[0] ] = list.fire;
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement("div");

	// Preliminary tests
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName("*");
	a = div.getElementsByTagName("a")[ 0 ];
	a.style.cssText = "top:1px;float:left;opacity:.5";

	// Can't get basic test support
	if ( !all || !all.length ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: ( document.compatMode === "CSS1Compat" ),

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", clickFn = function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent("onclick");
		div.detachEvent( "onclick", clickFn );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	input.setAttribute( "checked", "checked" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: true,
			change: true,
			focusin: true
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, div, tds, marginDiv,
			divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// NOTE: To any future maintainer, we've window.getComputedStyle
		// because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. For more
			// info see bug #3333
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = document.createElement("div");
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			container.style.zoom = 1;
		}

		// Null elements to avoid leaks in IE
		body.removeChild( container );
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	fragment.removeChild( div );
	all = a = select = opt = input = fragment = div = null;

	return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	deletedIds: [],

	// Remove at next major release (1.9/2.0)
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}

		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );

		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];

		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( !name.indexOf( "data-" ) ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				// Only convert to a number if it doesn't change the string
				+data + "" === data ? +data :
				rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery.removeData( elem, type + "queue", true );
				jQuery.removeData( elem, key, true );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook, fixSpecified,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea|)$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( setClass.indexOf( " " + classNames[ c ] + " " ) < 0 ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var removes, className, elem, c, cl, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}
		if ( (value && typeof value === "string") || value === undefined ) {
			removes = ( value || "" ).split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 && elem.className ) {

					className = (" " + elem.className + " ").replace( rclass, " " );

					// loop over each item in the removal list
					for ( c = 0, cl = removes.length; c < cl; c++ ) {
						// Remove until there is nothing to remove,
						while ( className.indexOf(" " + removes[ c ] + " ") >= 0 ) {
							className = className.replace( " " + removes[ c ] + " " , " " );
						}
					}
					elem.className = value ? jQuery.trim( className ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( core_rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
	attrFn: {},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {

			attrNames = value.split( core_rspace );

			for ( ; i < attrNames.length; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
				ret.value :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.value = value + "" );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var t, tns, type, origType, namespaces, origCount,
			j, events, special, eventType, handleObj,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, "events", true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
			type = event.type || event,
			namespaces = [];

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			for ( old = elem; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old === (elem.ownerDocument || document) ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
			handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = core_slice.call( arguments ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [];

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					selMatch = {};
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
		event.metaKey = !!event.metaKey;

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8 –
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === "undefined" ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};
	/**
	 *
	 * @param src
	 * @param props
	 * @returns {jQuery.Event}
	 * @constructor
	 */
jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "_submit_attached" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "_submit_attached", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "_change_attached", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var cachedruns,
	assertGetIdNotName,
	Expr,
	getText,
	isXML,
	contains,
	compile,
	sortOrder,
	hasDuplicate,
	outermostContext,

	baseHasDuplicate = true,
	strundefined = "undefined",

	expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

	Token = String,
	document = window.document,
	docElem = document.documentElement,
	dirruns = 0,
	done = 0,
	pop = [].pop,
	push = [].push,
	slice = [].slice,
	// Use a stripped-down indexOf if a native one is unavailable
	indexOf = [].indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	// Augment a function for special use by Sizzle
	markFunction = function( fn, value ) {
		fn[ expando ] = value == null || value;
		return fn;
	},

	createCache = function() {
		var cache = {},
			keys = [];

		return markFunction(function( key, value ) {
			// Only keep the most recent entries
			if ( keys.push( key ) > Expr.cacheLength ) {
				delete cache[ keys.shift() ];
			}

			return (cache[ key ] = value);
		}, cache );
	},

	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// Regex

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments not in parens/brackets,
	//   then attribute selectors and non-pseudos (denoted by :),
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

	// For matchExpr.POS and matchExpr.needsContext
	pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
		"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
	rpseudo = new RegExp( pseudos ),

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rnot = /^:not/,
	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"POS": new RegExp( pos, "i" ),
		"CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		// For use in libraries implementing .is()
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
	},

	// Support

	// Used for testing something on an element
	assert = function( fn ) {
		var div = document.createElement("div");

		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	},

	// Check if getElementsByTagName("*") returns only elements
	assertTagNameNoComments = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	}),

	// Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}),

	// Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	}),

	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn't catch changes
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length === 2;
	}),

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = document.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			document.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			document.getElementsByName( expando + 0 ).length;
		assertGetIdNotName = !document.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

// If slice is not available, provide a backup
try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		for ( ; (elem = this[i]); i++ ) {
			results.push( elem );
		}
		return results;
	};
}

function Sizzle( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var match, elem, xml, m,
		nodeType = context.nodeType;

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( nodeType !== 1 && nodeType !== 9 ) {
		return [];
	}

	xml = isXML( context );

	if ( !xml && !seed ) {
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	} else {

		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	}
	return ret;
};

isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
	function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b && b.parentNode;
		return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
	} :
	docElem.compareDocumentPosition ?
	function( a, b ) {
		return b && !!( a.compareDocumentPosition( b ) & 16 );
	} :
	function( a, b ) {
		while ( (b = b.parentNode) ) {
			if ( b === a ) {
				return true;
			}
		}
		return false;
	};

Sizzle.attr = function( elem, name ) {
	var val,
		xml = isXML( elem );

	if ( !xml ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( xml || assertAttributes ) {
		return elem.getAttribute( name );
	}
	val = elem.getAttributeNode( name );
	return val ?
		typeof elem[ name ] === "boolean" ?
			elem[ name ] ? name : null :
			val.specified ? val.value : null :
		null;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	// IE6/7 return a modified href
	attrHandle: assertHrefNotNormalized ?
		{} :
		{
			"href": function( elem ) {
				return elem.getAttribute( "href", 2 );
			},
			"type": function( elem ) {
				return elem.getAttribute("type");
			}
		},

	find: {
		"ID": assertGetIdNotName ?
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			} :
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			},

		"TAG": assertTagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					var elem,
						tmp = [],
						i = 0;

					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			},

		"NAME": assertUsableName && function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		},

		"CLASS": assertUsableClassName && function( className, context, xml ) {
			if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( rbackslash, "" );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				3 xn-component of xn+y argument ([+-]?\d*n|)
				4 sign of xn-component
				5 x of xn-component
				6 sign of y-component
				7 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1] === "nth" ) {
				// nth-child requires argument
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
				match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

			// other types prohibit arguments
			} else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var unquoted, excess;
			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			if ( match[3] ) {
				match[2] = match[3];
			} else if ( (unquoted = match[4]) ) {
				// Only check arguments that contain a pseudo
				if ( rpseudo.test(unquoted) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					unquoted = unquoted.slice( 0, excess );
					match[0] = match[0].slice( 0, excess );
				}
				match[2] = unquoted;
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		"ID": assertGetIdNotName ?
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					return elem.getAttribute("id") === id;
				};
			} :
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === id;
				};
			},

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}
			nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ expando ][ className ];
			if ( !pattern ) {
				pattern = classCache( className, new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)") );
			}
			return function( elem ) {
				return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
			};
		},

		"ATTR": function( name, operator, check ) {
			return function( elem, context ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.substr( result.length - check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, argument, first, last ) {

			if ( type === "nth" ) {
				return function( elem ) {
					var node, diff,
						parent = elem.parentNode;

					if ( first === 1 && last === 0 ) {
						return true;
					}

					if ( parent ) {
						diff = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								diff++;
								if ( elem === node ) {
									break;
								}
							}
						}
					}

					// Incorporate the offset (or cast to NaN), then check against cycle size
					diff -= last;
					return diff === first || ( diff % first === 0 && diff / first >= 0 );
				};
			}

			return function( elem ) {
				var node = elem;

				switch ( type ) {
					case "only":
					case "first":
						while ( (node = node.previousSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === "first" ) {
							return true;
						}

						node = elem;

						/* falls through */
					case "last":
						while ( (node = node.nextSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;
				}
			};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			var nodeType;
			elem = elem.firstChild;
			while ( elem ) {
				if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
					return false;
				}
				elem = elem.nextSibling;
			}
			return true;
		},

		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"text": function( elem ) {
			var type, attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				(type = elem.type) === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
		},

		// Input types
		"radio": createInputPseudo("radio"),
		"checkbox": createInputPseudo("checkbox"),
		"file": createInputPseudo("file"),
		"password": createInputPseudo("password"),
		"image": createInputPseudo("image"),

		"submit": createButtonPseudo("submit"),
		"reset": createButtonPseudo("reset"),

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"focus": function( elem ) {
			var doc = elem.ownerDocument;
			return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href);
		},

		"active": function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		},

		// Positional types
		"first": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = 0; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = 1; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

function siblingCheck( a, b, ret ) {
	if ( a === b ) {
		return ret;
	}

	var cur = a.nextSibling;

	while ( cur ) {
		if ( cur === b ) {
			return -1;
		}

		cur = cur.nextSibling;
	}

	return 1;
}

sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) & 4
		) ? -1 : 1;
	} :
	function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		i = 1;

	hasDuplicate = baseHasDuplicate;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				results.splice( i--, 1 );
			}
		}
	}

	return results;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type, soFar, groups, preFilters,
		cached = tokenCache[ expando ][ selector ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				soFar = soFar.slice( match[0].length );
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			tokens.push( matched = new Token( match.shift() ) );
			soFar = soFar.slice( matched.length );

			// Cast descendant combinators to space
			matched.type = match[0].replace( rtrim, " " );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				// The last two arguments here are (context, xml) for backCompat
				(match = preFilters[ type ]( match, document, true ))) ) {

				tokens.push( matched = new Token( match.shift() ) );
				soFar = soFar.slice( matched.length );
				matched.type = type;
				matched.matches = match;
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && combinator.dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( checkNonElements || elem.nodeType === 1  ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( !xml ) {
				var cache,
					dirkey = dirruns + " " + doneName + " ",
					cachedkey = dirkey + cachedruns;
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( (cache = elem[ expando ]) === cachedkey ) {
							return elem.sizset;
						} else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
							if ( elem.sizset ) {
								return elem;
							}
						} else {
							elem[ expando ] = cachedkey;
							if ( matcher( elem, context, xml ) ) {
								elem.sizset = true;
								return elem;
							}
							elem.sizset = false;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( matcher( elem, context, xml ) ) {
							return elem;
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		// Positional selectors apply to seed elements, so it is invalid to follow them with relative ones
		if ( seed && postFinder ) {
			return;
		}

		var i, elem, postFilterIn,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [], seed ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			postFilterIn = condense( matcherOut, postMap );
			postFilter( postFilterIn, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = postFilterIn.length;
			while ( i-- ) {
				if ( (elem = postFilterIn[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		// Keep seed and results synchronized
		if ( seed ) {
			// Ignore postFinder because it can't coexist with seed
			i = preFilter && matcherOut.length;
			while ( i-- ) {
				if ( (elem = matcherOut[i]) ) {
					seed[ preMap[i] ] = !(results[ preMap[i] ] = elem);
				}
			}
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			// The concatenated values are (context, xml) for backCompat
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && tokens.slice( 0, i - 1 ).join("").replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && tokens.join("")
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Nested matchers should use non-integer dirruns
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = superMatcher.el;
			}

			// Add elements passing elementMatchers directly to results
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++superMatcher.el;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				for ( j = 0; (matcher = setMatchers[j]); j++ ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	superMatcher.el = 0;
	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ expando ][ selector ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results, seed ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results, seed );
	}
	return results;
}

function select( selector, context, results, seed, xml ) {
	var i, tokens, token, type, find,
		match = tokenize( selector ),
		j = match.length;

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && !xml &&
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find["ID"]( token.matches[0].replace( rbackslash, "" ), context, xml )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().length );
			}

			// Fetch a seed set for right-to-left matching
			for ( i = matchExpr["POS"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( rbackslash, "" ),
						rsibling.test( tokens[0].type ) && context.parentNode || context,
						xml
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && tokens.join("");
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		xml,
		results,
		rsibling.test( selector )
	);
	return results;
}

if ( document.querySelectorAll ) {
	(function() {
		var disconnectedMatch,
			oldSelect = select,
			rescape = /'|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

			// qSa(:focus) reports false when true (Chrome 21),
			// A support test would require too much code (would include document ready)
			rbuggyQSA = [":focus"],

			// matchesSelector(:focus) reports false when true (Chrome 21),
			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			// A support test would require too much code (would include document ready)
			// just skip matchesSelector for :active
			rbuggyMatches = [ ":active", ":focus" ],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here (do not put tests after this one)
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE9 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<p test=''></p>";
			if ( div.querySelectorAll("[test^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here (do not put tests after this one)
			div.innerHTML = "<input type='hidden'/>";
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push(":enabled", ":disabled");
			}
		});

		// rbuggyQSA always contains :focus, so no need for a length check
		rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA.join("|") );

		select = function( selector, context, results, seed, xml ) {
			// Only use querySelectorAll when not filtering,
			// when this is not xml,
			// and when no QSA bugs apply
			if ( !seed && !xml && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				var groups, i,
					old = true,
					nid = expando,
					newContext = context,
					newSelector = context.nodeType === 9 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + groups[i].join("");
					}
					newContext = rsibling.test( selector ) && context.parentNode || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							newSelector
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}

			return oldSelect( selector, context, results, seed, xml );
		};

		if ( matches ) {
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				try {
					matches.call( div, "[test!='']:sizzle" );
					rbuggyMatches.push( "!=", pseudos );
				} catch ( e ) {}
			});

			// rbuggyMatches always contains :active and :focus, so no need for a length check
			rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

			Sizzle.matchesSelector = function( elem, expr ) {
				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, "='$1']" );

				// rbuggyMatches always contains :active, so no need for an existence check
				if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && (!rbuggyQSA || !rbuggyQSA.test( expr )) ) {
					try {
						var ret = matches.call( elem, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.document.nodeType !== 11 ) {
							return ret;
						}
					} catch(e) {}
				}

				return Sizzle( expr, null, null, [ elem ] ).length > 0;
			};
		}
	})();
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Back-compat
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, l, length, n, r, ret,
			self = this;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		ret = this.pushStack( "", "find", selector );

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			cur = this[i];

			while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length > 1 && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rcheckableType = /^(?:checkbox|radio)$/,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
		}
	},

	after: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( !isDisconnected( this[0] ) ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		}

		return this.length ?
			this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
			this;
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = [].concat.apply( [], args );

		var results, first, fragment, iNoClone,
			i = 0,
			value = args[0],
			scripts = [],
			l = this.length;

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call( this, i, table ? self.html() : undefined );
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			results = jQuery.buildFragment( args, this, scripts );
			fragment = results.fragment;
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				// Fragments from the fragment cache must always be cloned and never used in place.
				for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
					callback.call(
						table && jQuery.nodeName( this[i], "table" ) ?
							findOrAppend( this[i], "tbody" ) :
							this[i],
						i === iNoClone ?
							fragment :
							jQuery.clone( fragment, true, true )
					);
				}
			}

			// Fix #11809: Avoid leaking memory
			fragment = first = null;

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						if ( jQuery.ajax ) {
							jQuery.ajax({
								url: elem.src,
								type: "GET",
								dataType: "script",
								async: false,
								global: false,
								"throws": true
							});
						} else {
							jQuery.error("no ajax");
						}
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	if ( nodeName === "object" ) {
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
	var fragment, cacheable, cachehit,
		first = args[ 0 ];

	// Set context from what may come in as undefined or a jQuery collection or a node
	// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
	// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
	context = context || document;
	context = !context.nodeType && context[0] || context;
	context = context.ownerDocument || context;

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		// Mark cacheable and look for a hit
		cacheable = true;
		fragment = jQuery.fragments[ first ];
		cachehit = fragment !== undefined;
	}

	if ( !fragment ) {
		fragment = context.createDocumentFragment();
		jQuery.clean( args, context, fragment, scripts );

		// Update the cache, but only store false
		// unless this is a second parsing of the same content
		if ( cacheable ) {
			jQuery.fragments[ first ] = cachehit && fragment;
		}
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			l = insert.length,
			parent = this.length === 1 && this[0].parentNode;

		if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
			insert[ original ]( this[0] );
			return this;
		} else {
			for ( ; i < l; i++ ) {
				elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			clone;

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
			safe = context === document && safeFragment,
			ret = [];

		// Ensure that context is a document
		if ( !context || typeof context.createDocumentFragment === "undefined" ) {
			context = document;
		}

		// Use the already-created safe fragment if context permits
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Ensure a safe container in which to render the html
					safe = safe || createSafeFragment( context );
					div = context.createElement("div");
					safe.appendChild( div );

					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Go to html and back, then peel off extra wrappers
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					depth = wrap[0];
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						hasBody = rtbody.test(elem);
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Take out of fragment container (we need a fresh div each time)
					div.parentNode.removeChild( div );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				jQuery.merge( ret, elem );
			}
		}

		// Fix #11356: Clear elements from safeFragment
		if ( div ) {
			elem = div = safe = null;
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					fixDefaultChecked( elem );
				} else if ( typeof elem.getElementsByTagName !== "undefined" ) {
					jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
				}
			}
		}

		// Append elements to a provided document fragment
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we're done after handling an executable script
				if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== "undefined" ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var data, id, elem, type,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( elem.removeAttribute ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						jQuery.deletedIds.push( id );
					}
				}
			}
		}
	}
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
	browser[ matched.browser ] = true;
	browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
	browser.webkit = true;
} else if ( browser.webkit ) {
	browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
	elemdisplay = {},

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

	eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var elem, display,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		values[ index ] = jQuery._data( elem, "olddisplay" );
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && elem.style.display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {
			display = curCSS( elem, "display" );

			if ( !values[ index ] && display !== "none" ) {
				jQuery._data( elem, "olddisplay", display );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state, fn2 ) {
		var bool = typeof state === "boolean";

		if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
			return eventsToggle.apply( this, arguments );
		}

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, numeric, extra ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( numeric || extra !== undefined ) {
			num = parseFloat( val );
			return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	curCSS = function( elem, name ) {
		var ret, width, minWidth, maxWidth,
			computed = window.getComputedStyle( elem, null ),
			style = elem.style;

		if ( computed ) {

			ret = computed[ name ];
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	curCSS = function( elem, name ) {
		var left, rsLeft,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			// we use jQuery.css instead of curCSS here
			// because of the reliableMarginRight CSS hook!
			val += jQuery.css( elem, extra + cssExpand[ i ], true );
		}

		// From this point on we use curCSS for maximum performance (relevant in animations)
		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		valueIsBorderBox = true,
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox
		)
	) + "px";
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	if ( elemdisplay[ nodeName ] ) {
		return elemdisplay[ nodeName ];
	}

	var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
		display = elem.css("display");
	elem.remove();

	// If the simple way fails,
	// get element's real default display by attaching it to a temp iframe
	if ( display === "none" || display === "" ) {
		// Use the already-created iframe if possible
		iframe = document.body.appendChild(
			iframe || jQuery.extend( document.createElement("iframe"), {
				frameBorder: 0,
				width: 0,
				height: 0
			})
		);

		// Create a cacheable copy of the iframe document on first call.
		// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
		// document to it; WebKit & Firefox won't allow reusing the iframe document.
		if ( !iframeDoc || !iframe.createElement ) {
			iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
			iframeDoc.write("<!doctype html><html><body>");
			iframeDoc.close();
		}

		elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

		display = curCSS( elem, "display" );
		document.body.removeChild( iframe );
	}

	// Store the correct default display
	elemdisplay[ nodeName ] = display;

	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				} else {
					return getWidthOrHeight( elem, name, extra );
				}
			}
		},

		set: function( elem, value, extra ) {
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
				style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "marginRight" );
					}
				});
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						var ret = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
			i = 0,
			length = dataTypes.length;

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var selection,
		list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters );

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	// Don't do a request if no elements are being requested
	if ( !this.length ) {
		return this;
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// Request the remote document
	jQuery.ajax({
		url: url,

		// if "type" variable is undefined, then "GET" method will be used
		type: type,
		dataType: "html",
		data: params,
		complete: function( jqXHR, status ) {
			if ( callback ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			}
		}
	}).done(function( responseText ) {

		// Save response for use in complete callback
		response = arguments;

		// See if a selector was specified
		self.html( selector ?

			// Create a dummy div to hold the results
			jQuery("<div>")

				// inject the contents of the document in, removing the scripts
				// to avoid any 'Permission Denied' errors in IE
				.append( responseText.replace( rscript, "" ) )

				// Locate the specified elements
				.find( selector ) :

			// If not, just inject the full result
			responseText );

	});

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // ifModified key
			ifModifiedKey,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || strAbort;
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ ifModifiedKey ] = modified;
					}
					modified = jqXHR.getResponseHeader("Etag");
					if ( modified ) {
						jQuery.etag[ ifModifiedKey ] = modified;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.always( tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() ) || false;
			s.crossDomain = parts && ( parts.join(":") + ( parts[ 3 ] ? "" : parts[ 1 ] === "http:" ? 80 : 443 ) ) !==
				( ajaxLocParts.join(":") + ( ajaxLocParts[ 3 ] ? "" : ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) );
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();

		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	var conv, conv2, current, tmp,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ],
		converters = {},
		i = 0;

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There's only work to do if current dataType is non-auto
		if ( current !== "*" ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(" ");
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s["throws"] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: "success", data: response };
}
var oldCallbacks = [],
	rquestion = /\?/,
	rjsonp = /(=)\?(?=&|$)|\?\?/,
	nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		data = s.data,
		url = s.url,
		hasCallback = s.jsonp !== false,
		replaceInUrl = hasCallback && rjsonp.test( url ),
		replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
			!( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
			rjsonp.test( data );

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;
		overwritten = window[ callbackName ];

		// Insert callback into url or form data
		if ( replaceInUrl ) {
			s.url = url.replace( rjsonp, "$1" + callbackName );
		} else if ( replaceInData ) {
			s.data = data.replace( rjsonp, "$1" + callbackName );
		} else if ( hasCallback ) {
			s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});
var xhrCallbacks,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback, 0 );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var end, unit,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

				// We need to compute starting value
				if ( unit !== "px" && start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	}, 0 );
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we're done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		index = 0,
		tweenerIndex = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				percent = 1 - ( remaining / animation.duration || 0 ),
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end, easing ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			anim: animation,
			queue: animation.opts.queue,
			elem: elem
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	var index, prop, value, length, dataShow, tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.done(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery.removeData( elem, "fxshow", true );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index < length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing any value as a 4th parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, false, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ||
			// special check for .toggle( handler, handler, ... )
			( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations resolve immediately
				if ( empty ) {
					anim.stop( true );
				}
			};

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	if ( (body = doc.body) === elem ) {
		return jQuery.offset.bodyOffset( elem );
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== "undefined" ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	clientTop  = docElem.clientTop  || body.clientTop  || 0;
	clientLeft = docElem.clientLeft || body.clientLeft || 0;
	scrollTop  = win.pageYOffset || docElem.scrollTop;
	scrollLeft = win.pageXOffset || docElem.scrollLeft;
	return {
		top: box.top  + scrollTop  - clientTop,
		left: box.left + scrollLeft - clientLeft
	};
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.body;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, value, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}

})( window );

define('utils/util', ['jquery'], function ($) {
	'use strict';

	var setTimeout = window.setTimeout,
		setImmediate = window.setImmediate || setTimeout;


	/**
	 * @typedef  {Function} DebouncedFunction
	 * @property {number} pid
	 * @property {Function} cancel
	 */


	/**
	 * Базовые утилиты
	 * @module util
	 */
	var util = {

		/**
		 * Объединяет содержимое двух или более объектов.
		 * @memberOf util
		 * @param  {...Object} args
		 * @returns {Object}
		 */
		extend: function (args) {
			return $.extend.apply($, arguments);
		},


		/**
		 * Клонирование через JSON
		 * @param   {*} src
		 * @returns {*}
		 */
		cloneJSON: function (src) {
			return typeof src === 'object' ? JSON.parse(JSON.stringify(src)) : src;
		},


		/**
		 * Быстрое клонирование объекта
		 * @memberOf util
		 * @param   {Object}  obj
		 * @returns {Object}
		 */
		cloneObject: function (obj) {
			var ret = {}, key;

			if (obj && obj instanceof Object) {
				for (key in obj) {
					ret[key] = obj[key];
				}
			}

			return ret;
		},


		/**
		 * Метод для приведения строк к camelCase нотации
		 * @memberOf util
		 * @param  {string} str          Строка в snake нотации
		 * @param  {string} [delimiter]  Разделитель, по умолчанию '_'
		 * @return {string}              Строка в camelCase
		 */
		toCamelCase: function (str, delimiter) {
			delimiter = delimiter || '_';

			var regexp = new RegExp('(\\' + delimiter + '\\w)', 'g');

			return str.replace(regexp, function (match) {
				return match[1].toUpperCase();
			});
		},


		/**
		 * Выполнить функцию в следующем «тике«
		 * @param   {Function} fn
		 * @param   {boolean}  [returnFunc]
		 * @returns {undefined|Function}
		 */
		nextTick: function (fn, returnFunc) {
			if (returnFunc) {
				return function () {
					var args = arguments,
						_this = this;

					setImmediate(function () {
						fn.apply(_this, args);
					});
				};
			}
			else {
				setImmediate(fn);
			}
		},


		/**
		 * Отложить выполнение метода
		 * @param  {Function} fn
		 * @param  {number} [ms] минимальная задаржка перед выполнением
		 * @param  {Object} [thisArg]
		 * @return {DebouncedFunction}
		 */
		debounce: function (fn, ms, thisArg) {
			var debounced = function () {
				var args = arguments,
					length = args.length,
					ctx = thisArg || this;

				clearTimeout(debounced.pid);
				debounced.pid = setTimeout(function () {
					if (length === 0) {
						fn.call(ctx);
					}
					else if (length === 1) {
						fn.call(ctx, args[0]);
					}
					else if (length === 2) {
						fn.call(ctx, args[0], args[1]);
					}
					else if (length === 3) {
						fn.call(ctx, args[0], args[1], args[2]);
					}
					else {
						fn.apply(ctx, args);
					}
				}, ms);
			};

			debounced.cancel = _cancelDebounce;

			return debounced;
		},


		/**
		 * Тот же `bind`, но не учутываются аргументы при вызове
		 * @param  {Function}  fn
		 * @param  {Array}     [args]
		 * @param  {*}         thisArg
		 */
		bindWithoutArgs: function (fn, args, thisArg) {
			return Array.isArray(args)
				? function () { return fn.apply(thisArg || this, args); }
				: function () { return fn.call(thisArg || this); }
			;
		},


		/**
		 * Создать массив элементов
		 * @param {number} length
		 * @returns {number[]}
		 */
		range: function (length) {
			var array = [],
				i = 0;

			for (; i < length; i++) {
				array.push(i);
			}

			return array;
		}
	};


	function _cancelDebounce() {
		/* jshint validthis:true */
		clearTimeout(this.pid);
	}


	// Export
	util.version = '0.3.0';
	return util;
});

/**
 * User Timing polyfill (http://www.w3.org/TR/user-timing/)
 * @author RubaXa <trash@rubaxa.org>
 */
(function (window){
	var
		  startOffset = Date.now ? Date.now() : +(new Date)
		, performance = window.performance || {}

		, _entries = []
		, _marksIndex = {}

		, _filterEntries = function (key, value){
			var i = 0, n = _entries.length, result = [];
			for( ; i < n; i++ ){
				if( _entries[i][key] == value ){
					result.push(_entries[i]);
				}
			}
			return	result;
		}

		, _clearEntries = function (type, name){
			var i = _entries.length, entry;
			while( i-- ){
				entry = _entries[i];
				if( entry.entryType == type && (name === void 0 || entry.name == name) ){
					_entries.splice(i, 1);
				}
			}
		}
	;


	if( !performance.now ){
		performance.now = performance.webkitNow || performance.mozNow || performance.msNow || function (){
			return (Date.now ? Date.now() : +(new Date)) - startOffset;
		};
	}


	if( !performance.mark ){
		performance.mark = performance.webkitMark || function (name){
			var mark = {
				  name:			name
				, entryType:	'mark'
				, startTime:	performance.now()
				, duration:		0
			};
			_entries.push(mark);
			_marksIndex[name] = mark;
		};
	}


	if( !performance.measure ){
		performance.measure = performance.webkitMeasure || function (name, startMark, endMark){
			startMark	= _marksIndex[startMark].startTime;
			endMark		= _marksIndex[endMark].startTime;

			_entries.push({
				  name:			name
				, entryType:	'measure'
				, startTime:	startMark
				, duration:		endMark - startMark
			});
		};
	}


	if( !performance.getEntriesByType ){
		performance.getEntriesByType = performance.webkitGetEntriesByType || function (type){
			return _filterEntries('entryType', type);
		};
	}


	if( !performance.getEntriesByName ){
		performance.getEntriesByName = performance.webkitGetEntriesByName || function (name){
			return _filterEntries('name', name);
		};
	}


	if( !performance.clearMarks ){
		performance.clearMarks = performance.webkitClearMarks || function (name){
			_clearEntries('mark', name);
		};
	}


	if( !performance.clearMeasures ){
		performance.clearMeasures = performance.webkitClearMeasures || function (name){
			_clearEntries('measure', name);
		};
	}


	// exports
	window.performance = performance;

	if( typeof define === 'function' && (define.amd || define.ajs) ){
		define('performance', [], function (){ return performance });
	}
})(window);

/**
 * @author RubaXa <trash@rubaxa.org>
 * @license MIT
 */
(function () {
	"use strict";


	function _then(promise, method, callback) {
		return function () {
			var args = arguments, retVal;

			/* istanbul ignore else */
			if (typeof callback === 'function') {
				try {
					retVal = callback.apply(promise, args);
				} catch (err) {
					promise.reject(err);
					return;
				}

				if (retVal && typeof retVal.then === 'function') {
					if (retVal.done && retVal.fail) {
						retVal.__noLog = true;
						retVal.done(promise.resolve).fail(promise.reject);
						retVal.__noLog = false;
					}
					else {
						retVal.then(promise.resolve, promise.reject);
					}
					return;
				} else {
					args = [retVal];
					method = 'resolve';
				}
			}

			promise[method].apply(promise, args);
		};
	}


	/**
	 * «Обещания» поддерживают как [нативный](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
	 * интерфейс, так и [$.Deferred](http://api.jquery.com/category/deferred-object/).
	 *
	 * @class Promise
	 * @constructs Promise
	 * @param   {Function}  [executor]
	 */
	var Promise = function (executor) {
		var _completed = false;

		function _finish(state, result) {
			dfd.done =
			dfd.fail = function () {
				return dfd;
			};

			dfd[state ? 'done' : 'fail'] = function (fn) {
				/* istanbul ignore else */
				if (typeof fn === 'function') {
					fn(result);
				}
				return dfd;
			};

			var fn,
				fns = state ? _doneFn : _failFn,
				i = 0,
				n = fns.length
			;

			for (; i < n; i++) {
				fn = fns[i];
				/* istanbul ignore else */
				if (typeof fn === 'function') {
					fn(result);
				}
			}

			fns = _doneFn = _failFn = null;
		}


		function _setState(state) {
			return function (result) {
				if (_completed) {
					return dfd;
				}

				_completed = true;

				dfd.resolve =
				dfd.reject = function () {
					return dfd;
				};

				if (state && result && result.then && result.pending !== false) {
					// Опачки!
					result.then(
						function (result) { _finish(true, result); },
						function (result) { _finish(false, result); }
					);
				}
				else {
					_finish(state, result);
				}

				return dfd;
			};
		}

		var
			_doneFn = [],
			_failFn = [],

			dfd = {
				/**
				 * Добавляет обработчик, который будет вызван, когда «обещание» будет «разрешено»
				 * @param  {Function}  fn  функция обработчик
				 * @returns {Promise}
				 * @memberOf Promise#
				 */
				done: function done(fn) {
					_doneFn.push(fn);
					return dfd;
				},

				/**
				 * Добавляет обработчик, который будет вызван, когда «обещание» будет «отменено»
				 * @param  {Function}  fn  функция обработчик
				 * @returns {Promise}
				 * @memberOf Promise#
				 */
				fail: function fail(fn) {
					_failFn.push(fn);
					return dfd;
				},

				/**
				 * Добавляет сразу два обработчика
				 * @param   {Function}   [doneFn]   будет выполнено, когда «обещание» будет «разрешено»
				 * @param   {Function}   [failFn]   или когда «обещание» будет «отменено»
				 * @returns {Promise}
				 * @memberOf Promise#
				 */
				then: function then(doneFn, failFn) {
					var promise = Promise();

					dfd.__noLog = true; // для логгера

					dfd
						.done(_then(promise, 'resolve', doneFn))
						.fail(_then(promise, 'reject', failFn))
					;

					dfd.__noLog = false;

					return promise;
				},

				notify: function () { // jQuery support
					return dfd;
				},

				progress: function () { // jQuery support
					return dfd;
				},

				promise: function () { // jQuery support
					// jQuery support
					return dfd;
				},

				/**
				 * Добавить обработчик «обещаний» в независимости от выполнения
				 * @param   {Function}   fn   функция обработчик
				 * @returns {Promise}
				 * @memberOf Promise#
				 */
				always: function always(fn) {
					dfd.done(fn).fail(fn);
					return dfd;
				},


				/**
				 * «Разрешить» «обещание»
				 * @param    {*}  result
				 * @returns  {Promise}
				 * @method
				 * @memberOf Promise#
				 */
				resolve: _setState(true),


				/**
				 * «Отменить» «обещание»
				 * @param   {*}  result
				 * @returns {Promise}
				 * @method
				 * @memberOf Promise#
				 */
				reject: _setState(false)
			}
		;


		/**
		 * @name  Promise#catch
		 * @alias fail
		 * @method
		 */
		dfd['catch'] = function (fn) {
			return dfd.then(null, fn);
		};


		dfd.constructor = Promise;


		// Работеам как native Promises
		/* istanbul ignore else */
		if (typeof executor === 'function') {
			try {
				executor(dfd.resolve, dfd.reject);
			} catch (err) {
				dfd.reject(err);
			}
		}

		return dfd;
	};


	/**
	 * Дождаться «разрешения» всех обещаний
	 * @static
	 * @memberOf Promise
	 * @param    {Array} iterable  массив значений/обещаний
	 * @returns  {Promise}
	 */
	Promise.all = function (iterable) {
		var dfd = Promise(),
			d,
			i = 0,
			n = iterable.length,
			remain = n,
			values = [],
			_fn,
			_doneFn = function (i, val) {
				(i >= 0) && (values[i] = val);

				/* istanbul ignore else */
				if (--remain <= 0) {
					dfd.resolve(values);
				}
			},
			_failFn = function (err) {
				dfd.reject([err]);
			}
		;

		if (remain === 0) {
			_doneFn();
		}
		else {
			for (; i < n; i++) {
				d = iterable[i];

				if (d && typeof d.then === 'function') {
					_fn = _doneFn.bind(null, i); // todo: тест

					d.__noLog = true;

					if (d.done && d.fail) {
						d.done(_fn).fail(_failFn);
					} else {
						d.then(_fn, _failFn);
					}

					d.__noLog = false;
				}
				else {
					_doneFn(i, d);
				}
			}
		}

		return dfd;
	};


	/**
	 * Дождаться «разрешения» всех обещаний и вернуть результат последнего
	 * @static
	 * @memberOf Promise
	 * @param    {Array}   iterable   массив значений/обещаний
	 * @returns  {Promise}
	 */
	Promise.race = function (iterable) {
		return Promise.all(iterable).then(function (values) {
			return values.pop();
		});
	};


	/**
	 * Привести значение к «Обещанию»
	 * @static
	 * @memberOf Promise
	 * @param    {*}   value    переменная или объект имеющий метод then
	 * @returns  {Promise}
	 */
	Promise.cast = function (value) {
		var promise = Promise().resolve(value);
		return value && typeof value.then === 'function'
			? promise.then(function () { return value; })
			: promise
		;
	};


	/**
	 * Вернуть «разрешенное» обещание
	 * @static
	 * @memberOf Promise
	 * @param    {*}   value    переменная
	 * @returns  {Promise}
	 */
	Promise.resolve = function (value) {
		return (value && value.constructor === Promise) ? value : Promise().resolve(value);
	};


	/**
	 * Вернуть «отклоненное» обещание
	 * @static
	 * @memberOf Promise
	 * @param    {*}   value    переменная
	 * @returns  {Promise}
	 */
	Promise.reject = function (value) {
		return Promise().reject(value);
	};


	/**
	 * Дождаться «разрешения» всех обещаний
	 * @param   {Object}  map «Ключь» => «Обещание»
	 * @returns {Promise}
	 */
	Promise.map = function (map) {
		var array = [], key, idx = 0, results = {};

		for (key in map) {
			array.push(map[key]);
		}

		return Promise.all(array).then(function (values) {
			/* jshint -W088 */
			for (key in map) {
				results[key] = values[idx++];
			}

			return results;
		});
	};



	// Версия модуля
	Promise.version = "0.3.1";


	/* istanbul ignore else */
	if (!window.Promise) {
		window.Promise = Promise;
	}


	// exports
	if (typeof define === "function" && (define.amd || /* istanbul ignore next */ define.ajs)) {
		define('Promise', [], function () {
			return Promise;
		});
	} else if (typeof module != "undefined" && module.exports) {
		module.exports = Promise;
	}
	else {
		window.Deferred = Promise;
	}
})();

/**
 * @author RubaXa <trash@rubaxa.org>
 * @license MIT
 */
(function () {
	"use strict";

	var RDASH = /-/g,
		RSPACE = /\s+/,

		r_camelCase = /-(.)/g,
		camelCase = function (_, chr) {
			return chr.toUpperCase();
		},

		hasOwn = ({}).hasOwnProperty,
		emptyArray = [],

		returnTrue = function () {
			return true;
		}
	;



	/**
	 * Получить список слушателей
	 * @param    {Object}  target
	 * @param    {string}  name
	 * @returns  {Array}
	 * @memberOf Emitter
	 */
	function getListeners(target, name) {
		var list = target.__emList;

		name = name.toLowerCase().replace(RDASH, '');

		if (list === void 0) {
			list = target.__emList = {};
			list[name] = [];
		}
		else if (list[name] === void 0) {
			list[name] = [];
		}

		return list[name];
	}



	/**
	 * Излучатель событий
	 * @class Emitter
	 * @constructs Emitter
	 */
	var Emitter = function () {
	};
	Emitter.fn = Emitter.prototype = /** @lends Emitter# */ {
		constructor: Emitter,


		/**
		 * Прикрепить обработчик для одного или нескольких событий, поддерживается `handleEvent`
		 * @param   {string}    events  одно или несколько событий, разделенных пробелом
		 * @param   {Function}  fn      функция обработчик
		 * @returns {Emitter}
		 */
		on: function (events, fn) {
			events = events.split(RSPACE);

			var n = events.length, list;

			while (n--) {
				list = getListeners(this, events[n]);
				list.push(fn);
			}

			return this;
		},


		/**
		 * Удалить обработчик для одного или нескольких событий
		 * @param   {string}    [events]  одно или несколько событий, разделенных пробелом
		 * @param   {Function}  [fn]      функция обработчик, если не передать, будут отвязаны все обработчики
		 * @returns {Emitter}
		 */
		off: function (events, fn) {
			if (events === void 0) {
				this.__emList = events;
			}
			else {
				events = events.split(RSPACE);

				var n = events.length;

				while (n--) {
					var list = getListeners(this, events[n]), i = list.length, idx = -1;

					if (arguments.length === 1) {
						list.splice(0, 1e5); // dirty hack
					} else {
						if (list.indexOf) {
							idx = list.indexOf(fn);
						} else { // old browsers
							while (i--) {
								/* istanbul ignore else */
								if (list[i] === fn) {
									idx = i;
									break;
								}
							}
						}

						if (idx !== -1) {
							list.splice(idx, 1);
						}
					}
				}
			}

			return this;
		},


		/**
		 * Прикрепить обработчик события, который выполняется единожды
		 * @param   {string}    events  событие или список
		 * @param   {Function}  fn      функция обработчик
		 * @returns {Emitter}
		 */
		one: function (events, fn) {
			var proxy = function () {
				this.off(events, proxy);
				return fn.apply(this, arguments);
			};

			return this.on(events, proxy);
		},


		/**
		 * Распространить событие
		 * @param   {string}  type    тип события
		 * @param   {Array}   [args]  аргумент или массив аргументов
		 * @returns {*}
		 */
		emit: function (type, args) {
			var list = getListeners(this, type),
				i = list.length,
				fn,
				ctx,
				tmp,
				retVal,
				argsLength
			;

			type = 'on' + type.charAt(0).toUpperCase() + type.substr(1);

			if (type.indexOf('-') > -1) {
				type = type.replace(r_camelCase, camelCase);
			}

			if (typeof this[type] === 'function') {
				retVal = this[type].apply(this, [].concat(args));
			}

			if (i > 0) {
				args = args === void 0 ? emptyArray : [].concat(args);
				argsLength = args.length;

				while (i--) {
					fn = list[i];
					ctx = this;

					/* istanbul ignore else */
					if (fn !== void 0) {
						if (fn.handleEvent !== void 0) {
							ctx = fn;
							fn = fn.handleEvent;
						}

						if (argsLength === 0) {
							tmp = fn.call(ctx);
						}
						else if (argsLength === 1) {
							tmp = fn.call(ctx, args[0]);
						}
						else if (argsLength === 2) {
							tmp = fn.call(ctx, args[0], args[1]);
						}
						else {
							tmp = fn.apply(ctx, args);
						}

						if (tmp !== void 0) {
							retVal = tmp;
						}
					}
				}
			}

			return retVal;
		},


		/**
		 * Распространить `Emitter.Event`
		 * @param   {string}  type    тип события
		 * @param   {Array}   [args]  аргумент или массив аргументов
		 * @returns {Emitter}
		 */
		trigger: function (type, args) {
			var evt = new Event(type);
			evt.target = evt.target || this;
			evt.result = this.emit(type.type || type, [evt].concat(args));
			return this;
		}
	};



	/**
	 * Событие
	 * @class Emitter.Event
	 * @constructs Emitter.Event
	 * @param   {string|Object|Event}  type  тип события
	 * @returns {Emitter.Event}
	 */
	function Event(type) {
		if (type instanceof Event) {
			return type;
		}

		if (type.type) {
			for (var key in type) {
				/* istanbul ignore else */
				if (hasOwn.call(type, key)) {
					this[key] = type[key];
				}
			}

			type = type.type;
		}

		this.type = type.toLowerCase().replace(RDASH, '');
	}

	Event.fn = Event.prototype = /** @lends Emitter.Event# */ {
		constructor: Event,

		/**
		 * Позволяет определить, было ли отменено действие по умолчанию
		 * @returns {boolean}
		 */
		isDefaultPrevented: function () {
			return false;
		},


		/**
		 * Отменить действие по умолчанию
		 */
		preventDefault: function () {
			this.isDefaultPrevented = returnTrue;
		}
	};


	/**
	 * Подмешать методы к объекту
	 * @static
	 * @memberof Emitter
	 * @param   {Object}  target    цель
	 * @returns {Object}
	 */
	Emitter.apply = function (target) {
		target.on = Emitter.fn.on;
		target.off = Emitter.fn.off;
		target.one = Emitter.fn.one;
		target.emit = Emitter.fn.emit;
		target.trigger = Emitter.fn.trigger;
		return target;
	};


	// Версия модуля
	Emitter.version = "0.2.3";


	// exports
	Emitter.Event = Event;
	Emitter.getListeners = getListeners;


	if (typeof define === "function" && (define.amd || /* istanbul ignore next */ define.ajs)) {
		define('Emitter', [], function () {
			return Emitter;
		});
	} else if (typeof module != "undefined" && module.exports) {
		module.exports = Emitter;
	} else {
		window.Emitter = Emitter;
	}
})();

define('logger', [
	'uuid',
	'utils/util',
	'performance',
	'Promise',
	'Emitter'
], function (
	/** uuid */uuid,
	/** util */util,
	/** performance */performance,
	/** Promise */Promise,
	/** Emitter */Emitter
) {
	'use strict';


	/**
	 * @typedef   {Object}  LoggerMeta
	 * @property  {string}  fn     название метода
	 * @property  {strong}  file   путь к файлу
	 * @property  {number}  line
	 * @property  {number}  column
	 */


	var gid = 1,
		getListeners = Emitter.getListeners,
		encodeURIComponent = window.encodeURIComponent,

		RSPACE = /\s+/,

		index = {},
		entries = []
	;


	function _getPromiseName(entry, added) {
		return '[[' + entry.label.replace(/(:pending|^\[\[|\]\]$)/g, '') + ':' + added + ']]';
	}


	/**
	 * @namespace logger
	 * @class logger
	 * @type Object
	 * @description Глобальный объект логирования
	 */
	var logger = /** @lends logger */{
		index: index,
		parentId: 0,
		metaOffset: 0,


		/**
		 * Статус работы логера
		 * @type {boolean}
		 */
		disabled: false,


		/**
		 * Массив записей
		 * @type {logger.Entry[]}
		 */
		entries: entries,


		/**
		 * Использовать UUID идетификатор в качестве id записи
		 * @type {boolean}
		 */
		useUUID: false,


		/**
		 * Генерация UUID
		 * @name logger.uuid
		 * @method
		 * @static
		 * @memberOf logger
		 * @returns  {string}
		 */
		uuid: uuid,


		/**
		 * Добавить лог-запись
		 * @param  {string}  label  метка
		 * @param  {*}       args   аргументы для логирования
		 * @param  {*}       [parentId]
		 * @param  {LoggerMeta} [meta]
		 * @return {logger.Entry}
		 */
		add: function (label, args, parentId, meta) {
			if (logger.disabled) {
				return this;
			}

			logger.metaOffset = 1;
			return this.addEntry('log', label, args, parentId, meta);
		},


		/**
		 * Функция фитрации аргументов
		 * @param  {*}  args
		 * @return {*}
		 */
		filterArguments: function (args) {
			return args;
		},


		/**
		 * Создать scope
		 * @param  {string} label
		 * @param  {*} args
		 * @param  {LoggerMeta|number} [meta]  числом можно передать смещение (metaOffset) по stack
		 * @param  {number} [parentId]
		 * @return {logger.Entry}
		 */
		scope: function (label, args, meta, parentId) {
			/* jshint eqnull:true */
			if (meta == null) {
				meta = -2;
			}

			/* istanbul ignore next */
			if (meta >= -99) {
				meta = logger.meta(meta);
			}

			logger.metaOffset = 1;
			return this.addEntry('scope', label, args, parentId, meta);
		},


		/**
		 * Добавить запись
		 * @param   {string|Entry}  type        тип записи (scope, log)
		 * @param   {string}        [label]     метка
		 * @param   {*}             [args]      аргументы
		 * @param   {*}             [parentId]  id родителя
		 * @param   {LoggerMeta}    [meta]
		 * @return  {logger.Entry}
		 */
		addEntry: function (type, label, args, parentId, meta) {
			logger.metaOffset += 1;

			var entry = type instanceof Entry ? type : new Entry(type, label, args, parentId || this.parentId, meta);

			index[entry.id] = entry;
			entry.idx = entries.push(entry) - 1;

			this._emit();

			return entry;
		},


		/**
		 * Получить «родительскую» запись
		 * @param   {*} id
		 * @param   {string} label
		 * @returns {*}
		 */
		closest: function (id, label) {
			var entry;

			id = id.id || id;

			while ((entry = index[id]) && id) {
				id = entry.parentId;

				if (entry.label === label) {
					return entry;
				}
			}

			return null;
		},


		/**
		 * Получить лог-цепочу по id записи
		 * @param   {number}  id
		 * @param   {string}  [glue]
		 * @returns {Array}
		 */
		chain: function (id, glue) {
			var log = [], entry;

			while ((entry = index[id]) && id) {
				id = entry.parentId;
				log.push(entry);
			}

			log.reverse();

			if (glue) {
				log = log.map(function (entry) {
					return '[' + entry.id + '] ' + entry.label;
				}).join(glue);
			}

			return log;
		},


		/**
		 * Получить лог-scope
		 * @param   {string}  name   scope-название
		 * @param   {*}       args   аргументы
		 * @param   {*}       [parentId]
		 * @param   {LoggerMeta}  [meta]
		 * @returns {Object}
		 */
		getScope: function (name, args, parentId, meta) {
			logger.metaOffset += 1;
			return typeof name === 'string' ? this.addEntry('scope', name, args, parentId, meta) : name;
		},


		/**
		 * Обернуть фунцию или Promise в лог-scope
		 * @param   {string}     name  scope-название
		 * @param   {*}          args  метод или аргументы
		 * @param   {Function}   [fn]  метод
		 * @param   {number}     [parentId]
		 * @param   {LoggerMeta} [meta]
		 * @returns {Function|Promise}
		 */
		wrap: function (name, args, fn, parentId, meta) {
			if (arguments.length === 1) {
				fn = name;
				name = index[logger.parentId];
			}
			else if (fn === void 0) {
				fn = args;
				args = void 0;
			}

			if (fn && !fn.__logger__ && !this.disabled) {
				logger.metaOffset += 1;

				meta = meta || logger.meta();

				if (typeof fn === 'function') {
					var wrapper = function () {
						var entry = logger.getScope(name, args, parentId, meta),
							_parentId = logger.parentId,
							retVal;

						logger.parentId = entry.id;
						logger.metaOffset += 1;

						retVal = logger.wrap(entry, fn.apply(this, arguments));

						logger.parentId = _parentId;

						return retVal;
					};

					fn.__logger__ = true;
					wrapper.__logger__ = true;

					return wrapper;
				}
				else if (fn.then) {
					logger.getScope(name, args, null, meta).wrap(fn);
				}
			}

			logger.metaOffset = 0;

			return fn;
		},


		/**
		 * Выполнить метод в лог-конексте
		 * @param   {string} label
		 * @param   {*} args
		 * @param   {Function} fn
		 * @returns {*}
		 */
		call: function (label, args, fn) {
			logger.metaOffset += 1;
			return this.wrap(label, args, fn)();
		},


		/**
		 * Сбросить лог
		 */
		reset: function () {
			gid = 1;

			this.index = index = {};
			this.entries = entries = [];
			this.parentId = 0;
		},


		/**
		 * Вывод лога в консоль
		 * @param   {boolean} [ret]  вернуть лог строкой
		 * @returns {string|undefined}
		 */
		print: function (ret) {
			var groups = {},
				depends = {},
				retLog = '';


			entries.forEach(function (entry) {
				var id = entry.parentId;
				(groups[id] = groups[id] || []).push(entry);
			});


			(function _print(id, indent) {
				var entries = groups[id] || [],
					i = 0,
					n = entries.length,
					entry,
					log
				;

				for (; i < n; i++) {
					entry = entries[i];
					log = ('[' + entry.id + ':' + entry.parentId + '] ' + entry.label)
						+ (entry.args ? ': ' + JSON.stringify(entry.args) : '')
						//+ (' | ' + entry.meta.file + ':' + entry.meta.line + ':' + entry.meta.column)
					;


					/* istanbul ignore else */
					if (groups[entry.id]) {
						/* istanbul ignore else */
						if (ret) {
							retLog += indent + log + '\n';
							_print(entry.id, '  ' + indent);
						}
						else {
							console.group(log);
							_print(entry.id);
							console.groupEnd();
						}
					}
					else if (ret) {
						retLog += indent + log + '\n';
					}
					else {
						console.log(log);
					}
				}
			})(0, '');


			return ret && retLog;
		},


		/**
		 * Подписаться на добавление записи
		 * @param   {string}   labels
		 * @param   {Function} fn
		 * @returns {logger}
		 */
		on: function (labels, fn) {
			labels = labels.trim().split(RSPACE);

			var i = labels.length, label;

			while (i--) {
				label = labels[i].split(':');
				getListeners(this, label[1] || label[0]).push({
					fn: fn,
					label: label[1] || label[0],
					parent: label[1] && label[0]
				});
			}

			return this;
		},


		/**
		 * Отписаться от добавление записи
		 * @param   {string}   labels
		 * @param   {Function} fn
		 * @returns {logger}
		 */
		off: function (labels, fn) {
			labels = labels.trim().split(RSPACE);

			var i = labels.length, label, list, j, handle;

			while (i--) {
				label = labels[i].split(':');
				list = getListeners(this, label[1] || label[0]);
				j = list.length;

				while (j--) {
					handle = list[j];

					if (handle.fn === fn && (handle.parent === (label[1] && label[0]))) {
						list.splice(j, 1);
					}
				}
			}

			return this;
		},


		/**
		 * Испускаем события
		 * @private
		 */
		_emit: function () {
			var entry,
				parentEntry,
				list,
				e = entries.length,
				i,
				handle
			;

			while (e--) {
				entry = entries[e];

				if (!entry.emitted) {
					entry.emitted = true;
					list = getListeners(this, entry.label);
					i = list.length;

					while (i--) {
						handle = list[i];

						if (handle.parent) {
							parentEntry = this.closest(entry.id, handle.parent);

							/* istanbul ignore else */
							if (parentEntry) {
								handle.fn(parentEntry, entry);
							}
						}
						else {
							handle.fn(entry);
						}
					}
				}
			}
		},


		last: function () {
			return entries[entries.length - 1];
		},


		//spy: function (obj) {
		//	function getArgDesc(arg) {
		//		if (typeof arg === 'function') {
		//			return (arg.displayName = '<' + (arg.name || 'anonymous') + '>');
		//		}
		//
		//		return ('' + arg);
		//	}
		//
		//
		//	function wrapMethod(method) {
		//		var mutator = createMutator(method);
		//
		//		return function () {
		//			var args = mutator.apply(arguments);
		//			return logger.wrap(method.displayName, args, method).apply(this, arguments);
		//		};
		//	}
		//
		//
		//	function createMutator(fn) {
		//		var code = fn.toString().replace(/\/\*.*?\//g, ''),
		//			argsDesc = code.match(/\((.*?)\)/)[1].split(/\s*,\s*/),
		//			argsLength = argsDesc.length;
		//
		//		return {
		//			args: argsDesc,
		//
		//			apply: function (args) {
		//				var i = 0,
		//					n = Math.max(argsLength, args.length),
		//					logArgs = {},
		//					arg;
		//
		//				for (; i < n; i++) {
		//					arg = args[i];
		//					logArgs[argsDesc[i] || ('#' + i)] = getArgDesc(arg);
		//
		//					if (typeof arg === 'function') {
		//						args[i] = wrapMethod(arg);
		//					}
		//				}
		//
		//				args = null;
		//
		//				return logArgs;
		//			}
		//		};
		//	}
		//
		//
		//	Object.keys(obj).forEach(function (method) {
		//		var originalFn = obj[method];
		//
		//		if (typeof originalFn === 'function') {
		//			var mutator = createMutator(originalFn);
		//
		//			obj[method] = function () {
		//				var args = mutator.apply(arguments);
		//				return logger.wrap(method, args, originalFn).apply(this, arguments);
		//			};
		//		}
		//	});
		//
		//	return obj;
		//},


		/**
		 * Получить текущую мета информацию
		 * @param  {number} [offset]
		 * @return {LoggerMeta}
		 */
		meta: function (offset) {
			var meta,
				upMeta,
				stack,
				index = 1;

			Error.stackTraceLimit = 30;

			try {
				this.__throw();
			} catch (err) {
				/* istanbul ignore else */
				if (err.stack !== void 0) {
					stack = (err.stack + '').split('\n');
					index += /^TypeError/.test(stack[0]) + (-offset || logger.metaOffset);

					logger.metaOffset = 0;

					meta = this.parseStackRow(stack[index]);

					if (meta) {
						upMeta = this.parseStackRow(stack[index - 1]);

						/* jshint expr:true */
						upMeta && (meta.fn = upMeta.fn);
					}
					//meta.stack = stack;
				}
			}

			Error.stackTraceLimit = 10;

			/* istanbul ignore next */
			return meta ? meta : { fn: 'unknown', file: 'unknown', line: 0, column: 0 };
		},


		/**
		 * Разобрать строчку из стека
		 * @return {LoggerMeta}
		 */
		parseStackRow: function (value) {
			value += '';

			var match = value.match(/at\s+([^\s]+)(?:.*?)\(((?:http|file|\/)[^)]+:\d+)\)/),
				file;

			/* istanbul ignore next */
			if (!match) {
				match = value.match(/at\s+(.+)/);

				if (!match) {
					match = value.match(/^(.*?)(?:\/<)*@(.*?)$/) || value.match(/^()(https?:\/\/.+)/);
				} else {
					match[0] = '<anonymous>';
					match.unshift('');
				}
			}

			/* istanbul ignore next */
			if (match) {
				file = match[2].match(/^(.*?):(\d+)(?::(\d+))?$/) || [];
				match = {
					fn: (match[1] || '<anonymous>').trim(),
					file: file[1],
					line: file[2]|0,
					column: file[3]|0
				};
			}
			else {
				match = null;
			}

			return match;
		},


		/**
		 * Сериализовать лог
		 * @return {string}
		 */
		serialize: function () {
			return JSON.stringify(entries);
		},


		/**
		 * Отправить на почту
		 * @param {string} email
		 */
		mailTo: /* istanbul ignore next */ function (email) {
			var el = document.createElement('a');
			el.href = 'mailto:' + email
					+ '?subject=' + encodeURIComponent('[logger] ' + new Date())
					+ '&body=' + encodeURIComponent(this.serialize());
			el.innerHTML = 'send';
			el.click();
		}
	};


	/**
	 * Описание записи лога
	 * @class  logger.Entry
	 * @param  {string}  type
	 * @param  {string}  [label]
	 * @param  {*}       [args]
	 * @param  {*}       [parentId]
	 */
	function Entry(type, label, args, parentId, meta) {
		/**
		 * Идетификатор записи
		 * @member {*} logger.Entry#id
		 */
		this.id = (args && args.uuid) || /* istanbul ignore next */(logger.useUUID ? uuid() : gid++);


		/**
		 * Относительное время добавления
		 * @member {number} logger.Entry#ts
		 */
		this.ts = performance.now();


		/**
		 * Тип записи
		 * @member {string} logger.Entry#type
		 */
		this.type = type;


		/**
		 * Метка записи
		 * @member {string} logger.Entry#label
		 */
		this.label = label + '';


		try {
			args = util.cloneJSON(logger.filterArguments(args));
		} catch (err) {
			args = err;
		}


		/**
		 * Аргумерты логирования
		 * @member {*} logger.Entry#args
		 */
		this.args = args;


		/**
		 * Id родительской записи
		 * @member {*} logger.Entry#parentId
		 */
		this.parentId = parentId;


		/**
		 * Список id связанных записей
		 * @member {Array} logger.Entry#linked
		 */
		this.linked = [];


		/**
		 * Мета информация (строка, файл, метод и т.п.)
		 * @type {LoggerMeta}
		 */
		logger.metaOffset += 1;
		this.meta = meta || logger.meta();
		logger.metaOffset = 0;
	}


	Entry.fn = Entry.prototype = /** @lends logger.Entry.prototype */ {
		constructor: Entry,


		/**
		 * Добавить связанную запись
		 * @param  {string}  label
		 * @param  {*}       [args]
		 * @return {logger.Entry}
		 */
		add: function (label, args) {
			return logger.add(label, args, this.id, this.meta);
		},


		/**
		 * Выполнить метод в лог-конексте
		 * @param  {string|Function}   label
		 * @param  {*}        args
		 * @param  {Function} fn
		 * @return {*}
		 */
		call: function (label, args, fn) {
			if (typeof label === 'function') {
				var parentId = logger.parentId,
					retVal;

				logger.parentId = this.id;
				retVal = this.wrap(args ? label.apply(null, args) : label());
				logger.parentId = parentId;

				return retVal;
			}

			return logger.wrap(label, args, fn, this.id, this.meta)();
		},


		wrap: function (obj) {
			if (typeof obj === 'function') {
				return logger.wrap(this, obj);
			}
			else if (obj && !obj.__logger__ && obj.then) {
				var then = obj.then,
					done = obj.done,
					fail = obj.fail,
					always = obj.always,
					logScope = this;


				obj.__logger__ = logScope;


				/* jshint expr:true */
				done && (obj.done = function (callback) {
					var noLog = obj.__noLog,
						meta = logger.meta(-1 - (obj.metaOffset|0));

					return done.call(obj, function () {
						(noLog
							? obj.__logger__
							: logger.addEntry('scope', _getPromiseName(logScope, 'done'), null, obj.__logger__.id, meta)
						).call(callback, arguments);
					});
				});


				/* jshint expr:true */
				fail && (obj.fail = function (callback) {
					var noLog = obj.__noLog,
						meta = logger.meta(-1 - (obj.metaOffset|0));

					return fail.call(obj, function () {
						(noLog
							? obj.__logger__
							: logger.addEntry('scope', _getPromiseName(logScope, 'fail'), null, obj.__logger__.id, meta)
						).call(callback, arguments);
					});
				});


				/* jshint expr:true */
				always && (obj.always = function (callback) {
					var meta = logger.meta(-1 - (obj.metaOffset|0)),
						retVal;

					obj.__noLog = true;

					retVal = always.call(obj, function () {
						logger
							.addEntry('scope', _getPromiseName(logScope, 'always'), null, obj.__logger__.id, meta)
								.call(callback, arguments);
					});

					obj.__noLog = false;

					return retVal;
				});


				obj['catch'] = function (callback) {
					return obj.then(null, callback, true);
				};


				obj.then = function (onResolved, onRejected, isCatch) {
					if (obj.__noLog) {
						return then.call(obj, onResolved, onRejected);
					}

					var meta = logger.meta(-1 - (obj.metaOffset|0) - !!isCatch),
						label = isCatch ? 'catch' : 'then',
						scope = new Entry('scope', '', null, logScope.id, meta);

					function resolved() {
						scope.label = _getPromiseName(logScope, label + ':resolved');
						logger.addEntry(scope);

						return scope.call(onResolved, arguments);
					}

					function rejected() {
						scope.label = _getPromiseName(logScope, label + ':rejected');
						logger.addEntry(scope);

						return scope.call(onRejected, arguments);
					}

					return scope.wrap(then.call(obj, onResolved ? resolved : null, onRejected ? rejected : null));
				};
			}

			return obj;
		},


		/**
		 * Создать связанный scope
		 * @param  {string} label
		 * @param  {*} [args]
		 * @param  {*} [meta]
		 */
		//scope: function (label, args, meta) {
		//	return logger.scope(label, args, meta || -3, this.id);
		//},


		/**
		 * Получить цепочку записей
		 * @param  {string} [glue]
		 * @returns {Array|string}
		 */
		chain: function (glue) {
			return logger.chain(this.id, glue);
		},


		pluck: function (key) {
			return this.chain().map(function (entry) {
				return entry[key];
			});
		},


		/**
		 * Получить родителя
		 * @return {logger.Entry}
		 */
		parent: function () {
			return index[this.parentId];
		},


		/**
		 * Получить JSON-объект
		 * @returns {Object}
		 */
		toJSON: function () {
			return {
				id: this.id,
				dependId: this.dependId,
				linked: this.linked,
				type: this.type,
				label: this.label,
				args: this.args,
				meta: this.meta
			};
		}
	};


	Function.prototype.logger = function (label, args) {
		return logger.wrap(label, args, this, null, logger.meta(-1));
	};


	// Export Entry
	logger.Entry = Entry;


	/**
	 * Логируемый setTimeout
	 * @param  {string}    name
	 * @param  {function}  callback
	 * @param  {number}    ms
	 */
	/* istanbul ignore next */
	window.setTimeoutLog = function (name, callback, ms) {};


	/**
	 * Логируемый setIntervalLog
	 * @param  {string}    name
	 * @param  {function}  callback
	 * @param  {number}    ms
	 */
	/* istanbul ignore next */
	window.setIntervalLog = function (name, callback, ms) {};


	['setTimeout', 'setInterval'].forEach(function (name) {
		var method = window[name];

		window[name + 'Log'] = function (label, callback, ms) {
			if (typeof callback !== 'function') {
				ms = callback;
				callback = label;
				label = name;
			}

			var scope = logger.scope('~' + label);
			return method(function () {
				scope.call(callback);
			}, ms);
		};
	});



	Promise.Log = function (name, executor) {
		if (executor) {
			name = '[[' + name + ']]';
		}
		else {
			executor = name;
			name = '[[promise]]';
		}

		return logger.scope(name, null, -2).call(function () {
			return new Promise(executor);
		});
	};


	// Export
	logger.version = '0.4.1';


	/* jshint boss:true */
	return (window.octolog = window.logger = logger);
});

/**
 * @author RubaXa <trash@rubaxa.org>
 * @license MIT
 */
(function () {
	"use strict";


	var R_SPACE = /\s+/,
		R_KEYCHAIN_CHECK = /[\[.\]]/,
		R_KEYCHAIN_SPLIT = /(?:\.|['"]?]?\.?\[['"]?|['"]?])/
	;


	/**
	 * Split строки по пробелу
	 * @private
	 * @param   {string} val
	 * @returns {Array}
	 */
	function _split(val) {
		return (val + '').trim().split(R_SPACE);
	}



	/**
	 * Проверить ключи на наличие и истинность
	 * @private
	 * @param   {object}  obj
	 * @param   {string}  keys
	 * @param   {boolean} [exists]
	 * @returns {boolean}
	 */
	function _check(obj, keys, exists) {
		var ret, i, key, not, min, max;

		/* istanbul ignore else */
		if (keys) {
			keys = _split(keys);
			i = keys.length;

			while (i--) {
				key = keys[i];
				not = false;

				if (key.charAt(0) === '!') {// НЕ ключ
					not = true;
					key = key.substr(1);
				}

				if (key.indexOf(':') !== -1) { // переданы аргументы
					key = key.split(':');
					min = key[1];
					max = key[2];
					key = key[0];
				}

				// Получаем значение ключа
				ret = _grep(obj, key);

				if (min !== void 0) { // сравниваем со значением ключа
					ret = (max === void 0)
							? (ret == min)
							: (ret >= min && ret <= max)
						;
				}

				if (exists) { // Проверка наличия ключа
					ret = ret !== void 0;
				} else { // Приводик к boolean
					ret = !!ret;
				}

				if (ret ^ not) { // применяем модификатор (т.е. XOR)
					return true;
				}
			}
		}

		return false;
	}


	/**
	 * Получить/установить/удалить значение по ключу
	 * @private
	 * @param   {object}  obj
	 * @param   {string}  key
	 * @param   {boolean} [set]
	 * @param   {*}       [value]
	 * @returns {*}
	 */
	function _grep(obj, key, set, value) {
		var isUnset = arguments.length === 3;

		if (R_KEYCHAIN_CHECK.test(key)) {
			var chain = key.split(R_KEYCHAIN_SPLIT),
				i = 0,
				n = chain.length,
				curObj = obj,
				prevObj = obj,
				lastKey
			;

			for (; i < n; i++) {
				key = chain[i];
				if (key !== '') {
					lastKey = key;

					if (curObj) {
						prevObj = curObj;
						curObj = curObj[key];
						if (set && !isUnset && !curObj) {
							prevObj[key] = curObj = {};
						}
					}
					else {
						return void 0;
					}
				}
			}

			if (set) {
				if (isUnset) {
					delete prevObj[lastKey];
				} else {
					prevObj[lastKey] = value;
				}
			}

			return curObj;
		}
		else {
			if (set) {
				if (isUnset) {
					delete obj[key];
				} else {
					obj[key] = value;
				}
			}
			return obj[key];
		}
	}



	/**
	 * Работа с конфигами/настройками
	 * @class config
	 * @constructs config
	 * @param   {Object}  [props]  конфиг
	 * @returns {config}
	 */
	var config = function (props) {
		if (!(this instanceof config)) {
			return	new config(props);
		}

		if (props) {
			this.set(props);
		}
	};


	config.fn = config.prototype = /** @lends config# */ {
		constructor: config,

		/**
		 * Проверить свойства на истинность
		 * @param   {string}  keys  название свойств, разделенных пробелом
		 * @returns {boolean}
		 */
		is: function (keys) {
			return _check(this, keys);
		},


		/**
		 * Проверить наличие свойства
		 * @param   {string}  keys  название свойств, разделенных пробелом
		 * @returns {boolean}
		 */
		has: function (keys) {
			return _check(this, keys, true);
		},


		/**
		 * Получить свойство
		 * @param   {string}  key    имя свойства
		 * @param   {*}       [def]  значение по умолчанию
		 * @returns {boolean}
		 */
		get: function (key, def) {
			var retVal = _grep(this, key);
			return retVal === void 0 ? def : retVal;
		},


		/**
		 * Назначить свойство
		 * @param   {Object|string} props   список свойств
		 * @param   {*}  [value]   значение
		 * @return  {config}
		 */
		set: function (props, value) {
			var _attrs = props;

			/* istanbul ignore else */
			if (typeof props !== 'object') {
				_attrs = {};
				_attrs[props] = value;
			}

			/* istanbul ignore else */
			if (_attrs instanceof Object) {
				for (var key in _attrs) {
					/* istanbul ignore else */
					if (_attrs.hasOwnProperty(key)) {
						_grep(this, key, true, _attrs[key]);
					}
				}
			}

			return this;
		},


		/**
		 * Удалить свойство
		 * @param   {string}  key   имя свойства
		 * @returns {config}
		 */
		unset: function (key) {
			var args = arguments, i = args.length;

			while (i--) {
				_grep(this, args[i], true);
			}

			return this;
		}
	};


	/**
	 * Подмешать методы к объекту
	 * @static
	 * @memberof config
	 * @param  {Object}  target  цель
	 * @returns {Object}  возвращает переданный объекь
	 */
	config.apply = function (target) {
		target.is = config.is;
		target.has = config.has;
		target.get = config.get;
		target.set = config.set;
		target.unset = config.unset;
		return	target;
	};


	// Создаем глобальный конфиг
	var globalConfig = config({ __version__: '0.1.0' }), key;
	for (key in globalConfig) {
		config[key] = globalConfig[key];
	}


	// Версия модуля
	config.version = "0.1.0";


	// Export
	if (typeof define === "function" && (define.amd || /* istanbul ignore next */ define.ajs)) {
		define('config', [], function () {
			return config;
		});
	} else if (typeof module != "undefined" && module.exports) {
		module.exports = config;
	} else {
		window.config = window.__config__ = config;
	}
})();

define('jquery.mockjax', [],function() {

	/*!
	 * MockJax - jQuery Plugin to Mock Ajax requests
	 *
	 * Version:  1.5.3
	 * Released:
	 * Home:   http://github.com/appendto/jquery-mockjax
	 * Author:   Jonathan Sharp (http://jdsharp.com)
	 * License:  MIT,GPL
	 *
	 * Copyright (c) 2011 appendTo LLC.
	 * Dual licensed under the MIT or GPL licenses.
	 * http://appendto.com/open-source-licenses
	 */
	(function($) {
		var _ajax = $.ajax,
			mockHandlers = [],
			mockedAjaxCalls = [],
			CALLBACK_REGEX = /=\?(&|$)/,
			jsc = (new Date()).getTime();


		// Parse the given XML string.
		function parseXML(xml) {
			if ( window.DOMParser == undefined && window.ActiveXObject ) {
				DOMParser = function() { };
				DOMParser.prototype.parseFromString = function( xmlString ) {
					var doc = new ActiveXObject('Microsoft.XMLDOM');
					doc.async = 'false';
					doc.loadXML( xmlString );
					return doc;
				};
			}

			try {
				var xmlDoc = ( new DOMParser() ).parseFromString( xml, 'text/xml' );
				if ( $.isXMLDoc( xmlDoc ) ) {
					var err = $('parsererror', xmlDoc);
					if ( err.length == 1 ) {
						throw('Error: ' + $(xmlDoc).text() );
					}
				} else {
					throw('Unable to parse XML');
				}
				return xmlDoc;
			} catch( e ) {
				var msg = ( e.name == undefined ? e : e.name + ': ' + e.message );
				$(document).trigger('xmlParseError', [ msg ]);
				return undefined;
			}
		}

		// Trigger a jQuery event
		function trigger(s, type, args) {
			(s.context ? $(s.context) : $.event).trigger(type, args);
		}

		// Check if the data field on the mock handler and the request match. This
		// can be used to restrict a mock handler to being used only when a certain
		// set of data is passed to it.
		function isMockDataEqual( mock, live ) {
			var identical = true;
			// Test for situations where the data is a querystring (not an object)
			if (typeof live === 'string') {
				// Querystring may be a regex
				return $.isFunction( mock.test ) ? mock.test(live) : mock == live;
			}
			$.each(mock, function(k) {
				if ( live[k] === undefined ) {
					identical = false;
					return identical;
				} else {
					// This will allow to compare Arrays
					if ( typeof live[k] === 'object' && live[k] !== null ) {
						identical = identical && isMockDataEqual(mock[k], live[k]);
					} else {
						if ( mock[k] && $.isFunction( mock[k].test ) ) {
							identical = identical && mock[k].test(live[k]);
						} else {
							identical = identical && ( mock[k] == live[k] );
						}
					}
				}
			});

			return identical;
		}

		// See if a mock handler property matches the default settings
		function isDefaultSetting(handler, property) {
			return handler[property] === $.mockjaxSettings[property];
		}

		// Check the given handler should mock the given request
		function getMockForRequest( handler, requestSettings ) {
			// If the mock was registered with a function, let the function decide if we
			// want to mock this request
			if ( $.isFunction(handler) ) {
				return handler( requestSettings );
			}

			// Inspect the URL of the request and check if the mock handler's url
			// matches the url for this ajax request
			if ( $.isFunction(handler.url.test) ) {
				// The user provided a regex for the url, test it
				if ( !handler.url.test( requestSettings.url ) ) {
					return null;
				}
			} else {
				// Look for a simple wildcard '*' or a direct URL match
				var star = handler.url.indexOf('*');
				if (handler.url !== requestSettings.url && star === -1 ||
					!new RegExp(handler.url.replace(/[-[\]{}()+?.,\\^$|#\s]/g, "\\$&").replace(/\*/g, '.+')).test(requestSettings.url)) {
					return null;
				}
			}

			// Inspect the data submitted in the request (either POST body or GET query string)
			if ( handler.data && requestSettings.data ) {
				if ( !isMockDataEqual(handler.data, requestSettings.data) ) {
					// They're not identical, do not mock this request
					return null;
				}
			}
			// Inspect the request type
			if ( handler && handler.type &&
				handler.type.toLowerCase() != requestSettings.type.toLowerCase() ) {
				// The request type doesn't match (GET vs. POST)
				return null;
			}

			return handler;
		}

		// Process the xhr objects send operation
		function _xhrSend(mockHandler, requestSettings, origSettings) {
			if( mockHandler.once ){
				$.mockjaxClear(mockHandler.mockId);
			}

			// This is a substitute for < 1.4 which lacks $.proxy
			var process = (function(that) {
				return function() {
					return (function() {
						var onReady;

						// The request has returned
						this.status     = mockHandler.status;
						this.statusText = mockHandler.statusText;
						this.readyState	= 4;

						// We have an executable function, call it to give
						// the mock handler a chance to update it's data
						if ( $.isFunction(mockHandler.response) ) {
							mockHandler.response(origSettings);
						}
						// Copy over our mock to our xhr object before passing control back to
						// jQuery's onreadystatechange callback
						if ( requestSettings.dataType == 'json' && ( typeof mockHandler.responseText == 'object' ) ) {
							this.responseText = JSON.stringify(mockHandler.responseText);
						} else if ( requestSettings.dataType == 'xml' ) {
							if ( typeof mockHandler.responseXML == 'string' ) {
								this.responseXML = parseXML(mockHandler.responseXML);
								//in jQuery 1.9.1+, responseXML is processed differently and relies on responseText
								this.responseText = mockHandler.responseXML;
							} else {
								this.responseXML = mockHandler.responseXML;
							}
						} else {
							this.responseText = mockHandler.responseText;
						}
						if( typeof mockHandler.status == 'number' || typeof mockHandler.status == 'string' ) {
							this.status = mockHandler.status;
						}
						if( typeof mockHandler.statusText === "string") {
							this.statusText = mockHandler.statusText;
						}
						// jQuery 2.0 renamed onreadystatechange to onload
						onReady = this.onreadystatechange || this.onload;

						// jQuery < 1.4 doesn't have onreadystate change for xhr
						if ( $.isFunction( onReady ) ) {
							if( mockHandler.isTimeout) {
								this.status = -1;
							}
							onReady.call( this, mockHandler.isTimeout ? 'timeout' : undefined );
						} else if ( mockHandler.isTimeout ) {
							// Fix for 1.3.2 timeout to keep success from firing.
							this.status = -1;
						}
					}).apply(that);
				};
			})(this);

			if ( mockHandler.proxy ) {
				// We're proxying this request and loading in an external file instead
				_ajax({
					global: false,
					url: mockHandler.proxy,
					type: mockHandler.proxyType,
					data: mockHandler.data,
					dataType: requestSettings.dataType === "script" ? "text/plain" : requestSettings.dataType,
					complete: function(xhr) {
						mockHandler.responseXML = xhr.responseXML;
						mockHandler.responseText = xhr.responseText;
						// Don't override the handler status/statusText if it's specified by the config
						if (isDefaultSetting(mockHandler, 'status')) {
							mockHandler.status = xhr.status;
						}
						if (isDefaultSetting(mockHandler, 'statusText')) {
							mockHandler.statusText = xhr.statusText;
						}

						this.responseTimer = setTimeout(process, mockHandler.responseTime || 0);
					}
				});
			} else {
				// type == 'POST' || 'GET' || 'DELETE'
				if ( requestSettings.async === false ) {
					// TODO: Blocking delay
					process();
				} else {
					this.responseTimer = setTimeout(process, mockHandler.responseTime || 50);
				}
			}
		}

		// Construct a mocked XHR Object
		function xhr(mockHandler, requestSettings, origSettings, origHandler) {
			// Extend with our default mockjax settings
			mockHandler = $.extend(true, {}, $.mockjaxSettings, mockHandler);

			if (typeof mockHandler.headers === 'undefined') {
				mockHandler.headers = {};
			}
			if ( mockHandler.contentType ) {
				mockHandler.headers['content-type'] = mockHandler.contentType;
			}

			return {
				status: mockHandler.status,
				statusText: mockHandler.statusText,
				readyState: 1,
				open: function() { },
				send: function() {
					origHandler.fired = true;
					_xhrSend.call(this, mockHandler, requestSettings, origSettings);
				},
				abort: function() {
					clearTimeout(this.responseTimer);
				},
				setRequestHeader: function(header, value) {
					if (header === 'Content-Type' && value === 'application/x-www-form-urlencoded; charset=UTF-8') {
						return;
					}
					mockHandler.headers[header] = value;
				},
				getResponseHeader: function(header) {
					// 'Last-modified', 'Etag', 'content-type' are all checked by jQuery
					if ( mockHandler.headers && mockHandler.headers[header] ) {
						// Return arbitrary headers
						return mockHandler.headers[header];
					} else if ( header.toLowerCase() == 'last-modified' ) {
						return mockHandler.lastModified || (new Date()).toString();
					} else if ( header.toLowerCase() == 'etag' ) {
						return mockHandler.etag || '';
					} else if ( header.toLowerCase() == 'content-type' ) {
						return mockHandler.contentType || 'text/plain';
					}
				},
				getAllResponseHeaders: function() {
					var headers = '';
					$.each(mockHandler.headers, function(k, v) {
						headers += k + ': ' + v + "\n";
					});
					return headers;
				}
			};
		}

		// Process a JSONP mock request.
		function processJsonpMock( requestSettings, mockHandler, origSettings ) {
			// Handle JSONP Parameter Callbacks, we need to replicate some of the jQuery core here
			// because there isn't an easy hook for the cross domain script tag of jsonp

			processJsonpUrl( requestSettings );

			requestSettings.dataType = "json";
			if(requestSettings.data && CALLBACK_REGEX.test(requestSettings.data) || CALLBACK_REGEX.test(requestSettings.url)) {
				createJsonpCallback(requestSettings, mockHandler, origSettings);

				// We need to make sure
				// that a JSONP style response is executed properly

				var rurl = /^(\w+:)?\/\/([^\/?#]+)/,
					parts = rurl.exec( requestSettings.url ),
					remote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host);

				requestSettings.dataType = "script";
				if(requestSettings.type.toUpperCase() === "GET" && remote ) {
					var newMockReturn = processJsonpRequest( requestSettings, mockHandler, origSettings );

					// Check if we are supposed to return a Deferred back to the mock call, or just
					// signal success
					if(newMockReturn) {
						return newMockReturn;
					} else {
						return true;
					}
				}
			}
			return null;
		}

		// Append the required callback parameter to the end of the request URL, for a JSONP request
		function processJsonpUrl( requestSettings ) {
			if ( requestSettings.type.toUpperCase() === "GET" ) {
				if ( !CALLBACK_REGEX.test( requestSettings.url ) ) {
					requestSettings.url += (/\?/.test( requestSettings.url ) ? "&" : "?") +
						(requestSettings.jsonp || "callback") + "=?";
				}
			} else if ( !requestSettings.data || !CALLBACK_REGEX.test(requestSettings.data) ) {
				requestSettings.data = (requestSettings.data ? requestSettings.data + "&" : "") + (requestSettings.jsonp || "callback") + "=?";
			}
		}

		// Process a JSONP request by evaluating the mocked response text
		function processJsonpRequest( requestSettings, mockHandler, origSettings ) {
			// Synthesize the mock request for adding a script tag
			var callbackContext = origSettings && origSettings.context || requestSettings,
				newMock = null;


			// If the response handler on the moock is a function, call it
			if ( mockHandler.response && $.isFunction(mockHandler.response) ) {
				mockHandler.response(origSettings);
			} else {

				// Evaluate the responseText javascript in a global context
				if( typeof mockHandler.responseText === 'object' ) {
					$.globalEval( '(' + JSON.stringify( mockHandler.responseText ) + ')');
				} else {
					$.globalEval( '(' + mockHandler.responseText + ')');
				}
			}

			// Successful response
			jsonpSuccess( requestSettings, callbackContext, mockHandler );
			jsonpComplete( requestSettings, callbackContext, mockHandler );

			// If we are running under jQuery 1.5+, return a deferred object
			if($.Deferred){
				newMock = new $.Deferred();
				if(typeof mockHandler.responseText == "object"){
					newMock.resolveWith( callbackContext, [mockHandler.responseText] );
				}
				else{
					newMock.resolveWith( callbackContext, [$.parseJSON( mockHandler.responseText )] );
				}
			}
			return newMock;
		}


		// Create the required JSONP callback function for the request
		function createJsonpCallback( requestSettings, mockHandler, origSettings ) {
			var callbackContext = origSettings && origSettings.context || requestSettings;
			var jsonp = requestSettings.jsonpCallback || ("jsonp" + jsc++);

			// Replace the =? sequence both in the query string and the data
			if ( requestSettings.data ) {
				requestSettings.data = (requestSettings.data + "").replace(CALLBACK_REGEX, "=" + jsonp + "$1");
			}

			requestSettings.url = requestSettings.url.replace(CALLBACK_REGEX, "=" + jsonp + "$1");


			// Handle JSONP-style loading
			window[ jsonp ] = window[ jsonp ] || function( tmp ) {
					data = tmp;
					jsonpSuccess( requestSettings, callbackContext, mockHandler );
					jsonpComplete( requestSettings, callbackContext, mockHandler );
					// Garbage collect
					window[ jsonp ] = undefined;

					try {
						delete window[ jsonp ];
					} catch(e) {}

					if ( head ) {
						head.removeChild( script );
					}
				};
		}

		// The JSONP request was successful
		function jsonpSuccess(requestSettings, callbackContext, mockHandler) {
			// If a local callback was specified, fire it and pass it the data
			if ( requestSettings.success ) {
				requestSettings.success.call( callbackContext, mockHandler.responseText || "", status, {} );
			}

			// Fire the global callback
			if ( requestSettings.global ) {
				trigger(requestSettings, "ajaxSuccess", [{}, requestSettings] );
			}
		}

		// The JSONP request was completed
		function jsonpComplete(requestSettings, callbackContext) {
			// Process result
			if ( requestSettings.complete ) {
				requestSettings.complete.call( callbackContext, {} , status );
			}

			// The request was completed
			if ( requestSettings.global ) {
				trigger( "ajaxComplete", [{}, requestSettings] );
			}

			// Handle the global AJAX counter
			if ( requestSettings.global && ! --$.active ) {
				$.event.trigger( "ajaxStop" );
			}
		}


		// The core $.ajax replacement.
		function handleAjax( url, origSettings ) {
			var mockRequest, requestSettings, mockHandler;

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				origSettings = url;
				url = undefined;
			} else {
				// work around to support 1.5 signature
				origSettings.url = url;
			}

			// Extend the original settings for the request
			requestSettings = $.extend(true, {}, $.ajaxSettings, origSettings);

			// Iterate over our mock handlers (in registration order) until we find
			// one that is willing to intercept the request
			for(var k = 0; k < mockHandlers.length; k++) {
				if ( !mockHandlers[k] ) {
					continue;
				}

				mockHandler = getMockForRequest( mockHandlers[k], requestSettings );
				if(!mockHandler) {
					// No valid mock found for this request
					continue;
				}

				mockedAjaxCalls.push(requestSettings);

				// If logging is enabled, log the mock to the console
				$.mockjaxSettings.log( mockHandler, requestSettings );


				if ( requestSettings.dataType === "jsonp" ) {
					if ((mockRequest = processJsonpMock( requestSettings, mockHandler, origSettings ))) {
						// This mock will handle the JSONP request
						return mockRequest;
					}
				}


				// Removed to fix #54 - keep the mocking data object intact
				//mockHandler.data = requestSettings.data;

				mockHandler.cache = requestSettings.cache;
				mockHandler.timeout = requestSettings.timeout;
				mockHandler.global = requestSettings.global;

				copyUrlParameters(mockHandler, origSettings);

				(function(mockHandler, requestSettings, origSettings, origHandler) {
					mockRequest = _ajax.call($, $.extend(true, {}, origSettings, {
						// Mock the XHR object
						xhr: function() { return xhr( mockHandler, requestSettings, origSettings, origHandler ); }
					}));
				})(mockHandler, requestSettings, origSettings, mockHandlers[k]);

				return mockRequest;
			}

			// We don't have a mock request
			if($.mockjaxSettings.throwUnmocked === true) {
				throw('AJAX not mocked: ' + origSettings.url);
			}
			else { // trigger a normal request
				return _ajax.apply($, [origSettings]);
			}
		}

		/**
		 * Copies URL parameter values if they were captured by a regular expression
		 * @param {Object} mockHandler
		 * @param {Object} origSettings
		 */
		function copyUrlParameters(mockHandler, origSettings) {
			//parameters aren't captured if the URL isn't a RegExp
			if (!(mockHandler.url instanceof RegExp)) {
				return;
			}
			//if no URL params were defined on the handler, don't attempt a capture
			if (!mockHandler.hasOwnProperty('urlParams')) {
				return;
			}
			var captures = mockHandler.url.exec(origSettings.url);
			//the whole RegExp match is always the first value in the capture results
			if (captures.length === 1) {
				return;
			}
			captures.shift();
			//use handler params as keys and capture resuts as values
			var i = 0,
				capturesLength = captures.length,
				paramsLength = mockHandler.urlParams.length,
			//in case the number of params specified is less than actual captures
				maxIterations = Math.min(capturesLength, paramsLength),
				paramValues = {};
			for (i; i < maxIterations; i++) {
				var key = mockHandler.urlParams[i];
				paramValues[key] = captures[i];
			}
			origSettings.urlParams = paramValues;
		}


		// Public

		$.extend({
			ajax: handleAjax
		});

		$.mockjaxSettings = {
			//url:        null,
			//type:       'GET',
			log:          function( mockHandler, requestSettings ) {
				if ( mockHandler.logging === false ||
					( typeof mockHandler.logging === 'undefined' && $.mockjaxSettings.logging === false ) ) {
					return;
				}
				if ( window.console && console.log ) {
					var message = 'MOCK ' + requestSettings.type.toUpperCase() + ': ' + requestSettings.url;
					var request = $.extend({}, requestSettings);

					if (typeof console.log === 'function') {
						console.log(message, request);
					} else {
						try {
							console.log( message + ' ' + JSON.stringify(request) );
						} catch (e) {
							console.log(message);
						}
					}
				}
			},
			logging:       true,
			status:        200,
			statusText:    "OK",
			responseTime:  500,
			isTimeout:     false,
			throwUnmocked: false,
			contentType:   'text/plain',
			response:      '',
			responseText:  '',
			responseXML:   '',
			proxy:         '',
			proxyType:     'GET',

			lastModified:  null,
			etag:          '',
			headers: {
				etag: 'IJF@H#@923uf8023hFO@I#H#',
				'content-type' : 'text/plain'
			}
		};

		$.mockjax = function(settings) {
			var i = mockHandlers.length;
			settings.mockId = i;
			mockHandlers[i] = settings;
			return i;
		};
		$.mockjaxClear = function(i) {
			if ( arguments.length == 1 ) {
				mockHandlers[i] = null;
			} else {
				mockHandlers = [];
			}
			mockedAjaxCalls = [];
		};
		$.mockjax.handler = function(i) {
			if ( arguments.length == 1 ) {
				return mockHandlers[i];
			}
		};
		$.mockjax.mockedAjaxCalls = function() {
			return mockedAjaxCalls;
		};

		$.mockjax.once = function (settings){
			settings.once = true;
			return $.mockjax(settings);
		};
	})(jQuery);

});

define('request', [
	'uuid',
	'logger',
	'performance',
	'config',
	'Promise',
	'Emitter',
	'utils/util',
	'jquery',
	'jquery.mockjax'
], function (
	/** function */uuid,
	/** logger */logger,
	/** performance */performance,
	/** config */config,
	/** Promise */Promise,
	/** Emitter */Emitter,
	/** util */util,
	/** function */$
) {
	"use strict";


	/**
	 * «Пачка»
	 * @type {Array|null}
	 * @private
	 */
	var _batch = null;


	/**
	 * Название события «потеря WiFi авторизации»
	 * @const
	 */
	var LOSS_WIFI_AUTH = 'losswifiauth';


	/**
	 * Кеш активных GET-запросов
	 * @type {Object}
	 * @private
	 */
	var _activeCache = {};


	var _stringify = JSON.stringify;


	/**
	 * Получить данные для логирования
	 * @param   {Object}  req
	 * @param   {string}  [uuid]
	 * @returns {Object}
	 * @private
	 */
	var _getLog = function (req, uuid) {
		return {
			//id: uuid || req.uuid,
			url: req.url,
			data: util.cloneJSON(req.data),
			type: req.type,
			headers: req.options && req.options.headers || req.headers,
			startTime: req.startTime,
			duration: req.duration,
			status: req.httpStatus || req.status,
			statusText: req.statusText,
			readyState: req.readyState,
			responseText: req.status != 200 ? req.responseText : void 0
		};
	};



	/**
	 * Low-level интерфейс для работы с ajax/json/и т.п. запросами
	 * @class   request
	 * @mixes	Emitter
	 * @param   {string}         url        куда отправить запрос
	 * @param   {string|Object}  [data]     данные запроса
	 * @param   {Object}         [options]  дополнительные опции
	 * @returns {request.Request}
	 */
	function request(url, data, options) {
		options = util.extend(
			{
				type: 'POST',
				logger: 'request',
				loggerMeta: options && options.loggerMeta || logger.meta(-1),
				headers: {},
				retries: request.setup('retries'),
				Request: Request
			},
			options,
			{
				url: url,
				data: data
			}
		);


		var req,
			cacheKey,
			OptRequest = options.Request;


		if (options.type.toUpperCase() == 'GET') {
			cacheKey = url + '|' + _stringify(data) + '|' + _stringify(options && options.headers);
			req = _activeCache[cacheKey];

			/**
			 * Запрет кеширования GET запросов
			 */
			if (typeof options.cache == 'undefined') {
				options.cache = false;
			}

			if (!req) {
				req = new OptRequest(options);
				_activeCache[cacheKey] = req;

				req.always(function () {
					logger.add('_activeCache.remove', cacheKey);
					delete _activeCache[cacheKey];
				});
			}
		}
		else {
			req = new OptRequest(options);
		}

		return req;
	}


	/**
	 * Отправить запрос
	 * @name request.call
	 * @alias request
	 * @static
	 * @method
	 * @memberof request
	 */
	request.call;


	/**
	 * Отправить GET-запрос
	 * @alias request
	 * @static
	 * @method
	 * @memberof request
	 */
	request.get;



	/**
	 * Отправить POST-запрос
	 * @alias request
	 * @static
	 * @method
	 * @memberof request
	 */
	request.post;


	// Short-методы "get" и "post"
	['call', 'get', 'post'].forEach(function (name) {
		request[name] = function (url, data, options) {
			var meta = logger.meta(-1);

			meta.fn = 'request.' + name;

			options = util.cloneObject(options);
			options.type = options.type || (name == 'call' ? 'post' : name);
			options.loggerMeta = options.loggerMeta || meta;

			return request(url, data, options);
		};
	});


	/**
	 * Глобальные настройки для запросов, [$.ajaxSetup](http://api.jquery.com/jQuery.ajaxSetup/)
	 * @name     request.setup
	 * @static
	 * @method
	 * @param   {Object|string} opts     нзвание, либо объект опций (см. [jQuery.ajax](http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings))
	 * @param   {*}             [value]  значение
	 * @returns {*}
	 */
	request.setup = function (opts, value) {
		var settings = $.ajaxSettings;

		if (typeof opts === 'string') {
			if (value !== void 0) {
				settings[opts] = value;
			} else {
				return settings[opts];
			}
		}
		else if (opts === void 0) {
			return settings;
		}
		else {
			$.ajaxSetup(opts);
		}
	};


	// «Наши» настройки
	request.setup({
		retries: 1, // максимум попыток `xhr.retry()`
		batchUrl: '/batch', // url по умолчанию для отравки «пачки»

		locationReload: function () {
			(window.mockWindow || /* istanbul ignore next */ window).location.reload();
		},

		lossWiFiAuthDetect: function (xhr, err) {
			var responseText = xhr.responseText;
			return (err == 'parsererror') && /<meta[^>]+refresh/i.test(responseText);
		}
	});



	/**
	 * Объект запроса
	 * @class request.Request
	 * @constructs request.Request
	 * @mixes   Promise
	 * @param   {Object}   options
	 */
	function Request(options) {
		var _this = this,
			_promise,
			logId = (options.headers['X-Request-Id'] = uuid());


		/**
		 * Уникальный идентификатор запроса
		 * @member {string} request.Request#uuid
		 */
		_this.uuid = logId;


		if (options.batch !== false && _batch) {
			_this.batched = true;

			_promise = new Promise(function (resolve, reject) {
				_batch.push({
					req: _this,
					opts: options,
					resolve: resolve,
					reject: reject
				});
			});

			_promise = _promise.then(
				function (body) { return _this.end(false, body); },
				function (err) { return _this.end(err); }
			);
		}
		else {
			_promise = _this.send(options);
		}


		_this.__logger__ = _promise.__logger__;


		/**
		 * «Обещание»
		 * @member {Promise} request.Request#url
		 * @private
		 */
		_this._promise = _promise;
		_promise.metaOffset = 1; // смещение на один вверх по стеку

		/**
		 * Куда делаем запрос
		 * @member {string} request.Request#url
		 */
		_this.url = options.url;

		/**
		 * Тип запроса GET, POST и т.п.
		 * @member {string} request.Request#type
		 */
		_this.type = options.type;

		/**
		 * Параметры запроса
		 * @member {Object} request.Request#data
		 */
		_this.data = options.data;

		/**
		 * Дополнительные опции запроса
		 * @member {Object} request.Request#options
		 */
		_this.options = options;

		/**
		 * Время начала запроса
		 * @member {number} request.Request#startTime
		 */
		_this.startTime = performance.now();

		request.trigger('start', _this);
	}


	Request.fn = Request.prototype = /** @lends request.Request# */ {
		__resultLogEntry__: {},

		/**
		 * Запрос в «пачке»
		 * @type {boolean}
		 */
		batched: false,


		/**
		 * Успешное выполнение запроса
		 * @param  {Function} fn
		 * @return {Request}
		 */
		done: function done(fn) {
			this._promise.__noLog = this.__noLog; // todo: Нужно избавлятся от этого флага
			this._promise.done(fn);

			return this;
		},


		/**
		 * Неудачное выполнение запроса
		 * @param  {Function} fn
		 * @return {Request}
		 */
		fail: function fail(fn) {
			this._promise.__noLog = this.__noLog;
			this._promise.fail(fn);

			return this;
		},


		/**
		 * Любой исход выполнения запроса
		 * @param  {Function} fn
		 * @return {Request}
		 */
		always: function always(fn) {
			this._promise.__noLog = this.__noLog;
			this._promise.always(fn);

			return this;
		},


		/**
		 * Подписаться на выполение запроса
		 * @param  {Function} doneFn
		 * @param  {Function} [failFn]
		 * @return {Promise}
		 */
		then: function then(doneFn, failFn) {
			return this._promise.then(doneFn, failFn);
		},


		/**
		 * Перехвотить ошибки при выполнении
		 * @param  {Function} fn
		 * @return {Promise}
		 */
		'catch': function (fn) {
			return this._promise['catch'](fn);
		},


		/**
		 * Отправить запрос
		 * @param  {Object}  options
		 * @return {Promise}
		 */
		send: function send(options) {
			var _this = this,
				xhr,
				promise;

			/**
			 * Время завершения
			 * @member {number} request.Request#endTime
			 */
			_this.endTime = null;

			/**
			 * Продолжительность запроса
			 * @member {number} request.Request#duration
			 */
			_this.duration = null;

			/**
			 * Запрос в ожидании ответа
			 * @member {boolean} request.Request#pending
			 */
			_this.pending = true;

			/**
			 * Запрос отменен
			 * @member {boolean} request.Request#aborted
			 */
			_this.aborted = false;

			/**
			 * Количество повторных попыток
			 * @member {number} request.Request#retries
			 */
			_this.retries = options.retries;

			/**
			 * Raw-тело ответа (text)
			 * @member {*} request.Request#responseText
			 */
			_this.responseText = null;

			/**
			 * Тело ответа
			 * @member {*} request.Request#body
			 */
			_this.body = null;

			/**
			 * Статус ответа сервера
			 * @type {number}
			 */
			_this.status = null;

			/**
			 * Ошибка
			 * @member {*} request.Request#error
			 */
			_this.error = null;

			/**
			 * Объект запроса
			 * @member {XMLHttpRequest} request.Request#xhr
			 */
			_this.xhr = xhr = $.ajax(options);

			promise = new Promise(function (resolve, reject) {
				xhr
					.done(resolve)
					.fail(function (x, err) { reject(err); })
				;
			});


			logger.wrap('[[' + options.logger + ']]', _getLog(options), promise);

			this.__resultLogEntry__ = logger.addEntry('log', options.logger + ':pending', null, promise.__logger__.id);
			this.__resultLogEntry__.meta = promise.__logger__.meta = options.loggerMeta;

			promise.__noLog = true;

			return promise.then(
				function (body) { return _this.end(false, body); },
				function (err) { return _this.end(err); }
			);
		},


		/**
		 * Получить заголовок ответа по его имени
		 * @param   {string}  name
		 * @returns {string}
		 */
		getResponseHeader: function (name) {
			return this.xhr.getResponseHeader(name);
		},


		/**
		 * Получить все заголовки от сервера
		 * @returns {string}
		 */
		getAllResponseHeaders: function () {
			return this.xhr.getAllResponseHeaders();
		},


		/**
		 * Отменить запрос
		 */
		abort: function () {
			this.aborted = true;
			this.xhr && this.xhr.abort();
			this.end(false);
		},


		/**
		 * Завершить запрос
		 */
		end: function (err, body) {
			var options = this.options;

			/* jshint eqnull:true */
			this.status = this.status == null ? this.xhr.status : this.status;
			this.statusText = this.statusText || this.xhr.statusText;
			this.readyState = this.xhr.readyState;
			this.responseText = this.xhr.responseText;

			this.endTime = performance.now();
			this.duration = this.endTime - this.startTime;
			this.pending = false;

			this.__resultLogEntry__.args = _getLog(this);

			// Проверяем на потерю WiFi
			if (request.setup('lossWiFiAuthDetect')(this, err)) {
				err = LOSS_WIFI_AUTH;
			}

			if (options.postProcessing) {
				// Пост-обработка
				options.postProcessing(this, body);
			}

			if (err === false) { // Это успех, бро!
				this.body = body;
				this.__resultLogEntry__.label = '[[' + options.logger + ':done]]';
			}
			else { // Всё плохо, но не стоит отчаиваться, возможно кто-то перехватит ошибку
				this.error = err;
				this.__resultLogEntry__.label = '[[' + options.logger + ':fail]]';

				// Emit error
				var evt = new Emitter.Event(err === LOSS_WIFI_AUTH ? err : 'error');

				request.trigger(evt, this);

				// Вернули «обещание», начинаем «веселье»
				if (evt.result && evt.result.then) {
					request.trigger('end', this);

					return evt.result; // вернем это «обещание»
				}
				else if (err === LOSS_WIFI_AUTH && !evt.isDefaultPrevented()) {
					request.setup('locationReload')(this); // перезагружаем страницу
				}
			}

			request.trigger('end', this);

			return Promise[this.isOK() ? 'resolve' : 'reject'](Object.create(this, {then: {value: null} }));
		},


		/**
		 * Сервер ответил 200, 201 или 202 и не было ошибок при парсинге ответа
		 * @returns {boolean}
		 */
		isOK: function () {
			return (this.status >= 200 && this.status <= 202) && !this.error;
		},


		/**
		 * Повторить запрос
		 * @param   {Promise|Function}  [promise]
		 * @param   {boolean}           [self]
		 * @returns {request.Request}
		 */
		retry: function (promise, self) {
			var _this = this,
				options = self ? _this.options : util.cloneObject(_this.options);

			if (options.retries > 0) {
				options.retries--;
				options.logger = 'retry:' + options.logger;

				promise = promise || Promise.resolve();

				if (!promise.then) {
					promise = new Promise(promise);
				}

				return promise.then(
					function () { // success
						if (self) {
							return _this.send(options);
						}
						else {
							return request(_this.url, _this.data, options);
						}
					},

					function () { // fail
						return Promise.reject(_this);
					}
				);
			}

			return Promise.reject(_this);
		},


		/**
		 * Проверить свойство на истинность
		 * @name request.Request#is
		 * @method
		 * @param   {string}  keys
		 * @returns {boolean}
		 */
		is: config.is,


		/**
		 * Проверить свойство на наличие
		 * @name request.Request#has
		 * @method
		 * @param   {string}  keys
		 * @returns {boolean}
		 */
		has: config.has,


		/**
		 * Получить свойство
		 * @name request.Request#get
		 * @method
		 * @param   {string}  key
		 * @returns {boolean}
		 */
		get: config.get,


		/**
		 * Маппинг данных ответа (боже, ну и описание)
		 * @param  {Object|Function} mappers
		 * @return {Object}
		 */
		map: function (mappers) {
			if (mappers instanceof Function) {
				return (mappers.map || mappers).call(mappers, this.get('body'));
			} else {
				var result = {};

				$.each(mappers, function (name, mapper) {
					result[name] = (mapper.map || mapper).call(mapper, this.get('body.' + name));
				}.bind(this));

				return result;
			}
		},


		/**
		 * Сравнить на равество
		 * @param  {request.Request} req
		 * @return {boolean}
		 */
		equals: function (req) {
			return req && (this._promise === req._promise); // возможно есть лучшая проверка, но я не знаю
		}
	};


	/**
	 * Группировать запросы в «пачку»  ***Экспериментальный метод***
	 * @param	{Function} executor
	 * @param	{string}   [url]
	 * @returns {Promise}
	 */
	request.batch = function (executor, url) {
		var batch = _batch || [], // создаем «пачку», либо используем текущию
			results;

		if (_batch === null) {
			_batch = batch;
			batch.promise = new Promise(util.nextTick(function (resolve, reject) {
				if (batch.length > 0) {
					var req = request.post(url || request.setup('batchUrl'), {
						batch: _stringify(batch.map(function (entry) {
							var opts = entry.opts;

							return {
								url: opts.url,
								type: opts.type,
								data: opts.data,
								headers: opts.headers
							};
						}))
					}, { batch: false }) // это запрос идет в не пачки
						.done(function () {
							req.body.forEach(function (body, i) {
								batch[i].req.xhr = req.xhr;
								batch[i].resolve(body);
							});

							resolve();
						})
						.fail(function () {
							batch.forEach(function (entry) {
								entry.req.xhr = req.xhr;
								entry.reject(req);
							});

							reject(req);
						})
					;
				} else {
					resolve();
				}

				_batch = null;
			}, true));
		}

		results = executor();

		return batch.promise.then(function () { return results; });
	};


	// Подмешиваем Emitter
	Emitter.apply(request);


	/**
	 * Создание моков, основано на [jQuery.mockjax](https://github.com/appendto/jquery-mockjax)
	 * @name     request.mock
	 * @static
	 * @method
	 * @param    {Object} options
	 * @returns  {number}
	 */
	request.mock = $.mockjax;

	request.mock.once = $.mockjax.once;
	request.mock.clear = $.mockjaxClear;


	// Быстрый доступ к Promise
	request.all = Promise.all;
	request.Promise = Promise;


	// «Запрос», чтобы можно было расширять
	request.Request = Request;


	// Export
	request.version = '0.4.0';
	return request;
});

define('RPC', [
	'logger',
	'request',
	'Emitter',
	'Promise',
	'utils/util'
], function (
	/** logger */logger,
	/** request */request,
	/** Emitter */Emitter,
	/** Promise */Promise,
	/** util */util
) {
	"use strict";


	var R_URL_VERSION = /^\/?v\d+/,
		R_URL_LAST_SLASH = /\/$/,
		R_URL_FIRST_SLASH = /^\//,
		R_URL_2xSLASH = /\/{2,}/g,
		R_URL_NO_FIRST_2xSLASH = /([^$\/])\/+/g,

		_stringify = JSON.stringify,
		_cloneObject = util.cloneObject
	;


	/**
	 * Объект для работы с API.
	 * Для подключения дополнительный возможностей, таких как обработка SDC и т.п. нужно [их подключить](statuses/) ;]
	 * @class  RPC
	 * @mixes  Emitter
	 */
	var RPC = {
			all: Promise.all,
			request: request,
			Promise: Promise,
			errorHandler: []
		},

		_settings = {
			version: 1,
			sdcUrl: '//auth.mail.ru/sdc',
			baseUrl: '//api.mail.ru/',
			timeout: 10000,
			email: '',
			token: '',
			htmlencoded: false,
			tokenRetries: 2,
			emulateHTTP: true,
			session: ''
		},

		_hasOwn = Object.prototype.hasOwnProperty;


	/**
	 * Трансляция кодов ответа в имена статусов API.
	 * @type {Object}
	 * @memberof RPC
	 */
	RPC.codes = {
		200: 'ok',
		203: 'non_authoritative',
		301: 'move',
		304: 'notmodified',
		400: 'invalid',
		402: 'payment_required',
		403: 'denied',
		404: 'notfound',
		406: 'unacceptable',
		408: 'timeout',
		409: 'conflict',
		417: 'expectation_failed',
		422: 'unprocessable',
		423: 'locked',
		424: 'failed_dependency',
		426: 'upgrade_required',
		429: 'many_requests',
		449: 'retry_with',
		451: 'unavailable_for_legal_reasons',
		500: 'fail',
		501: 'not_implemented',
		503: 'unavaliable',
		507: 'insufficient'
	};


	/**
	 * Трансляция статусов в коды ответа API.
	 * @type {Object}
	 * @memberof RPC
	 */
	RPC.statuses = {};
	for (var code in RPC.codes) {
		RPC.statuses[RPC.codes[code]] = code;
	}


	// Делаем из названия метода http/https url
	function _normalizeUrl(path) {
		var baseUrl = _settings.baseUrl;
		path = String(path || "");

		/* istanbul ignore else */
		if (R_URL_FIRST_SLASH.test(path)) {
			path = path.replace(R_URL_NO_FIRST_2xSLASH, '$1/');
		} else if (path.indexOf(baseUrl) === -1) {
			if (!R_URL_VERSION.test(path)) {
				path = '/v' + _settings.version + '/' + path;
			}

			// Вырезаем все повторяющиеся слеши, кроме первых двух
			path = baseUrl.replace(R_URL_LAST_SLASH, "") + ("/" + path).replace(R_URL_2xSLASH, "/");
		}

		return path;
	}


	// Делаем из входных данных для RPC.mock объект для $.mockjax
	function _makeMockSettings(path, settings) {
		if (typeof path === 'object') {
			settings = path;
			path = settings.url;
		}

		settings = settings || /* istanbul ignore next */ {};
		var data = settings.data || {};

		return {
			url: _normalizeUrl(path),
			once: settings.once,
			contentType: 'application/json',
			type: settings.type,
			headers: settings.headers || {},
			responseTime: settings.responseTime || 15,
			data: data,
			responseText: _stringify(settings.responseText || {
				body: settings.body || '',
				status: settings.status || /* istanbul ignore next */ 200,
				email: settings.email || '',
				htmlencoded: settings.htmlencoded || '',
				last_modified: settings.last_modified || ''
			}),
			response: settings.response
		};
	}


	// Создаем объект запроса, указанного типа (POST/GET)
	function _call(path, data, options, type) {
		options = _cloneObject(options);
		options.type = type;
		options.loggerMeta = options.loggerMeta || logger.meta(-2);

		return RPC.call(path, data, options);
	}


	/**
	 * Метод для установки/получения настроек.
	 * @static
	 * @method
	 * @memberof RPC
	 * @param  {Object|string}  [options]  Может быть как объектом настроек, так и строковым ключом
	 * @param  {*}  [value]  Используется только для установки значения
	 * @returns {*}
	 */
	RPC.setup = function (options, value) {
		if (options === undefined) { // get all settings
			return _settings;
		} else {
			if (value !== undefined) { // set setting
				_settings[options] = value;
			} else if (typeof options === 'string') { // get setting, options - is a key
				return _settings[options];
			} else {
				for (var key in options) { // set bundle of settings
					/* istanbul ignore next */
					if (_hasOwn.call(options, key)) {
						_settings[key] = options[key];
					}
				}
			}
		}
	};


	/**
	 * Метод для получения URL конца API
	 * @static
	 * @method
	 * @memberof RPC
	 * @param  {string} [path] относительный URL метода или абсолютный если начинается с "/" или "//"
	 * @return {string}
	 */
	RPC.url = function (path) {
		return _normalizeUrl(path);
	};

	/**
	 * Метод проверяет активна ли для пользователя безопасная сессия (см. [Авторизация](http://api.tornado.dev.mail.ru/auth))
	 * @static
	 * @method
	 * @memberof RPC
	 * @returns {boolean}
	 */
	RPC.hasSession = function () {
		return !!_settings.session;
	};

	/**
	 * Метод для проверки наличия токена
	 * @static
	 * @method
	 * @memberof RPC
	 * @return {boolean}
	 */
	RPC.hasToken = function () {
		return !!_settings.token;
	};


	/**
	 * Метод, сбрасывыющий токен
	 * @static
	 * @method
	 * @memberof RPC
	 */
	RPC.resetToken = function () {
		_settings.token = '';
	};


	/**
	 * Получение токена. В случае успешного выполнения устанавливает полученный токен.
	 * @static
	 * @memberof RPC
	 * @return {Promise}
	 */
	RPC.token = function () {
		return RPC.call('tokens').then(function (/* RPC.Request */req) {
			/* jshint expr:true */
			return (_settings.token = req.get('body.token'));
		});
	};


	/**
	 * Универсальный метод для отправки запроса к API.
	 * В случае ответа xhr.is('denied:token') запрашивает токен.
	 * @static
	 * @method
	 * @memberof RPC
	 * @param  {string}        path метод API
	 * @param  {Object}        [data] данные запроса
	 * @param  {Object}        [options] настройки для request
	 * @return {RPC.Request}
	 */
	RPC.call = function call(path, data, options) {
		options = _cloneObject(options);
		options.timeout = options.timeout || _settings.timeout;
		options.Request = RPCRequest;
		options.dataType = 'json';
		options.type = options.type ? options.type.toUpperCase() : 'POST';
		options.loggerMeta = options.loggerMeta || logger.meta(-1);

		data  = _cloneObject(data || {});

		/* istanbul ignore else */
		if (!data.email && _settings.email) {
			data.email = _settings.email;
		}

		/* jshint eqnull:true */
		/* istanbul ignore else */
		if (_settings.htmlencoded != null) {
			data.htmlencoded = _settings.htmlencoded;
		}

		/* istanbul ignore else */
		if (_settings.token) {
			data.token = _settings.token;
		}

		/* istanbul ignore else */
		if (_settings.emulateHTTP === true && options.type != 'GET' && options.type != 'POST') {
			options.type = 'POST';
		}

		/* istanbul ignore else */
		if (_settings.session) {
			data.session = _settings.session;
		}

		options.logger = options.logger || path;

		return request(_normalizeUrl(path), RPC.serialize(data), options);
	};


	/**
	 * Метод сериализации данных, перед отправкой
	 * может быть переопределен
	 * @static
	 * @method
	 * @memberof RPC
	 * @param {*} data - даные
	 * @returns {*}
	 */
	RPC.serialize = function (data) {
		return data;
	};

	/**
	 * Метода для совершения GET зароса
	 * @static
	 * @method
	 * @memberof RPC
	 * @param    {string}        path       метод API
	 * @param    {Object}        [data]     данные запроса
	 * @param    {Object}        [options]  опции
	 * @returns  {RPC.Request}
	 */
	RPC.get = function get(path, data, options) {
		return _call(path, data, options, 'GET');
	};


	/**
	 * Метода для совершения POST зароса
	 * @static
	 * @method
	 * @memberof RPC
	 * @param    {string}        path       метод API
	 * @param    {Object}        [data]     данные запроса
	 * @param    {Object}        [options]  опции
	 * @returns  {RPC.Request}
	 */
	RPC.post = function post(path, data, options) {
		return _call(path, data, options, 'POST');
	};


	/**
	 * Выполнить действия «пачкой»    ***Экспериментальный метод***
	 * @static
	 * @method
	 * @memberof RPC
	 * @param	{Function} executor
	 * @returns {Promise}
	 */
	RPC.batch = function (executor) {
		return request.batch(executor, this.url('batch'));
	};


	/**
	 * Эмуляция XHR
	 * @static
	 * @method
	 * @memberof RPC
	 * @param    {string}   path        Имя метода API
	 * @param    {Object}   [settings]  Результат запроса
	 * @return   {number}               id мока
	 */
	RPC.mock = function (path, settings) {
		return request.mock(_makeMockSettings(path, settings));
	};


	/**
	 * Разовая эмуляция XHR
	 * @static
	 * @method
	 * @memberof RPC.mock
	 * @param    {string}  path        Имя метода API
	 * @param    {Object}  [settings]  Результат запроса
	 * @returns  {number}              id мока
	 */
	RPC.mock.once = function (path, settings) {
		return request.mock.once(_makeMockSettings(path, settings));
	};


	/**
	 * Объект запроса RPC
	 * @class Request
	 * @memberOf RPC
	 * @constructs RPC.Request
	 * @extends request.Request
	 */
	var RPCRequest = function () {
		/**
		 * Время изменения, аналог If-Modified-Since HTTP заголовка.
		 * @type {number}
		 * @name lastModified
		 * @memberof RPC.Request#
		 */
		this.lastModified = null;

		/**
		 * Флаг, указывающий на включенное/отключенное htmlencode
		 * конвертирование значений полей в ответе API.
		 * @type {boolean}
		 * @name htmlencoded
		 * @memberof RPC.Request#
		 */
		this.htmlencoded = null;

		/**
		 * email учетки, над которой производится действие
		 * @type {string}
		 * @name email
		 * @memberof RPC.Request#
		 */
		this.email = null;

		/**
		 * Имя статуса ответа API.
		 * @type {string}
		 * @name statusName
		 * @memberof RPC.Request#
		 */
		this.statusName = null;

		return request.Request.apply(this, arguments);
	};

	RPCRequest.prototype = (function () {
		var F = function () {};
		F.prototype = request.Request.prototype;
		return new F;
	})();


	/**
	 * Завершить запрос
	 * @name RPC.Request#end
	 * @method
	 * @param  {string|boolean} err
	 * @param  {Object} api
	 * @return {*}
	 */
	RPCRequest.prototype.end = function (err, api) {
		// сохраняем реальный статус
		this.httpStatus = this.status;

		if (!this.proxyReq && !err) {
			// Всё ок, API ответило корретно, никаких http ошибок
			for (var key in api) {
				/* istanbul ignore else */
				if (_hasOwn.call(api, key)) {
					this[util.toCamelCase(key)] = api[key];
				}
			}

			// Преобразуем код в название статуса
			this.statusName = RPC.codes[api.status];

			// если пользователю была выставлена безопасная сессия, то сохранить ее
			if (api.session) {
				_settings.session = api.session;
			}

			// В родительский метод передаем именно ответ api.body
			api = api.body;
			err = err || !this.isOK(); // todo: проверить всё это
		}

		// вызываем родительский метод
		return request.Request.fn.end.call(this, err, api);
	};


	/**
	 * Проверить свойство на истинность
	 * @param  {string}  keys
	 * @return {boolean}
	 * @method RPC.Request#is
	 */
	RPCRequest.prototype.is = function (keys) {
		var R_STATUS = /\b(\w+)(?::(\w+))?\b/g, // Не кешируем RegExp, а то «криво» будет работа exec
			key,
			val,
			matches;

		while (!!(matches = R_STATUS.exec(keys))) {
			key = matches[1]; // статус
			val = matches[2]; // значение

			if (RPC.statuses[key] == this.status && (!val || this.body == val)) {
				return true;
			}
		}

		return request.Request.fn.is.call(this, keys);
	};



	// Доступ к RPCRequest
	RPC.Request = RPCRequest;


	// Подмешиваем Emitter
	Emitter.apply(RPC);


	// Обработка ошибок
	request.on('error', function (evt, req) {
		var i = RPC.errorHandler.length,
			handle,
			result;

		while (i--) {
			handle = RPC.errorHandler[i];

			if (req.is(handle.status)) {
				result = handle.process(req);

				/* istanbul ignore else */
				if (result) {
					evt.preventDefault();
					return req.retry(result, true);
				}
			}
		}
	});


	// Export
	RPC.version = '0.5.0';
	return RPC;
});

define('inherit', [], function () {
	/**
	 * Создание «родительского» метода
	 * @param   {*}  fn
	 * @param   {*} parent
	 * @returns {*}
	 * @private
	 */
	function _parentize(fn, parent) {
		if (typeof fn === 'function') {
			fn.parent = parent;
		}
		return	fn;
	}


	/**
	 * Примитивное наследование
	 * @param   {Function|Object}  Class
	 * @param   {Object}    [methods]
	 * @returns {Function}
	 * @private
	 */
	function inherit(Class, methods) {
		if (arguments.length === 1) {
			methods = Class;

			Class = methods.constructor;
			Class.fn = Class.prototype = methods;

			return inherit.apply(Class);
		}


		var key,
			ClassExt = _parentize(methods.hasOwnProperty('constructor') ? methods.constructor : function (a, b, c) {
				var retVal;

				switch (arguments.length) {
					case 1: retVal = Class.call(this, a); break;
					case 2: retVal = Class.call(this, a, b); break;
					case 3: retVal = Class.call(this, a, b, c); break;
					default: retVal = Class.apply(this, arguments); break;
				}

				if (retVal !== void 0) {
					return retVal;
				}
			}, Class)
		;


		// Наследуем статические методы и свойства
		for (key in Class) {
			if (Class.hasOwnProperty(key)) {
				ClassExt[key] = Class[key];
			}
		}


		// Наследуем
		ClassExt.prototype = (function () {
			var F = function () {};
			F.prototype = Class.fn;
			return new F;
		})();


		// Быстрый доступ к прототипу
		ClassExt.fn = ClassExt.prototype;


		// Методы класса
		for (key in methods) {
			ClassExt.fn[key] = _parentize(methods[key], ClassExt.fn[key]);
		}


		// Выправляем конструктор
		ClassExt.fn.constructor = ClassExt;


		return inherit.apply(ClassExt);
	}


	/**
	 * Подмешать методы
	 * @param   {Function}  target
	 * @returns {Function}
	 */
	inherit.apply = function (target) {
		target.extend = target.extend || function (methods) {
			return inherit(this, methods);
		};
		return target;
	};


	// Export
	return inherit;
});

/**
 * @desc    Просто функция фильтрации `filter`
 * @author  RubaXa <trash@rubaxa.org>
 * @licence MIT
 */
(function () {
	'use strict';


	/**
	 * Функция неидентичности двух переменных
	 * @param   {*}  actual
	 * @param   {*}  expected
	 * @returns {boolean}
	 */
	function notEqual(actual, expected) {
		if (actual === expected) {
			return false;
		}

		var expectedType = typeof expected;

		if (
			(expectedType === 'string' || expectedType === 'number' || expectedType === 'boolean') ||
			(actual === null && expected !== null) || (actual !== null && expected === null)
		) {
			return actual != expected;
		}

		// А теперь детально расмотрим
		var key, actualType = typeof actual;

		if (actualType === expectedType) {
			if (expected instanceof Array) {
				key = expected.length;

				while (key--) {
					if (notEqual(actual[key], expected[key])) {
						return true;
					}
				}
			}
			else if (expected instanceof Object) {
				for (key in expected) {
					 if (notEqual(actual[key], expected[key])) {
						 return true
					 }
				}
			}
		}

		return false;
	}


	/**
	 * Создать функцию сравнения
	 * @param   {Function|Object}  fn
	 * @param   {*}                thisArg
	 * @returns {Function}
	 */
	function createIterator(fn, thisArg) {
		var iterator;

		if (typeof fn === 'function') {
			iterator = thisArg
				? function (value, index, array) { return fn.call(thisArg, value, index, array); }
				: fn
			;
		}
		else {
			var keys = Object.keys(fn),
				key = keys[0],
				length = keys.length,
				expected = fn[key]
			;

			if (length === 1) {
				iterator = (key.indexOf('.') === -1)
					? function (actual) { return !notEqual(actual[key], expected); }
					: function (actual, model) { return !notEqual(model.get(key), expected); };
			}
			else {
				iterator = function (actual, model) {
					var idx = length;

					while (idx--) {
						key = keys[idx];

						if (notEqual(key.indexOf('.') === -1 ? actual[key] : model.get(key), fn[key])) {
							return false;
						}
					}

					return true;
				};
			}

			iterator.keys = keys;
			iterator.isWhere = true;
		}

		return iterator;
	}


	/**
	 * Фнукиця фильтрации
	 * @param   {Array|Object} array
	 * @param   {Function}     iterator
	 * @param   {*}            thisArg
	 * @returns {Array}
	 */
	function filter(array, iterator, thisArg) {
		if (!array) {
			return [];
		}

		var result = [],
			i = 0,
			n = array.length
		;

		if (n > 0) {
			iterator = createIterator(iterator, thisArg);

			for (; i < n; i++) {
				if (iterator(array[i], i, array)) {
					result.push(array[i]);
				}
			}
		}
		else if (array instanceof Object) {
			iterator = createIterator(iterator, thisArg);

			for (i in array) {
				if (array.hasOwnProperty(i) && iterator(array[i], i, array)) {
					result.push(array[i]);
				}
			}
		}

		return result;
	}


	filter.version = '0.1.4';
	filter.notEqual = notEqual;
	filter.createIterator = createIterator;


	// Export
	if (typeof define === 'function' && (define.amd || define.ajs)) {
		define('filter', [],function () { return filter; });
	}
	else if (typeof module != 'undefined' && typeof module.exports != 'undefined') {
		module.exports = filter;
	}
	else {
		window['filter'] = filter;
	}
})();

define('Model.List', [
	'utils/util',
	'filter',
	'inherit',
	'RPC',
	'Emitter'
], function (
	/** util */util,
	/** Function */filter,
	/** Function */inherit,
	/** RPC */RPC,
	/** Emitter */Emitter
) {
	"use strict";


	/**
	 * «Обещание» с ссылкой на список моделей, которые будут загружены
	 * @typedef  {Object}  ModelListPromise
	 * @property {Model.List} list
	 * @property {Function} then
	 * @property {Function} done
	 * @property {Function} fail
	 * @property {Function} always
	 */



	var array = [],

		array_push = array.push,
		array_join = array.join,
		array_sort = array.sort,
		array_slice = array.slice,
		array_splice = array.splice,
		array_indexOf = array.indexOf,
		array_reduce = array.reduce,

		_allModelEvents = 'sync change remove destroy',

		stringifyJSON = JSON.stringify,

		_compareAttr = function (/* Model */a, /* Model **/b, /* string */attr, /* boolean */desc) {
			var aVal = a.get(attr),
				bVal = b.get(attr),
				res = aVal - bVal;

			if (res !== res) {
				if (aVal && aVal.localeCompare) {
					res = aVal.localeCompare(bVal);
				} else {
					res = (aVal == bVal) ? 0 : (aVal > bVal ? 1 : -1);
				}
			}

			return res * (desc ? -1 : 1);
		}
	;


	/**
	 * Список моделей (коллекция)
	 * @class Model.List
	 * @constructs Model.List
	 * @mixes  Emitter
	 * @mixes  inherit
	 * @param  {Model[]}    [models]  массив моделей
	 * @param  {boolean}    [lazy]    ленивая инициализация
	 */
	function List(models, lazy) {
		this._index = {};
		this.length = 0;

		if (models instanceof Array || models instanceof List) {
			this.set(models, true);
		}
		else if (lazy) {
			this.on = this._lazyOn;
			this.get = this._lazyGet;
		}
	}


	List.fn = List.prototype = /** @lends Model.List# */ {
		constructor: List,


		/**
		 * Как сортировать коллекцию, подробнее смотрите метод `sort`
		 * @type {string|object|function}
		 */
		comparator: null,


		/**
		 * Связанная модель
		 * @type {Model}
		 */
		Model: null,


		/**
		 * Количество моделей в коллекции
		 * @type {number}
		 */
		length: 0,


		/**
		 * Дополнительные индексы
		 * @type {object}
		 * @private
		 */
		_indexes: null,


		/**
		 * Ленивая инициазиция слушателей событий
		 * @param   {string}    events
		 * @param   {Function}  fn
		 * @returns {Model.List}
		 * @private
		 */
		_lazyOn: function (events, fn) {
			var on = Emitter.fn.on,
				i = this.length;

			this.on = on; // возвращаем метод

			while (i--) {
				this[i].on(_allModelEvents, this);
			}

			return on.call(this, events, fn);
		},


		/**
		 * Ленивая инициазиция метода индекса
		 * @param   {*}    id
		 * @returns {Model}
		 * @private
		 */
		_lazyGet: function (id) {
			var get = List.fn.get,
				i = this.length,
				model,
				_index = this._index
			;

			this.get = get; // возвращаем метод

			while (i--) {
				model = this[i];
				_index[model.id] = _index[model.cid] = model;
				(this._addToIndex !== void 0) && this._addToIndex(model);
			}

			return get.call(this, id);
		},


		_debounceTriggerUpdate: util.debounce(function () {
			this.trigger('update', this);
		}, 0),


		/**
		 * Подготовить модель
		 * @param   {Object}  attrs
		 * @returns {Model}
		 * @private
		 */
		_prepareModel: function (attrs) {
			var Model = this.Model,
				model = attrs,
				id
			;

			if (!(attrs instanceof Model)) {
				// попробуем достать из глобальной коллекции
				id = attrs.cid || attrs[Model.fn.idAttr];
				model = this.get(id) || Model.all.get(id);

				if (model === void 0) {
					// Создаем модель
					model = new Model(attrs);
				}
				else {
					// просто обновляем
					model.set(attrs);
				}
			}

			return model;
		},


		/**
		 * Обработка и делигирование события от модели
		 * @param  {Emitter.Event}  evt
		 * @param  {Model}  model
		 * @private
		 */
		handleEvent: function (evt, model) {
			var type = evt.type;

			if (type === 'remove' || type === 'destroy') {
				this.remove(model);
			}
			else { // Метод `remove` сам испускает события
				evt.list = this;
				this.trigger(evt, model);
			}

			this._changed = type === 'change';

			if (this._changing !== true) { // Выставляется в `set`
				this._debounceTriggerUpdate();
			}
		},


		/**
		 * Перебор моделей
		 * @param   {Function} iterator
		 * @param   {*}  thisArg
		 * @returns {Model.List}
		 */
		each: function (iterator, thisArg) {
			for (var i = 0, n = this.length; i < n; i++) {
				iterator.call(thisArg, this[i], i, this);
			}
			return this;
		},


		/**
		 * Вернет массив, полученный преобразованием каждой модели в функции iterator
		 * @param  {Function} iterator
		 * @param  {*} thisArg
		 * @return {Array}
		 */
		map: function (iterator, thisArg) {
			var retArr = [];

			for (var i = 0, n = this.length; i < n; i++) {
				retArr.push(iterator.call(thisArg, this[i], i, this));
			}

			return retArr;
		},


		/**
		 * Применяет функцию `callback` по очереди к каждому элементу массива слева направо,
		 * сохраняя при этом промежуточный результат.
		 * @param   {Function} callback
		 * @param   {*} [initValue]
		 * @returns {*}
		 */
		reduce: function (callback, initValue) {
			return array_reduce.apply(this, arguments);
		},


		/**
		 * Посчитать сумму
		 * @param   {string} attr
		 * @returns {number}
		 */
		sum: function (attr) {
			var sum = 0;

			this.each(function (model) {
				sum += model.get(attr);
			});

			return sum;
		},


		/**
		 * Посчитать среднее арифметическое
		 * @param   {string} attr
		 * @returns {number}
		 */
		avg: function (attr) {
			return this.sum(attr) / this.length;
		},


		/**
		 * Вернет новую коллекцию, состоящую из моделей,
		 * для которых итератор возвращает истинное значение
		 * @param  {Function|Object} iterator   итератор, либо объект "имя аттрибута" => "зачение"
		 * @param  {*}               [thisArg]  `this` для итератора
		 * @param  {boolean}         [once]     вернуть первое найденное значение
		 * @returns {Model.List|Model|undefined}
		 */
		filter: function (iterator, thisArg, once) {
			var list = new (this.constructor)(null, true),
				i = 0,
				n = this.length,
				model,
				length = 0,
				isWhere
			;

			iterator = filter.createIterator(iterator, thisArg);
			isWhere = iterator.isWhere;

			for (; i < n; i++) {
				model = this[i];

				if (isWhere === true) {
					/* istanbul ignor else */
					if (iterator(model.attributes, model)) {
						list[length++] = model;
					}
				}
				else if (iterator(model, i, this)) {
					list[length++] = model;
				}

				if (length === 1 && once) {
					return list[0];
				}
			}

			if (once) {
				return;
			}

			list.length = length;

			return list;
		},


		/**
		 * Получить первую модель из коллекции
		 * @returns {Model}
		 */
		first: function () {
			return this[0];
		},


		/**
		 * Получить последнию модель из коллекции
		 * @returns {Model}
		 */
		last: function () {
			return this[this.length - 1];
		},


		/**
		 * Найти модель (см. filter)
		 * @param   {Function|Object}  iterator
		 * @param   {*}                [thisArg]
		 * @returns {Model}
		 */
		find: function (iterator, thisArg) {
			return this.filter(iterator, thisArg, true);
		},


		/**
		 * Получить массив значений по имени свойства
		 * @param   {string}  attr  имя свойства модели
		 * @returns {Array}
		 */
		pluck: function (attr) {
			return this.map(function (model) {
				return model.get(attr);
			});
		},


		/**
		 * Вернет `true`, если коллекция содержит элемент model
		 * @param   {*}  model   модель, идентификатор или cid
		 * @return {boolean}
		 */
		contains: function (model) {
			return !!this.get(model);
		},


		/**
		 * Получить index модели
		 * @param   {Model|object|string|number}  [model]   модель, объект, id или cid
		 * @returns {number}
		 */
		indexOf: function (model) {
			if (!(model instanceof Object)) {
				model = { id: model, cid: model };
			}

			var idx = this.length,
				_model;

			while (idx--) {
				_model = this[idx];

				if (_model.id === model.id || _model.cid === model.cid) {
					return idx;
				}
			}

			return -1;
		},


		/**
		 * Сортировать
		 * @param   {Object|Function}  attrs       аттрибут, объект { attr: desc(boolean) } или функция
		 * @param   {Object|boolean}   [options]   возможные опции: silent, reverse, clone
		 * @returns {Model.List}
		 */
		sort: function (attrs, options) {
			if (!attrs) {
				attrs = this.comparator || this.Model.fn.idAttr;
			}


			var _this = this,
				typeOf = typeof attrs,
				comparator,
				silent,
				reverse;


			if (options) {
				silent = options === true || options.silent;
				reverse = options.reverse;

				if (options.clone) {
					_this = _this.clone();
				}
			}


			if (typeOf === 'string') {
				// Сортировка по аттрибуту
				comparator = function (a, b) {
					return _compareAttr(a, b, attrs, reverse);
				};
			}
			else if (typeOf === 'object') {
				// сортировка по нескольким аттрибутам
				var keys = Object.keys(attrs),
					keysLength = keys.length;

				comparator = function (a, b) {
					var i = 0,
						res = 0;

					for (; i < keysLength; i++) {
						res = _compareAttr(a, b, keys[i], attrs[keys[i]] ^ reverse);

						if (res !== 0) {
							return res;
						}
					}

					return res;
				};
			}
			else {
				// Передана функция сравнения
				comparator = function (a, b) {
					return attrs.call(this, a, b) * (reverse ? -1 : 1);
				};
			}

			// Сортируем
			array_sort.call(_this, comparator);

			!silent && _this.trigger('sort', _this);

			return _this;
		},


		/**
		 * Получить модель по индексу
		 * @param   {number}  index
		 * @returns {Model|undefined}
		 */
		eq: function (index) {
			return this[index];
		},


		/**
		 * Получить модель по id
		 * @param   {*}  id   идентификатор, cid или модель
		 * @returns {Model|undefined}
		 */
		get: function (id) {
			/* jshint eqnull:true */
			return (id == null)
				? void 0
				: this._index[id.cid || id[this.Model.fn.idAttr] || id]
			;
		},


		/**
		 * Получить модель по id даже если её нет
		 * @param   {*}  id   идентификатор или cid
		 * @returns {Model}
		 */
		getSafe: function (id) {
			var model = this.get(id);

			/* istanbul ignore else */
			if (model === void 0) {
				model = new (this.Model)({ id: id && (id[this.Model.fn.idAttr] || id) });
			}

			return model;
		},


		/**
		 * Создать модель и добавить в коллекцию
		 * @param   {Object}  attrs  свойства модели
		 * @param   {Object}  [options]
		 * @returns {Model}
		 */
		create: function (attrs, options) {
			var model = this._prepareModel(attrs);
			this.set([model], options);
			return model;
		},


		/**
		 * Установить новый список моделей
		 * @param   {Model[]}  models  массив свойств или моеделей
		 * @param   {Object}   [options]   опции (clone: false, reset: false, silent: false, sort: boolean|preset, merge: true)
		 * @returns {Model.List}
		 */
		set: function (models, options) {
			var i,
				n,
				evt = new Emitter.Event('add'),
				cid,
				model,
				_models, // предудущий список моделей

				_index = this._index,
				length = this.length,

				clone = false,
				merge = true,
				reset = false,
				silent = false,
				changed = false,

				sort = !!this.comparator,
				sorted = false
			;


			// Клонируем массив, потому что дальше мы будем его модифицировать
			models = (models && models.slice) ? models.slice() : [];


			if (options) {
				clone = options.clone;
				merge = options.merge !== false;
				reset = options.reset;
				silent = options.silent || options === true;

				if (options.sort !== void 0) {
					sort = options.sort;
				}
			}


			if (reset) {
				// Сбрасываем все модели
				_models = array_splice.call(this, 0, length);
				i = length;

				reset = length > 0 || models.length > 0;
				changed = reset;

				// Отписываемся от событий модели
				while (i--) {
					_models[i].off(_allModelEvents, this);
				}

				// Сбрасываем index и длину
				length = 0;
				_index = this._index = {};
			}


			for (i = 0, n = models.length; i < n; i++) {
				this._changed = false; // Выставляет в `handleEvent` при изменении моделей (оптимизация)
				this._changing = true; // Проверяется в `handleEvent` при изменении моделей (оптимизация)

				model = this._prepareModel(models[i]);

				cid = model.cid;
				models[i] = model;

				changed = changed || this._changed;

				// Проверяем в индексе
				if (_index[cid] === void 0) {
					// Добавялем в индекс
					_index[cid] = model;
					(model.id !== null) && (_index[model.id] = model);
					(this._addToIndex !== void 0) && this._addToIndex(model);

					// Добавляем в коллекцию
					this[length] = model;
					this.length = ++length;

					// Подписываемся на события
					model.on(_allModelEvents, this);

					if (!silent) {
						// Событие "add"
						changed = true;
						evt.list = this;
						evt.target = model;
						this.trigger(evt, model);
					}
				}


				// Сохранить порядок в котором переданны элементы
				if (sort === 'preset' && this[i] !== model) {
					sorted = true;

					this[this.indexOf(model)] = this[i];
					this[i] = model;
				}

				this._changing = false;
			}


			if (merge === false) {
				// Проходимся по моделяем и удаляем которых нет
				i = length;

				while (i--) {
					if (models.indexOf(this[i]) === -1) {
						changed = true;
						this.remove(this[i]);
					}
				}
			}


			if (changed && sort === true && !sorted) {
				// Сортируем коллекцию, если были изменения
				sorted = true;
				this.sort(null, { silent: true });
			}


			if (!silent) { // Без событий
				sorted && this.trigger('sort', this);
				reset && this.trigger({ type: 'reset', models: this, previousModels: _models }, this);

				if (sorted || changed) {
					this._debounceTriggerUpdate.cancel();
					this.trigger('update', this);
				}
			}


			if (clone) {
				return new (this.constructor)(models);
			}

			return this;
		},


		/**
		 * Преобразовать в массив
		 * @returns {Model[]}
		 */
		toArray: function () {
			return array_slice.call(this);
		},


		/**
		 * Преобразовать в JSON
		 * @param   {boolean}  [ref]  вернуть ссылку на аттрибуты модели
		 * @returns {Object[]}
		 */
		toJSON: function (ref) {
			return this.map(function (model) {
				return model.toJSON(ref);
			});
		},


		/**
		 * Обрезать, возвращает новую коллекцию
		 * @param   {number}  [start]
		 * @param   {number}  [end]
		 * @returns {Model.List}
		 */
		slice: function (start, end) {
			var array = start === void 0 ? this : array_slice.call(this, start, end === void 0 ? this.length : end),
				i = array.length,
				newList = new (this.constructor)(null, true)
			;

			while (i--) {
				newList[i] = array[i];
			}

			newList.length = array.length;

			return newList;
		},


		/**
		 * Сбросить коллекуию
		 * @param   {Array}  [models]
		 * @param   {Object} [options]
		 * @returns {Model.List}
		 */
		reset: function (models, options) {
			options = options || {};

			if (options === true) {
				options = { silent: true };
			}

			options.reset = true;
			options.clone = false;

			return this.set(models, options);
		},


		/**
		 * Удалить модель из коллекции
		 * @param   {Model}  model
		 * @returns {Model.List}
		 */
		remove: function (model) {
			var evt,
				idx = array_indexOf.call(this, model);

			/* istanbul ignore else */
			if (idx !== -1) {
				model.off(_allModelEvents, this);
				array_splice.call(this, idx, 1);

				delete this._index[model.id];
				delete this._index[model.cid];

				evt = new Emitter.Event('remove');
				evt.list = this;
				evt.target = model;
				this.trigger(evt, model);
			}

			return this;
		},


		/**
		 * Сохранить изменения единой пачкой
		 * @param   {*} [attr]
		 * @param   {*} [value]
		 * @param   {*} [options]
		 * @returns {Promise}
		 */
		save: function (attr, value, options) {
			return RPC.batch(function () {
				this.each(function (model) {
					model.save(attr, value, options);
				});
			}.bind(this));
		},


		/**
		 * Удалить всю коллекцию
		 * @param   {Object}  [query] дополнительные параметры запроса
		 * @retruns {Promise}
		 */
		drop: function (query) {
			return RPC.batch(function () {
				this.each(function (model) {
					model.remove(query);
				});
			}.bind(this));
		},


		/**
		 * Уничтожить коллекцию и модели в ней
		 * @returns {Model.List}
		 */
		destroy: function () {
			var i = this.length;

			while (i--) {
				/* jshint expr:true */
				this[i] && this[i].destroy();
			}

			return this;
		},


		/**
		 * Получить или обновить список
		 * @param   {Object} [query]   параметры запроса
		 * @param   {Object} [options] опции
		 * @returns {ModelListPromise}
		 */
		fetch: function (query, options) {
			options = options || {};

			var list = this,
				Model = list.Model,
				all = Model.all,
				promise = Model.fetchData(query)
					.then(function (array) {
						all.set(array); // глобальный список
						list[options.reset ? 'reset' : 'set'](array, options);

						return list;
					})
					.fail(function (err) {
						list.emit('error', err);
					})
			;

			promise.list = list;

			return promise;
		},


		/**
		 * Клонировать коллекцию
		 * @returns {Model.List}
		 */
		clone: function () {
			return this.slice();
		}
	};


	/**
	 * @name  Model.List#forEach
	 * @alias each
	 * @method
	 */
	List.fn.forEach = List.fn.each;


	/**
	 * @name  Model.List#where
	 * @alias filter
	 * @method
	 */
	List.fn.where = List.fn.filter;


	/**
	 * @name  Model.List#findWhere
	 * @alias find
	 * @method
	 */
	List.fn.findWhere = List.fn.find;


	// Подмещиваем методы Emitter'а
	Emitter.apply(List.fn);


	// Подмещиваем наследование
	inherit.apply(List);


	/**
	 * Добавить индекс для быстрого доступа к модели/моделям
	 * @param    {string}  attr  имя свойства
	 * @param    {boolean} [uniq]  уникальный индекс
	 * @methodOf List
	 */
	List.addIndex = function (attr, uniq) {
		var _indexes = this.fn._indexes;

		/* istanbul ignore else */
		if (!_indexes) {
			_indexes = this.fn._indexes = [];
		}

		_indexes.push({
			attr: attr,
			uniq: uniq
		});

		/* jshint evil:true */
		this.fn._addToIndex = Function('model', _indexes.map(function (index) {
			var attr = stringifyJSON(index.attr),
				value = attr.indexOf('.') > -1
							? 'model.get(' + attr + ')'
							: 'model.attributes[' + attr + ']';

			/* istanbul ignore else */
			if (index.uniq) {
				return 'this._index[' + value + '] = model;';
			} else {
				throw "todo: Нужно думать";
			}
		}).join('\n'));
	};


	// Export
	List.version = '0.9.0';
	return List;
});

define('Model', [
	'inherit',
	'logger',
	'request',
	'Promise',
	'Emitter',
	'Model.List',
	'config'
], function (
	/** function */inherit,
	/** logger */logger,
	/** request */request,
	/** Promise */Promise,
	/** Emitter */Emitter,
	/** Model.List */List,
	/** config */config
) {
	"use strict";

	var _toString = {}.toString;
	var _stringifyJSON = JSON.stringify;
	var _type = function (val) {
		return val === null ? 'null' : _toString.call(val).toLowerCase().slice(8, -1);
	};



	// Установка аттрибутов согласно схеме
	var _setAttr = function (model, absKey, attr, newValue, changed, changes) {
		var idx = absKey.lastIndexOf('.'),
			attributes = model.attributes,
			_attributes = model._attributes,
			value = attributes[attr];

		if (idx !== -1) {
			attr = absKey.substr(idx + 1);
			value = model.get(absKey);
		}

		if (model.constructor.scheme[absKey] === 'set') {
			for (var key in newValue) {
				_setAttr(model, absKey + '.' + key, key, newValue[key], changed, changes);
			}
		}
		else if (_notEqual(value, newValue)) {
			if (absKey !== attr) {
				var chain = absKey.split('.');

				for (var i = 0, n = chain.length - 1, part, dottedKey; i < n; i++) {
					part = chain[i];

					if (attributes[part] === void 0) {
						attributes[part] = {};
					}

					if (_attributes[part] === void 0) {
						_attributes[part] = {};
					}

					if (changed[part] === void 0) {
						changed[part] = {};
					}

					attributes = attributes[part];
					_attributes = _attributes[part];
					changed = changed[part];

					dottedKey = dottedKey === void 0 ? part : dottedKey + '.' + part;

					if (changes[dottedKey] === void 0) {
						changes[dottedKey] = attributes;
						changes.push(dottedKey);
					}
				}
			}

			_attributes[attr] = value;
			changed[attr] = newValue;
			attributes[attr] = newValue;

			changes.push(absKey);
			changes[absKey] = newValue;
		}
	};


	/**
	 * «Обещание» с ссылкой на модель, которая будет загружена
	 * @typedef  {Object}  ModelPromise
	 * @property {Model}    model
	 * @property {Function} then
	 * @property {Function} done
	 * @property {Function} fail
	 * @property {Function} always
	 */


	/**
	 * Локальный идентификтор модели
	 * @type {number}
	 */
	var cid = 1;


	/**
	 * Быстрое клонирование
	 * @param   {*}  obj
	 * @param   {boolean} [isObject]
	 * @returns {*}
	 * @private
	 */
	function _clone(obj, isObject) {
		var i, key,
			res = obj;

		if (isObject !== true && obj instanceof Array) {
			i = obj.length;
			res = [];
			while (i--) {
				res[i] = _clone(obj[i]);
			}
		} else if (isObject === true || obj instanceof Object) {
			res = {};
			for (key in obj) {
				res[key] = _clone(obj[key]);
			}
		}

		return res;
	}


	/**
	 * Быстрое сравнение двух переменных
	 * @param   {*}  actual
	 * @param   {*}  expected
	 * @returns {boolean}
	 * @private
	 */
	function _notEqual(actual, expected) {
		if (actual === expected) {
			return false;
		}

		var expectedType = typeof expected;

		if (expectedType === 'string' || expectedType === 'number' || expectedType === 'boolean') {
			return actual != expected;
		}

		// А теперь детально расмотрим
		var idx, actualType = typeof actual;

		/* istanbul ignore else */
		if (actualType === expectedType) {
			if (actual === null) {
				return true;
			}

			/* istanbul ignore else */
			if (expected instanceof Array) {
				idx = expected.length;

				if (actual.length !== idx) {
					return true;
				}

				while (idx--) {
					if (_notEqual(actual[idx], expected[idx])) {
						return true;
					}
				}
			}
			else if (expected instanceof Object) {
				var key,
					keys = Object.keys(expected)
				;

				idx = keys.length;

				if (Object.keys(actual).length !== idx) {
					return true;
				}

				while (idx--) {
					key = keys[idx];

					if (_notEqual(actual[key], expected[key])) {
						return true;
					}
				}
			}

			return false;
		}

		return true;
	}


	/**
	 * Создаеть геттер для атрибутов
	 * @param   {string}   attrs    название своства
	 * @param   {boolean}  retBool  вернуть булево значение
	 * @returns {Function}
	 * @private
	 */
	function _createGetter(attrs, retBool) {
		var code = (function (name) {
			var attributes = this.$,
				retVal = attributes[name = (this.shortcuts[name] || name)]
			;

			/* istanbul ignore else */
			if (retVal === void 0 && name.indexOf('.') !== -1) {
				name = name.split('.');

				if (name.length === 2) {
					retVal = attributes[name[0]] && attributes[name[0]][name[1]];
				}
				else {
					for (var i = 0, n = name.length - 1; i < n; i++) {
						attributes = attributes[name[i]];

						if (!attributes) {
							return;
						}
					}

					retVal = attributes[name[n]];
				}
			}

			return retVal;
		}).toString();

		if (retBool) {
			code = code
				.replace(/(return)\s+(.+,\s*)?(\w+)/, function (_, ret, incut, retVal) {
					return ret + (incut || '') + '!!' + retVal;
				})
				.replace(/(return)(.*?)(;|})/, function (_, ret, incut, end) {
					/* istanbul ignore next */
					return ret + (incut ? incut + ',' : '') + ' false' + end;
				})
			;
		}

		/* jshint evil:true */
		return Function('return ' + code.replace('this.$', 'this.' + attrs))();
	}


	/**
	 * Модель
	 * @class Model
	 * @constructs Model
	 * @mixes Emitter
	 * @param  {Object}  [attrs]  свойства
	 */
	function Model(attrs) {
		var key,
			valueValidator = this.valueValidator,
			value,
			attributes = this.attributes = {},
			defaults = this.defaults
		;


		this.cid = 'c' + cid++;
		this.changed = {}; // Если это не сделать, будет работать с общим объектом в прототипе
		this._attributes = {};


		// Устанавливаем свойства модели
		/* istanbul ignore else */
		if (attrs) {
			for (key in attrs) {
				value = attrs[key];

				/* istanbul ignore else */
				if (valueValidator !== null) {
					value = valueValidator(value, key, attrs, this);
				}

				attributes[key] = value;
			}
		}


		// Заполняем свойствами по умолчанию
		for (key in defaults) {
			/* istanbul ignore else */
			if (attributes[key] === void 0) {
				value = defaults[key];

				/* jshint eqnull:true */
				/* istanbul ignore else */
				if ((value !== null) && (typeof value === 'object')) {
					value = _clone(value);
				}

				attributes[key] = value;
			}
		}


		// Идетификатор модели
		/* istanbul ignore else */
		if (attributes[this.idAttr] !== void 0) {
			this.id = attributes[this.idAttr];
		}


		if (this._updateGetters !== void 0) {
			this._updateGetters(attributes, attributes);
		}
	}


	Model.fn = Model.prototype = /** @lends Model# */{
		constructor: Model,

		/**
		 * Название класса
		 * @type {string}
		 */
		className: 'Model',


		/**
		 * Локальный идентификатор модели
		 * @type  {string}
		 */
		cid: null,

		/**
		 * Идентификатор модели (PK)
		 * @type {*}
		 */
		id: null,


		/**
		 * Имя свойства-идентификатора (PK)
		 * @type {string}
		 */
		idAttr: 'id',


		/**
		 * Свойства по умолчанию
		 * @type {Object}
		 */
		defaults: {},


		/**
		 * Доступ к свойствам через гетеры, либо определить объект "геттер" => "свойство"
		 * @type {boolean|Object}
		 */
		getters: false,


		/**
		 * Тригеры на add/update/save/remove, а так же beforeadd и т.д.
		 * @type {Object}
		 */
		triggers: {},


		/**
		 * Валидатор значения аттрибута
		 * @type {Function|null}
		 */
		valueValidator: null,


		/**
		 * Список измененнных ствойств их новых значений
		 * @type {Object}
		 */
		changed: {},


		/**
		 * Список измененнных ствойств их старых значений
		 * @type {Object}
		 * @private
		 */
		_attributes: {},


		/**
		 * Короткий доступ к свойствам
		 * @type {Object}
		 */
		shortcuts: {},


		/**
		 * Объект отвечающий за запросы к серверу
		 * @type {request}
		 */
		request: request,


		/**
		 * Объект отвечающий за хранение данных (кеш)
		 * @type {Storage}
		 */
		storage: null,


		/**
		 * URL получения/сохранения/удаления модели
		 * @type {string}
		 */
		url: "",


		/**
		 * URL получения списка моделей (коллекции)
		 * @type {string}
		 */
		findUrl: "",


		/**
		 * URL получения одной модели
		 * @type {string}
		 */
		findOneUrl: "",


		/**
		 * URL создания модели
		 * @type {string}
		 */
		addUrl: "",


		/**
		 * URL сохранения модели
		 * @type {string}
		 */
		saveUrl: "",


		/**
		 * URL удаления
		 * @type {string}
		 */
		removeUrl: "",


		/**
		 * Проверить значение свойства на истинность
		 * @param   {string}  name
		 * @returns {boolean}
		 * @method Model#is
		 */
		is: _createGetter('attributes', true),


		/**
		 * Получить значение свойства
		 * @param   {string}  name
		 * @returns {*}
		 * @method Model#get
		 */
		get: _createGetter('attributes'),


		/**
		 * Получить предыдущие значение свойства
		 * @param   {string}  name
		 * @returns {*}
		 * @method Model#previous
		 */
		previous: _createGetter('_attributes'),


		/**
		 * Вызвать тригер
		 * @param  {String} name
		 * @param  {*} [args]
		 * @private
		 */
		_callTrigger: function (name, args) {
			var trigger = this.triggers[name];
			trigger && trigger.call(this, args);
		},


		/**
		 * Установить свойства или свойство
		 * @param   {string|Object}  attr  название или объект свойств
		 * @param   {*|Object}       [newValue]  значение или опции
		 * @param   {boolean|Object} [options] опции (silent, clean)
		 * @returns {Model}
		 */
		set: function (attr, newValue, options) {
			var attrs,
				changes = [],
				silent, // не испускать событий при изменении
				changed = this.changed,
				valueValidator = this.valueValidator,
				evt, i // loops vars
			;


			// Получем свойства
			if (typeof attr === 'object') {
				attrs = attr;
				options = options || newValue;
			} else {
				(attrs = {})[attr] = newValue;
			}


			// Опции
			if (options instanceof Object) {
				silent = options.silent;

				if (options.clean) {
					// установить свойства и не оставить следа об этих изменениях
					changed = {};
				}
			}
			else {
				silent = (options === true);
			}


			// Назначаем идентификатор (PK), если его передали
			/* istanbul ignore else */
			if (attrs[this.idAttr] !== void 0) {
				this.id = attrs[this.idAttr];
			}


			// Перебераем и изменяем свойства
			for (attr in attrs) {
				newValue = attrs[attr]; // Новое значение
				attr = (this.shortcuts[attr] || attr);

				/* istanbul ignore else */
				if (valueValidator !== null) {
					newValue = valueValidator(newValue, attr, attrs, this);
				}

				_setAttr(this, attr, attr, newValue, changed, changes);
			}


			if ((this._updateGetters !== void 0) && (changes.length > 0)) {
				// Обновим геттеры
				this._updateGetters(changed, attrs);
			}


			// Если есть изменения и не «тишина»
			/* istanbul ignore else */
			if ((changes.length > 0) && !silent) {
				i = changes.length;

				evt = new Emitter.Event(''); // для «скорости» используем единый объект
				evt.target = this.model;
				evt.changes = changes;

				while (i--) {
					attr = changes[i];

					evt.attr = attr;
					evt.type = 'change:' + attr;
					evt.changed = changes[attr];
					evt.allChanged = changed;

					this.trigger(evt, this);
				}

				evt.type = 'change';
				evt.changed = changed;

				this.trigger(evt, this);
			}

			return this;
		},

		
		/**
		 * Увеличить атрибут на `value`
		 * @param   {string}  attr
		 * @param   {number}  [value]
		 * @param   {object}  [options]
		 * @returns {Model}
		 */
		increment: function (attr, value, options) {
			if (arguments.length == 1 || value instanceof Object) {
				options = value;
				value = 1;
			}

			value = parseInt(value, 10);

			return Number.isNaN(value) ? this : this.set(attr, this.get(attr) + value, options);
		},


		/**
		 * Получить объект свойств (клон аттрибутов)
		 * @param   {boolean}  [ref]  вернуть ссылку на аттрибуты
		 * @returns {Object}
		 */
		toJSON: function (ref) {
			var attrs = this.attributes;
			return ref ? attrs : _clone(attrs, true);
		},


		/**
		 * Явялется ли модель «новой»?
		 * @returns {boolean}
		 */
		isNew: function () {
			return this.id === null;
		},


		/**
		 * Очередь действий
		 * @param   {Function}  fn
		 * @returns {Promise}
		 */
		queue: function (fn) {
			var meta = logger.meta(-2),
				model = this,
				call = function () {
					/* istanbul ignore else */
					if (model.removed) {
						// @todo: Безумно спорное место, как и весь `removed`
						var err = new Error('MODEL_REMOVED');
						err.model = model;
						return Promise.reject(err);
					}

					return fn(model, meta);
				}
			;

			if (!this._queue) {
				this._queue = new Promise(function (resolve) { resolve(); });
				//this._queue.__logger__.meta = meta;
			}


			this._queue = this._queue.then(call, call);
			//this._queue.__logger__.meta = meta;

			return this._queue;
		},


		/**
		 * Вызывается при findOne, если вернуть `false` будет отправлен запрос на серевер
		 * @returns {boolean}
		 * @protected
		 */
		isDataFully: function () {
			return true;
		},


		/**
		 * Изменена ли модель?
		 * @param   {string}  [name]
		 * @returns {boolean}
		 */
		hasChanged: function (name) {
			/* istanbul ignore else */
			if (name) {
				return this.changed[name];
			}

			for (var key in this.changed) {
				/* istanbul ignore else */
				if (this.changed.hasOwnProperty(key)) {
					return true;
				}
			}

			return this.isNew();
		},


		/**
		 * Обновить информацию о модели
		 * @param   {Object}  [params]  доп. параметры
		 * @returns {Promise}
		 */
		fetch: function (params) {
			params = params || {};
			params[this.idAttr] = this.id;
			return this.constructor.findOne(params);
		},


		/**
		 * Предварительная обработка ответа сервера
		 * @param   {Object}  body  тело ответа
		 * @param   {request.Request} req  объект запроса
		 * @returns {Object}
		 */
		parse: function (body, req) {
			return body;
		},

		/**
		 * Подготовка данных модели перед отправкой на сервер
		 * @param   {String} method метод сохранения add или save
		 * @param   {Object} attrs свойства модели
		 * @returns {Object} свойства модели, подготовленные для передачи в запрос
		 */
		prepareSendData: function (method, attrs) {
			return attrs;
		},

		/**
		 * Сохранить модель
		 * @param   {string|Object}   [attr]    свойство, которое нужно установить перед сохранением
		 * @param   {*}               [value]   значение
		 * @param   {Object|boolean}  [options] опции
		 * @returns {Promise}
		 */
		save: function save(attr, value, options) {
			/* istanbul ignore else */
			if (attr) {
				// Устанавливаем аттрибуты, если переданны (до сохранения)
				this.set(attr, value, options);
			}

			return this.queue(function (/** Model */model, /** LoggerMeta */meta) {
				if (model.hasChanged()) {
					var isNew = model.isNew(),
						attrs = model[isNew ? 'attributes' : 'changed'],
						method = model.addUrl && isNew ? 'add' : 'save',
						url = model.constructor.url(method, model.attributes)
					;

					model._callTrigger(isNew ? 'beforeadd' : 'beforeupdate', attrs);
					model._callTrigger('beforesave', attrs);

					// Для поддержки saveUrl
					if (!isNew) {
						attrs[model.idAttr] = model.id;
					}

					// Подготавливаем данные
					attrs = model.prepareSendData(method, attrs);

					// Сбрасываем изменения
					model.changed = {};

					// Обновляем данные в хранилище
					model.storage && model.storage.update(model.toJSON());

					// Отправляем запрос
					return model.request.post(
						url,
						attrs,
						{
							logger: model.className + '.save',
							loggerMeta: meta
						}).then(function (req) {
							var body = model.parse(req.body, req);

							body && model.set(body, { clean: true });
							model.constructor.all.set([model]);
							model.trigger('sync', model);

							model._callTrigger(isNew ? 'add' : 'update', attrs);
							model._callTrigger('save', attrs);

							return model;
						});
				} else {
					return model;
				}
			});
		},


		/**
		 * Удалить модель
		 * @param   {Object}   [query]  дополнительные GET-параметры
		 * @returns {Promise}
		 */
		remove: function remove(query) {
			return this.queue(function (/** Model */model, /** LoggerMeta */meta) {
				query = query || {};
				query[model.idAttr] = model.id;

				query = model.prepareSendData('remove', query);
				model._callTrigger('beforeremove', query);

				return model.request.call(
					model.constructor.url('remove', model),
					query,
					{
						logger: model.className + '.remove',
						loggerMeta: meta,
						type: 'DELETE'
					}).done(function () {
						model.removed = true; // помечаем объект как удаленный
						model.trigger({ type: 'remove', model: model }, model);
						model.destroy();
						model._callTrigger('remove', query);
					});
			});
		},


		/**
		 * Уничтожить модель
		 * @returns {Model}
		 */
		destroy: function () {
			var model = this;

			/* istanbul ignore else */
			if (!model.destroyed) {
				model.destroyed = true;
				
				// Удаляем данные из хранилища
				model.storage && model.storage.remove(model.id);
				model.trigger({type: 'destroy', model: model}, model);

				model.off(); // и отписываем всех слушателей
			}
		},


		/**
		 * Добавить запись в лог
		 * @param {string} label
		 * @param {*}      [args]
		 */
		log: function (label, args) {
			logger.add(this.className + ':' + label, args);
		},


		/**
		 * Метод для установки или получения мета информации о модели
		 * @param {string|object} [property] имя свойства (с поддержкой точечной нотации) или обьект свойство:значение
		 * @param {*} [value] значение для установки
		 * @returns {*}
		 */
		meta: function (property, value) {
			var _meta = this._meta,
				argsLength = arguments.length;

			if (_meta === void 0 || property === null) {
				this._meta = _meta = config({});
			}

			/* istanbul ignore else */
			if (argsLength === 0) {
				return _meta;
			}
			else if (argsLength === 2) {
				_meta.set(property, value);
			}
			else if (argsLength === 1) {
				if (typeof property === 'object') {
					_meta.set(property);
				} else {
					return _meta.get(property);
				}
			}

			return this;
		}
	};


	/**
	 * Создание расширенной модели
	 * @memberOf Model
	 * @param   {Object} methods
	 * @returns {Model}
	 */
	Model.extend = function (methods) {
		var ModelExt = inherit(this, methods),
			prototype = ModelExt.fn,
			scheme = (ModelExt.scheme = {}),
			defaults = prototype.defaults,
			getters = prototype.getters;

		// Коллекция
		ModelExt.List = ModelExt.List.extend({ Model: ModelExt });

		// Глобальная коллекция в рамках модели
		ModelExt.all = new (ModelExt.List);
		ModelExt._findOneModels = {};

		// Генерируем схему
		/* istanbul ignore else */
		if (defaults) {
			(function _walker(attrs, prefix) {
				var keys = Object.keys(attrs);

				if (keys.length) {
					prefix = prefix ? prefix + '.' : '';

					keys.forEach(function (key) {
						var value = attrs[key];

						if (value instanceof Object) {
							scheme[prefix + key] = 'set';
							_walker(value, prefix + key);
						}
						else {
							scheme[prefix + key] = _type(value);
						}
					});
				}
				else {
					scheme[prefix] = _type(attrs);
				}
			})(defaults);
		}

		// Генерируем геттеры
		if (getters) {
			if (getters === true) {
				getters = {};

				Object.keys(defaults).forEach(function (attr) {
					getters[attr] = null;
				});
			}

			// Генерируем метод обновления геттеров
			/* jshint evil:true */
			prototype._updateGetters = Function(Object.keys(getters).map(function (name, getter) {
				getter = getters[name];

				/* istanbul ignore else */
				if (prototype.hasOwnProperty(name)) {
					throw "Unable to create a getter `" + name + "`, this key is already in use";
				}
				else if (typeof getter === 'function') {
					prototype['__getter__' + name] = getter;
					getter = 'this.__getter__' + name + '()';
				}
				else if (typeof prototype[getter] === 'function') {
					getter = 'this.' + getter + '()';
				}
				else if (getter === null || typeof getter === 'string') {
					getter = 'this.get(' + _stringifyJSON(getter || name) + ')';
				}

				return 'this.' + name + ' = ' + getter;
			}).join('\n'));
		}

		return	ModelExt;
	};


	/**
	 * Схема модели
	 * @type {Object}
	 */
	Model.scheme = {};


	/**
	 * Приватная коллекция для целосности поиска
	 * @type {Object}
	 * @private
	 */
	Model._findOneModels = {};


	/**
	 * Класс коллекции
	 * @static
	 * @memberOf Model
	 * @type {Model.List}
	 */
	Model.List = List;
	Model.List.fn.Model = Model; // Спорно, знаю.


	/**
	 * Глобальная коллекция для модели
	 * @static
	 * @memberOf Model
	 * @type {Model.List}
	 */
	Model.all = new List;


	/**
	 * Установить модели в глобальной колеккции
	 * @memberOf Model
	 * @param   {Model[]}   models
	 * @param   {Object}    options
	 * @returns {*}
	 */
	Model.set = function (models, options) {
		return this.all.set(models, options);
	};


	/**
	 * Получить модель из глобальной коллекции
	 * @memberOf Model
	 * @param   {string|number}  id
	 * @returns {Model|undefined}
	 */
	Model.get = function (id) {
		return this.all.get(id);
	};


	/**
	 * Получить модель из глобальной коллекции даже если её нет
	 * @memberOf Model
	 * @param   {string|number}  id
	 * @returns {Model}
	 */
	Model.getSafe = function (id) {
		return this.all.getSafe(id);
	};


	/**
	 * Создание mock для модели
	 * @memberOf Model
	 * @param  {Object}  mocks
	 */
	Model.mock = function (mocks) {
		for (var method in mocks) {
			var url,
				variants = [].concat(mocks[method]),
				i = 0,
				n = variants.length,
				query
			;

			for (; i < n; i++) {
				url = this.url(method, variants[i].query || {});
				query = method == 'add' ? new this(variants[i].query).toJSON() : variants[i].query;

				this.fn.request.mock({
					url: url,
					once: variants[i].once,
					type: /^find/.test(method) ? 'GET' : (/remove/.test(method) && !this.fn.request.setup('emulateHTTP') ? 'DELETE' : 'POST'),
					data: /^(add|save|remove)$/.test(method) ? this.fn.prepareSendData(method, query) : query,
					status: variants[i].status,
					body: variants[i].body,
					responseText: variants[i].result
				});
			}
		}
	};


	/**
	 * Сформировать URL
	 * @memberOf Model
	 * @param   {string}  name
	 * @param   {Object}  [params]
	 * @returns {string}
	 */
	Model.url = function (name, params) {
		var url = this.fn[name + 'Url'] || this.fn.url;

		/* istanbul ignore else */
		if (typeof url === 'function') {
			url = url(params);
		}
		
		return String(url).replace(/:([a-z]+)/gi, function (_, name) {
			return params[name] || '';
		}).replace(/([^$\/])\/+/g, '$1/');
	};


	/**
	 * Получить данные от сервера, либо из кеша
	 * @memberOf Model
	 * @param   {Object}   query
	 * @param   {boolean}  [single]
	 * @returns {Promise}
	 */
	Model.fetchData = function (query, single) {
		var meta = logger.meta(-2),
			XModel = this,
			storage = XModel.fn.storage,
			method = single ? 'findOne' : 'find',
			promise,

			findReq = function () {
				// Формируем url
				var url = XModel.url(method, query);

				// В стородже ничего, выполняем запрос
				return XModel.fn.request.get(
					url,
					query,
					{
						logger: XModel.fn.className + '.' + method,
						loggerMeta: meta,
						dataType: 'json'
					}).then(function (req) {
						// Данные получены, сохраняем в хранилище
						var body = XModel.fn.parse(req.body, req);
						storage && storage.save(method, query, body);
						return body;
					});
			}
		;

		query = query || {};

		if (storage) {
			// Пробуем получить данные из хранилища
			promise = logger.wrap('[[' + XModel.fn.className + '.storage.' + method + ']]', query, storage[method](query))['catch'](findReq);
		} else {
			promise = findReq();
		}

		/* jshint expr:true */
		promise.__logger__ && (promise.__logger__.meta = meta);
		promise.__noLog = true;

		return promise;
	};


	/**
	 * Получить коллекцию
	 * @memberOf Model
	 * @param   {Object}   [query]   запрос
	 * @param   {Object}   [options] опции
	 * @returns {ModelListPromise}
	 */
	Model.find = function find(query, options) {
		return (new this.List).fetch(query, options);
	};


	/**
	 * Получить модель
	 * @memberOf Model
	 * @param   {Object|string}   query   запрос или id
	 * @returns {ModelPromise}
	 */
	Model.findOne = function findOne(query) {
		var XModel = this,
			idAttr = XModel.fn.idAttr,
			hasOne = !!(XModel.fn.findOneUrl || XModel.fn.url),
			model,
			id,
			promise,
			queryKey,
			_findOneModels = XModel._findOneModels
		;

		/* jshint eqnull:true */
		if ((query != null) && !(query instanceof Object)) {
			id = query;
			(query = {})[idAttr] = id;
		} else {
			query = query || /* istanbul ignore next */ {};
		}

		// Пробуем получить модель из глобальной коллекции или зарезервировать его в длкальном хранилиже.
		// todo: Тут есть возможный баг, что параллельно отработает `find` и создаст модель с таким же `id`, в итоге инстансы будут разными
		id = query[idAttr];
		queryKey = _stringifyJSON(query);
		model = XModel.all.get(id) || (_findOneModels[queryKey] || (_findOneModels[queryKey] = new XModel));

		if (model && !model.isNew() && model.isDataFully(query)) {
			promise = Promise.resolve(model);
		}
		else {
			// Если нет `findOneUrl` то делаем запрос без параметров,
			// после чего из коллекции получем модель
			promise = this.fetchData(hasOne ? query : {}, hasOne)
				.then(function (attrs) {
					var err;

					if (!hasOne || id == null) {
						attrs = (id == null)
									? ((attrs instanceof Array) ? attrs[0] : attrs)
									: attrs.filter(function (attrs) { return attrs[idAttr] == id; })[0]
						;
					}

					if (attrs) {
						model.set(attrs, { clean: model.isNew() });
						XModel.all.set([model]);

						// Удаляем только на «успех»
						delete _findOneModels[queryKey];

						return model;
					}
					else {
						err = new Error('MODEL_NOT_FOUND');
						model.emit('error', err);
						model.log('error', err);

						return Promise.reject(err);
					}
				})
				.fail(function (err) {
					model.log('error', err);
					model.emit('error', err);
				})
			;
		}

		promise.model = model;

		return promise;
	};


	/**
	 * Создать и сохранить модель
	 * @param   {Object}  attrs
	 * @returns {Promise}
	 */
	Model.save = function (attrs) {
		var model = new this(attrs);
		return model.save();
	};


	/**
	 * Мапинг данных в модель или коллекцию
	 * @param   {Object|Object[]} data
	 * @returns {Model|Model.List}
	 */
	Model.map = function (data) {
		var result = this.all.set([].concat(data), { clone: true });
		return (data instanceof Array) ? result : result[0];
	};


	// Подмешиваем Emitter
	Emitter.apply(Model.fn);


	// Export
	Model.version = '0.5.1';
	return Model;
});

define('Action', [
	'logger',
	'inherit',
	'Promise',
	'Emitter',
	'Model',
	'Model.List'
], function (
	/** logger */logger,
	/** inherit */inherit,
	/** Promise */Promise,
	/** Emitter */Emitter,
	/** Model */Model,
	/** Model.List */List
) {
	'use strict';


	// Получить параметры для логирования
	var _getLogParams = function (value) {
		var i,
			result = value;

		if (value && typeof value === 'object') {
			/* istanbul ignore next */
			if (value.toLogJSON) {
				result = value.toLogJSON();
			}
			else if (value instanceof Model) {
				result = value.id;
			}
			else if (value instanceof List) {
				result = value.pluck('id');
			}
			else if (Array.isArray(value)) {
				i = value.length;
				result = [];

				while (i--) {
					result[i] = _getLogParams(value[i]);
				}
			}
			else {
				result = {};
				Object.keys(value).forEach(function (key) {
					result[key] = _getLogParams(value[key]);
				});
			}
		}

		return result;
	};



	/**
	 * Действие.
	 * @abstract
	 * @class Action
	 * @constructs Action
	 * @extends Emitter
	 * @returns {Promise}
	 */
	var Action = inherit(Emitter, /** @lends Action# */{
		/**
		 * Имя действия
		 * @type {string}
		 */
		name: 'abstract',


		/**
		 * Конструктор
		 * @param  {Object}  params   параметры
		 * @param  {Object}  options  опции
		 * @constructor
		 */
		constructor: function (params, options) {
			/**
			 * Параметры
			 * @type {Object}
			 */
			this.params = params;


			/**
			 * Опции
			 * @type {Object}
			 */
			this.options = options;


			/**
			 * Подготовленные данные
			 * @type {boolean}
			 * @private
			 */
			this._data;


			/**
			 * Статус команды «в работе≠
			 * @type {boolean}
			 */
			this.pending = false;


			/**
			 * Статус выполнения действия
			 * @type {*}
			 */
			this.status;


			/**
			 * Ошибка при выполнении
			 * @type {*}
			 */
			this.error = null;


			/**
			 * Результат успешного выполнения
			 * @type {*}
			 */
			this.result = null;


			return options.logScope.call(this._execute.bind(this));
		},


		/**
		 * Выполнить действие
		 * @private
		 * @return {Promise}
		 */
		_execute: function () {
			var _this = this,
				params = _this.params,
				options = _this.options,
				logScope = options.logScope;


			// «Поехали!»
			_this.pending = true;

			Action.trigger('start', [_this, params, options]);

			return new Promise(function (resolve) {
				// Безопасное выполнение внутри `Promise`
				resolve(_this.prepare(params, options));
			}.logger(_this.name + '.prepare')).then(
				// Данные успешно подготовлены
				function (data) {
					if (data === null) {
						// нужно выходить
						logScope.add('operation:exit');
						_this._resolve('done', data);

						return _this;
					}

					if (data === void 0) {
						// используем исходные данные
						data = params;
					}

					_this._data = data;

					// «Операция!»
					return new Promise(function (resolve) {
						_this.trigger('operation', [data, params, options]);
						resolve(_this.operation(data, params, options));
					}.logger(_this.name + '.operation')).then(
						// Это успех!
						function (result) {
							logScope.add('operation:done');
							_this._resolve('done', result);

							return _this;
						},

						// Ошибка, нужно откатывать
						function (error) {
							logScope.add('operation:fail', error);

							_this.rollback();
							_this._resolve('fail', error);

							return Promise.reject(_this);
						}
					);
				},

				// Ошибка при подготовке данных
				function (error) {
					logScope.add('prepare:fail', error);
					_this._resolve('fail', error);

					return Promise.reject(_this);
				}
			);
		},


		/**
		 * Отмена действия
		 * @public
		 * @return {Promise}
		 */
		undo: function () {
			var _this = this,
				args = [_this._data, _this.params, _this.options],
				promise = _this._undoPromise,
				logScope;

			if (!promise) {
				logScope = logger.scope('[[' + _this.name + '.undo]]');

				_this._undoPromise = promise = new Promise(logScope.wrap(function (resolve) {
					_this.trigger.apply(_this, ['undo'].concat(args));
					Action.trigger.apply(_this, ['undo', _this].concat(args));

					resolve(_this.undoOperation.apply(_this, args));
				}));

				promise.then(
					_this._resolveUndo.bind(_this, logScope, true),
					_this._resolveUndo.bind(_this, logScope, false)
				);
			}

			return promise;
		},


		/**
		 * Подготовить данные для выполнения действия
		 * @protected
		 * @param  {Object}  params
		 * @param  {Object}  options
		 */
		prepare: function (params, options) {
		},


		/**
		 * Выполняемая операция
		 * @protected
		 * @param  {*}       data  подготовленные операции (или теже `params`)
		 * @param  {object}  params
		 * @param  {object}  options
		 */
		operation: function (data, params, options) {
		},


		/**
		 * Обратная операция
		 * @protected
		 * @param  {*}       data
		 * @param  {Object}  params
		 * @param  {Object}  options
		 */
		undoOperation: function (data, params, options) {
			logger.add('NOT_IMPLEMENTED');
			throw 'NOT_IMPLEMENTED';
		},


		/**
		 * Опредация откатки изменений
		 * @protected
		 * @param  {*}       data
		 * @param  {Object}  params
		 * @param  {Object}  options
		 */
		rollbackOperation: function (data, params, options) {
			logger.add('NOT_IMPLEMENTED');
		},


		/**
		 * Откатываем действие при ошибке (не путать с `undo`)
		 * @public
		 */
		rollback: function () {
			var _this = this,
				options = _this.options;

			options.logScope.call('[[' + _this.name + '.rollback]]', function () {
				try {
					_this.rollbackOperation(_this._data, _this.params, options);
				} catch (err) {
					logger.add('error', err);
				}
			});
		},


		/**
		 * Разрешить действие
		 * @private
		 * @param  {string} status
		 * @param  {*}      result
		 */
		_resolve: function (status, result) {
			this.pending = false;
			this.status = status;
			this[status == 'done' ? 'result' : 'error'] = result;

			this.trigger(status, result);
			this.trigger('complete', [this, status, result]);

			Action.trigger(status, [this, result]);
			Action.trigger('complete', [this, status, result]);
		},


		/**
		 * Разрешить аннуляцию действия
		 * @private
		 * @param  {logger.Entry} undoLogScope
		 * @param  {boolean}      status
		 * @param  {*}            result
		 */
		_resolveUndo: function (undoLogScope, status, result) {
			var args = [this, status, result];

			undoLogScope.add('undo:' + (status ? 'done' : 'fail'), status ? void 0 : result);

			this.trigger('undo:complete', args);
			Action.trigger('undo:complete', args);
		},


		/**
		 * Излучатель события
		 * @override
		 * @param {string} type
		 * @param {Array}  args
		 */
		emit: function (type, args) {
			var options = this.options;

			if (options['on' + type]) {
				options['on' + type].apply(this, args);
			}

			return Emitter.fn.emit.apply(this, arguments);
		}
	});


	// Подмешиваем события
	Emitter.apply(Action);


	/**
	 * Регистрация действия
	 * @static
	 * @param  {string}  name       название действия
	 * @param  {Action}  NewAction  класс действия
	 * @memberOf Action
	 */
	Action.register = function (name, NewAction) {
		this[name] = NewAction;

		// Экспортируем имя действия
		NewAction.prototype.name = name;

		// Статический метод для выполнения действия
		NewAction.execute = function (params, options) {
			return Action.execute(name, params, options);
		};

		return NewAction;
	};


	/**
	 * Выполнить действие.
	 * @static
	 * @param   {string}  name
	 * @param   {Object}  [params]
	 * @param   {Object}  [options]
	 * @return  {Promise}
	 * @memberOf Action
	 */
	Action.execute = function (name, params, options) {
		/** @type {Action}*/
		var Target = this[name],
			logScope = logger.scope('[[Action:' + name + ']]', _getLogParams(params)),
			error = 'ACTION_NOT_FOUND:' + name;

		if (!Target) {
			logScope.add(error);
		}

		options = options || {};
		options.logScope = logScope;

		return Target ? new Target(params, options) : Promise.reject(error);
	};


	/**
	 * Бросаем событие с ожиданием Promise,
	 * для вызова UI (диалогов, форм) в процессе выполнения действия.
	 * @param  {string}  type
	 * @param  {*}       [args]
	 * @return {Promise}
	 */
	Action.waitFor = function waitFor(type, args) {
		var evt = new Emitter.Event(type),
			promise;

		// защищаемся от кривого аргумента; не меняем аргументы; первым параметром - текущий экземпляр Action
		Action.trigger(evt, [].concat(this, args));

		/* jshint eqnull:true */
		if (evt.result != null) {
			if (evt.result.then) { // если приехал Promise (или что то похожее) - возвращаем его
				promise = evt.result;
			} else {
				promise = Promise.cast(evt.result);
			}
		}
		else { // если нет - всё пропало, отказать!
			promise = Promise.reject();
		}

		return promise;
	};


	// Export
	Action.version = '0.1.0';
	return Action;
});

define('RPCModel', [
	'RPC',
	'Model'
], function (
	/** RPC */RPC,
	/** Model */Model
) {
	"use strict";

	/**
	 * Класс модели работающей через RPC
	 * @class RPCModel
	 * @constructs RPCModel
	 * @extends Model
	 */
	var RPCModel = Model.extend(/** @lends RPCModel.prototype */{
		/**
		 * Транспорт
		 * @type {RPC}
		 */
		request: RPC
	});


	// Export
	return RPCModel;
});

define('Storage', [
	'jquery',
	'inherit',
	'Promise',
	'RPC'
], function (
	/** function */$,
	/** function */inherit,
	/** Promise */Promise,
	/** RPC */RPC
) {
	"use strict";

	/**
	 * Ссылка на localStorage
	 * @type {localStorage}
	 */
	var localStorage;


	try {
		/** @namespace window.localStorage */
		localStorage = window.localStorage;
	} catch (err) {}



	/**
	 * Абстрактное хранилище данных
	 * @class Storage
	 * @constructs Storage
	 */
	var Storage = inherit(/** @lends Storage# */{
		/**
		 * Статус хранилища
		 * @type {boolean}
		 */
		disabled: false,


		/**
		 * @param  {string}  name  название хранилища
		 * @param  {string}  [idAttr] названия свойства (PK)
		 * @constructor
		 */
		constructor: function (name, idAttr) {
			this.name = name;
			this.idAttr = idAttr || 'id';

			$(window).bind('beforeunload', this._store.bind(this));
		},

		/**
		 * Инициализация хранилилища данных и индексов
		 * @private
		 */
		_initStorage: function () {
			if (this._data === void 0) {
				this.clear();
				this._restore();
			}
		},

		/**
		 * Сформировать ключ для хранения данных
		 * @param   {string}  type
		 * @param   {*}       value
		 * @returns {string}
		 * @private
		 */
		_key: function (type, value) {
			return type + ':' + (typeof value === 'string' ? /* istanbul ignore next */ value : JSON.stringify(value));
		},


		/**
		 * Добавить данные в index
		 * @param  {string}  key
		 * @param  {*}  data
		 * @private
		 */
		_addToIndex: function (key, data) {
			var id = data[this.idAttr],
				idx = this._index[id]
			;

			/* istanbul ignore else */
			if (idx === void 0) {
				idx = this._index[id] = {};
			}

			idx[key] = true;
		},


		/**
		 * Востановить данные
		 * @returns  {Object}
		 * @protected
		 */
		_restore: function () {
			return {};
		},


		/**
		 * Сохранить данные
		 * @protected
		 */
		_store: function () {
		},


		/**
		 * Получить данные из хранилища
		 * @param   {string}  type
		 * @param   {*}       query
		 * @returns {Promise}
		 */
		fetch: function (type, query) {
			this._initStorage();

			var value = this._data[this._key(type, query)];
			return Promise[this.disabled || value === void 0 ? 'reject' : 'resolve'](value);
		},


		/**
		 * Поиск массива данных по запросу
		 * @param   {*}  query
		 * @returns {Promise}
		 */
		find: function (query) {
			return this.fetch('find', query);
		},


		/**
		 * Поиск данных по запросу
		 * @param   {*}  query
		 * @returns {Promise}
		 */
		findOne: function (query) {
			return this.fetch('findOne', query).then(function (array) {
				return array[0];
			});
		},


		/**
		 * Сохранение данных
		 * @param   {string}  type
		 * @param   {*}       query
		 * @param   {*}       array
		 */
		save: function (type, query, array) {
			/* istanbul ignore next */
			if (!this.disabled) {
				var key = this._key(type, query), i;

				this._initStorage();

				// Сохраняем данные (всегда массив, чтобы дальше не думалось)
				this._data[key] = (array = [].concat(array));

				// Добавляем в индекс
				i = array.length;
				while (i--) {
					this._addToIndex(key, array[i]);
				}
			}
		},


		/**
		 * Обновить данные
		 * @param  {Object}  data
		 */
		update: function (data) {
			// Пока просто удаляем связанные данные
			this.remove(data[this.idAttr]);
		},


		/**
		 * Удалить связанные по идентификатору
		 * @param  {number|string}  id
		 */
		remove: function (id) {
			this._initStorage();

			var idx = this._index[id], key;

			/* istanbul ignore next */
			if (idx) {
				for (key in idx) {
					delete this._data[key];
				}

				delete this._index[id];
			}
		},


		/**
		 * Предустановить данные
		 * @param  {Array}  array
		 * @param  {Object} [query]
		 */
		setData: function (array, query) {
			this.save('find', query || {}, array);
		},


		/**
		 * Отчистить хранилище
		 */
		clear: function () {
			this._data = {};
			this._index = {};
		}
	});



	/**
	 * Хранилище на основе localStorage
	 * @class Storage.Local
	 * @memberOf Storage
	 * @extends Storage
	 */
	Storage.Local = Storage.extend(/** @lends Storage.Local# */{

		_restore: function () {
			try {
				var value = localStorage.getItem(this.name + '|' + RPC.setup().email);
				/* istanbul ignore else */
				if (value) {
					this._data = JSON.parse(value);
				}
			} catch (err) {
				// todo: Нужен логгер
			}
		},

		_store: function () {
			try {
				localStorage.setItem(this.name + '|' + RPC.setup().email, JSON.stringify(this._data));
			} catch (err) {
				// todo: Нужен логгер
			}
		}
	});


	// Export
	Storage.version = '0.1.2';
	return Storage;
});

define('mail/Folder', [
	'utils/util',
	'RPCModel',
	'Storage',
	'Promise'
], function (
	/** util **/util,
	/** RPCModel **/RPCModel,
	/** Storage **/Storage,
	/** Promise **/Promise
) {
	'use strict';

	// @todo: RPC.serialize
	var _serialize = JSON.stringify;


	/**
	 * Папка писем
	 * @class mail.Folder
	 * @constructs mail.Folder
	 * @extends RPCModel
	 */
	var Folder = RPCModel.extend(/** @lends mail.Folder# */{
		className: 'mail.Folder',

		/**
		 * @type {Storage}
		 */
		storage: new Storage('mail.folders'),

		findUrl: 'folders',
		addUrl: 'folders/add',
		saveUrl: 'folders/edit',
		removeUrl: 'folders/remove',
		openUrl: 'folders/open',
		closeUrl: 'folders/close',
		clearUrl: 'folders/clear',

		/**
		 * @see http://api.tornado.dev.mail.ru/folders/
		 * @type {Object}
		 */
		defaults: {
			id: null,
			system: false,
			type: '',
			name: '',
			parent: -1,
			open: true,
			security: false,
			messages_total: 0,
			messages_unread: 0,
			child: false,
			children: false,
			archive: false
		},

		/**
		 * Краткие ссылки для удобного доступа к свойствам
		 */
		shortcuts: {
			'unread': 'messages_unread',
			'messages': 'messages_total'
		},

		/**
		 * Находится ли папка на корневом уровне
		 * @returns {boolean}
		 */
		isRoot: function () {
			return this.get('parent') == -1;
		},

		/**
		 * Является ли папка дочерней (находится не на корневом уровне)
		 * @returns {boolean}
		 */
		isSubfolder: function () {
			return !this.isRoot();
		},

		/**
		 * Является ли папка родительской для других папок
		 * @returns {boolean}
		 */
		isParent: function () {
			return this.is('children');
		},

		/**
		 * Пустая ли папка
		 * @returns {boolean}
		 */
		isEmpty: function () {
			return !this.get('messages');
		},

		/**
		 * Защищена ли папка паролем
		 * @returns {boolean}
		 */
		isSecure: function () {
			return this.is('security');
		},

		/**
		 * Открыта ли папка защищённая паролем в текущей сессии.
		 * Для не защищённых паролем папок всегда возвращает true.
		 * @returns {boolean}
		 */
		isSecureOpen: function () {
			return this.is('open');
		},

		/**
		 * Является ли папка системной
		 * @returns {boolean}
		 */
		isSystem: function () {
			return this.is('system');
		},

		/**
		 * Является ли папка архивной
		 * @returns {boolean}
		 */
		isArchive: function () {
			return this.is('archive');
		},

		/**
		 * Можно ли пользователю удалить папку.
		 * @returns {boolean}
		 */
		isRemovable: function () {
			return (!this.isSystem() || this.get('type') == Folder.TYPE_ARCHIVE) && !this.isParent();
		},

		/**
		 * Папка "Входящие" (включая вложенные)
		 * @returns {boolean}
		 */
		isInbox: function () {
			return this.get('type') == Folder.TYPE_INBOX;
		},

		/**
		 * Папка "Отправленные"
		 * @returns {boolean}
		 */
		isSent: function () {
			return this.get('type') == Folder.TYPE_SENT;
		},

		/**
		 * Папка "Черновики" (включая вложенные и "Шаблоны")
		 * @returns {boolean}
		 */
		isDrafts: function () {
			// Шаблоны это тоже самое что и черновики
			// @TODO выяснить за каким лешим тогда нам метод isTemplates
			return this.get('type') == Folder.TYPE_DRAFTS || this.get('type') == Folder.TYPE_TEMPLATES;
		},

		/**
		 * Папка "Спам"
		 * @returns {boolean}
		 */
		isSpam: function () {
			return this.get('type') == Folder.TYPE_SPAM;
		},

		/**
		 * Папка "Корзина"
		 * @returns {boolean}
		 */
		isTrash: function () {
			return this.get('type') == Folder.TYPE_TRASH;
		},

		/**
		 * Папка "Шаблоны"
		 * @returns {boolean}
		 */
		isTemplates: function () {
			return this.get('type') == Folder.TYPE_TEMPLATES;
		},

		/**
		 * Пользовательские папки (созданные пользователями и не находящиеся внутри системных папок)
		 * @returns {boolean}
		 */
		isUser: function () {
			return this.get('type') == Folder.TYPE_USER;
		},

		/**
		 * Папки, созданные утилитой "Разбери ящик"
		 * @returns {boolean}
		 */
		isSorted: function () {
			var type = this.get('type');
			return type === Folder.TYPE_SOCIAL || type === Folder.TYPE_PROMOTIONS || type === Folder.TYPE_NEWSLETTERS;
		},

		/**
		 * Если start = true, копирует значения свойств в временную переменную,
		 * что даёт возможность "откатить" изменения позже.
		 * @param {boolean} start
		 * @returns {mail.Folder}
		 * @deprecated
		 */
		transaction: function (start) {
			if (start) {
				this.__copy = this.toJSON();
			} else {
				delete this.__copy;
			}

			return this;
		},

		/**
		 * "Откатывает" значения свойств сохранённые после вызова функции transaction().
		 * @returns {mail.Folder}
		 * @deprecated
		 */
		rollback: function () {
			if (this.__copy) {
				this.set(this.__copy);
			}

			return this.transaction(false);
		},

		/**
		 * @see Model#prepareSendData
		 * @param {string} method
		 * @param {Object} attrs
		 * @returns {Object}
		 */
		prepareSendData: function (method, attrs) {
			if (method == 'remove') {
				attrs = {
					ids: _serialize([attrs.id]),
					ajax_call: 1,
					api: 1
				};
			} else {
				attrs = {folders: _serialize([attrs])};
			}

			return attrs;
		},

		/**
		 * @see Model#parse
		 * @param {Object} body
		 * @param {Request} req
		 * @returns {*}
		 */
		parse: function (body, req) {
			if (/folders\/(edit|add)/.test(req.url) && body.length) {
				body = {id: body[0]};
			}

			if (/messages\/status/.test(req.url)) {
				body = body.folders;
			}

			return body;
		},


		/**
		 * Очищает папку (из корзины\спама удаляет письма, для остальных - перемещает в корзину)
		 * @returns {Promise}
		 */
		cleanup: function () {
			return this.queue(function (/** mail.Folder */model) {
				return model.request.post(model.constructor.url('clear'), {
					ids: _serialize([model.id])
				}).then(function () {
					return model.set({messages_unread: 0, messages_total: 0}, {clean: true});
				});
			});
		},

		/**
		 * Открыть закрытую папку по паролю
		 * @param {string} password
		 * @returns {Promise}
		 */
		secureOpen: function (password) {
			return this.queue(function (/** mail.Folder */model) {
				return model.request.post(model.constructor.url('open'), {
					folders: _serialize([{
						id: model.id,
						secret: {folder_password: (password + '').trim()}
					}])
				}).then(function () {
					return model.set('open', true, {clean: true});
				});
			});
		},

		/**
		 * Закрыть открытую запароленную папку
		 * @returns {Promise}
		 */
		secureClose: function () {
			return this.queue(function (/** mail.Folder */model) {
				return model.request.post(model.constructor.url('close'), {
					ids: _serialize([model.id])
				}).then(function () {
					return model.set('open', false, {clean: true});
				});
			});
		}
	});


	// Константы
	util.extend(Folder, /** @lends mail.Folder */{
		INBOX      : 0,
		SPAM       : 950,
		SENT       : 500000,
		DRAFTS     : 500001,
		TRASH      : 500002,
		MRIM       : 500003,
		MRIM_ARCH  : 500005,
		TEMPLATES  : 500006,
		ARCHIVE    : 500010,
		SOCIAL     : 500011,
		PROMOTIONS : 500012,
		NEWSLETTERS: 500013,

		TYPE_INBOX      : 'inbox',
		TYPE_SPAM       : 'spam',
		TYPE_SENT       : 'sent',
		TYPE_DRAFTS     : 'drafts',
		TYPE_TEMPLATES  : 'templates',
		TYPE_TRASH      : 'trash',
		TYPE_ARCHIVE    : 'archive',
		TYPE_USER       : 'user',
		TYPE_SOCIAL     : 'social',
		TYPE_PROMOTIONS : 'promotions',
		TYPE_NEWSLETTERS: 'newsletters',

		UNREAD    : 600006,
		FLAGGED   : 600007,
		ATTACH    : 600008,
		FILESEARCH: -2,

		/** @deprecated **/
		TYPES: {
			0     : 'Inbox',
			950   : 'Spam',
			500000: 'Sent',
			500001: 'Drafts',
			500002: 'Trash',
			500003: 'MRIM',
			500006: 'Templates',
			500010: 'Archive',
			USER  : 'user'
		}
	});


	/**
	 * Есть ли подпапки у любой папки в коллекции
	 * @memberof mail.Folder.List#
	 * @returns {boolean}
	 */
	Folder.List.fn.hasSubfolders = function () {
		var i = this.length;

		while (i--) {
			if (this[i].isSubfolder()) {
				return true;
			}
		}

		return false;
	};

	/**
	 * Найти все папки (загрузить если не загружены)
	 * @memberof mail.Folder
	 * @returns {Promise}
	 */
	Folder.unsafeFindAll = function () {

		return Folder.all.length ? Promise.resolve(Folder.all.clone()) : Folder.find();
	};

	// Export
	Folder.version = '0.2.0';
	return Folder;
});

define('mail/Message', [
	'RPCModel',
	'mail/Folder'
], function (
	/** RPCModel */RPCModel,
	/** mail.Folder */Folder
) {
	'use strict';


	/**
	 * Список полей, которые можно обновить
	 * @type {string}
	 */
	var whitelistForUpdate = ' folder next prev attaches subject snippet length_unread length_flagged ';



	/**
	 * Письмо
	 * @class mail.Message
	 * @constructs mail.Message
	 * @extends RPCModel
	 */
	var Message = RPCModel.extend(/** @lends mail.Message# */{
		/**
		 * Имя класса
		 * @type {string}
		 */
		className: 'mail.Message',


		/**
		 * URL получения списка писем
		 * @type {string}
		 */
		findUrl: 'messages/status',


		/**
		 * URL получения письма
		 * @type {string}
		 */
		findOneUrl: 'messages/message',


		/**
		 * URL для изменения флагов письма
		 * @type {string}
		 */
		markAsUrl: 'messages/marks',

		/**
		 * URL для изменения флагов всех писем в папке
		 * @type {string}
		 */
		markAsAllUrl: 'messages/marks/all',

		/**
		 * URL для перемещения писем
		 * @type {string}
		 */
		moveToUrl: 'messages/move',

		/**
		 * URL для перемещения всех писем в папке
		 * @type {string}
		 */
		moveToAllUrl: 'messages/move/all',

		/**
		 * URL для удаления писем
		 * @type {string}
		 */
		deleteUrl: 'messages/remove',

		/**
		 * URL для перемещения и пометки писем как спам
		 * @type {string}
		 */
		spamUrl: 'messages/services/spam',

		/**
		 * URL для снятия с писем пометки "спам"
		 * @type {string}
		 */
		unspamUrl: 'messages/services/unspam',

		/**
		 * @see http://api.tornado.dev.mail.ru/messages/message/
		 * @type {Object}
		 */
		defaults: {
			prev: null,
			next: null,
			subject: '',
			priority: 3,
			remind: 0,
			date: 0,
			size: 0,
			folder: Folder.INBOX,
			folders: [],
			rd_slot: '',
			snippet: '',

			body: {
				html: null,
				text: null
			},

			flags: {
				spf: true,
				dkim: true,
				unread: false,
				read_set: false,
				flagged: false,
				reply: false,
				forward: false,
				attach: false,
				safe: true,
				hide_fast_answers: false,
				receipt: false,
				blacklist_spam: false,
				probable_spam: false,
				dmarc_spf_pass: false,
				dmarc_fail: false,
				stored: false,
				rfc822: false,
				/**
				 * @todo figure out
				 */
				dont_cache: false
			},

			images: {
				exists: false,
				hidden: false,
				banned: false,
				attaches2cid: {}
			},

			drafts: {
				last_type: null,
				reply: '',
				replyall: '',
				forward: ''
			},

			/**
			 * @todo - convert to Attach collection
			 */
			attaches: {
				total: {
					href: '',
					name: ''
				},
				tnef: '',
				list: []
			},

			correspondents: {
				from: [],
				to: [],
				recipient: {
					avatars: {},
					email: '',
					name: ''
				},
				cc: [],
				bcc: []
			},

			replies: {
				to: [],
				all: [],
				cc: []
			},

			resend: {
				to: [],
				from: [],
				date: 0,
				comment: ''
			},

			templates: {
				replay: null,
				forward: null
			},

			collector: {
				id: '-1',
				type: ''
			},

			headers: {},

			parser_version: ''
		},

		/** @protected */
		parse: function (body) {
			return body.messages || body;
		},


		/** @protected */
		valueValidator: function (newValue, attr, newAttrs, model) {
			if (
				!model.attributes._load_by_message ||
				whitelistForUpdate.indexOf(' ' + attr + ' ') > -1 ||
				attr.indexOf('flags') === 0
			) {
				return newValue;
			} else {
				return model.get(attr);
			}
		},


		/**
		 * Проверка на загруженность письма
		 * @return {boolean}
		 */
		isDataFully: function () {
			return this.get('body.html') !== null;
		},


		/**
		 * Получить папку
		 * @return {mail.Folder}
		 */
		getFolder: function () {
			return Folder.getSafe(this.get('folder'));
		},


		/**
		 * Ниазкий приоритет?
		 * @return {boolean}
		 */
		isLow: function () {
			return Message.PRIORITY_LOW == this.get('priority');
		},


		/**
		 * Высокий приоритет?
		 * @return {boolean}
		 */
		isNormal: function () {
			return Message.PRIORITY_NORMAL == this.get('priority');
		},


		/**
		 * Нормальный приоритет?
		 * @return {boolean}
		 */
		isHigh: function () {
			return Message.PRIORITY_HIGH == this.get('priority');
		},


		/**
		 * Редактируемое-ли письмо?
		 * @return {boolean}
		 */
		isEditable: function () {
			return !/\d{20};\d;\d/.test(this.id);
		},


		/**
		 * Можно-ли отписаться от рассылки?
		 * @return {boolean}
		 */
		canListUnsubscribe: function () {
			return this.is('headers.List-Unsubscribe');
		}

	});


	/**
	 * Низкий приоритет письма
	 * @const
	 * @type {number}
	 * @memberOf mail.Message
	 */
	Message.PRIORITY_LOW = 5;


	/**
	 * Нормальный приоритет письма
	 * @const
	 * @type {number}
	 * @memberOf mail.Message
	 */
	Message.PRIORITY_NORMAL = 3;


	/**
	 * Высокий приоритет письма
	 * @const
	 * @type {number}
	 * @memberOf mail.Message
	 */
	Message.PRIORITY_HIGH = 1;


	// Export
	Message.version = '0.2.1';
	return Message;
});

define('mail/Thread', [
	'utils/util',
	'mail/Message'
], function (
	/** util */util,
	/** mail.Message */Message
) {
	'use strict';


	/**
	 * Цепочка писем / «Тред»
	 * @class mail.Thread
	 * @constructs mail.Thread
	 * @extends mail.Message
	 */
	var Thread = Message.extend(/** @lends mail.Thread# */{
		/**
		 * Имя класса
		 * @type {string}
		 */
		className: 'mail.Thread',


		/**
		 * URL получения списка писем
		 * @type {string}
		 */
		findUrl: 'threads',


		/**
		 * URL получения цепочки писем
		 * @type {string}
		 */
		findOneUrl: 'threads/thread',

		/**
		 * URL для изменения флагов цепочек писем
		 * @type {string}
		 */
		markAsUrl: 'threads/marks',

		/**
		 * URL для перемещения цепочек
		 * @type {string}
		 */
		moveToUrl: 'threads/move',

		/**
		 * URL для удаления цепочек
		 * @type {string}
		 */
		deleteUrl: 'threads/remove',

		/**
		 * URL для перемещения и пометки цепочек как спам
		 * @type {string}
		 */
		spamUrl: 'threads/services/spam',

		/**
		 * URL для снятия с цепочки пометки "спам"
		 * @type {string}
		 */
		unspamUrl: 'threads/services/unspam',

		/**
		 * @see http://api.tornado.dev.mail.ru/threads/thread/
		 * @type {Object}
		 */
		defaults: util.extend(Message.fn.defaults, {
			length_unread: 0,
			length_flagged: 0
		})

	});


	/**
	 * "id письма" => "id треда"
	 * @type {Object}
	 * @private
	 */
	var _byLetterIndex = {};


	/**
	 * Переиндексация поиска треда по id письма
	 * @param thread
	 * @private
	 */
	var _reindexByMessages = function (/** mail.Thread */thread) {
		var messages = thread.get('messages');

		/* istanbul ignore else */
		if (Array.isArray(messages)) {
			messages.forEach(function (/** Object */message) {
				_byLetterIndex[message.id] = thread;
			});
		}
	};


	Thread.all.on('add', function (evt, /** mail.Thread */thread) {
		thread.on('change:messages', function () {
			_reindexByMessages(thread);
		});

		_reindexByMessages(thread);
	});


	/**
	 * Получить тред по id письма
	 * @methodOf mail.Thread
	 * @param  {string} id
	 * @return {mail.Thread|undefined}
	 */
	Thread.getByMessageId = function (id) {
		return _byLetterIndex[id];
	};


	// Export
	Thread.version = '0.1.0';
	return Thread;
});

define('mail/actions/MarkAs', [
	'logger',
	'utils/util',
	'RPC',
	'Action',
	'mail/Folder',
	'mail/Message',
	'mail/Thread'
], function (
	/** logger */logger,
	/** util */util,
	/** RPC */RPC,
	/** Action */Action,
	/** mail.Folder */Folder,
	/** mail.Message */Message,
	/** mail.Thread */Thread
) {
	'use strict';


	/**
	 * Параметры при действие «Пометить как»
	 * @typedef   {Object}   MailMarkAs
	 * @property  {Model[]}  models список изменяемых моделей
	 * @property  {string}   flag   изменяемый флаг
	 * @property  {boolean}  state  стостояние флага
	 */


	/**
	 * Описание
	 * @class mail.MarkAs
	 * @constructs mail.MarkAs
	 * @extends Action
	 */
	var MarkAs = Action.extend(/** @lends mail.MarkAs# */{
		/**
		 * Список моделей
		 * @type {Model[]}
		 */
		models: [],


		/**
		 * @param  {MailMarkAs} params
		 * @return {Model.List}
		 */
		prepare: function (params) {
			var flag = params.flag,
				attr = 'flags.' + flag,
				attrLength = 'length_' + flag,
				state = !!params.state,
				models = params.models,
				counters = {}, // распределение по папкам
				prevAttrs = {},
				cleanTrue = {clean: true};

			/**
			 * Получить объект "свойство" => "зачение"
			 * @param {boolean} state
			 * @param {number} length
			 * @returns {Object}
			 * @private
			 */
			var _getAleterdAttrs = function (state, length) {
				var attrs = {};

				attrs[attr] = state;
				attrs[attrLength] = length;

				return attrs;
			};


			// Фильтруем коллекцию от моделей, которые не изменили своё состояние
			models = models.filter(function (/** Model */model) {
				/* istanbul ignore else */
				if (model.is(attr) != state) {
					var thread = Thread.getByMessageId(model.id),
						folderId = model.get('folder'),
						length = model.get(attrLength);

					// Группируем, чтобы изменить счетчики разом
					counters[folderId] = (counters[folderId] || 0) + (length || 1);

					// Запоминаем предыдущие состояния
					prevAttrs[model.id] = _getAleterdAttrs(!state, length);

					if (thread) {
						// Это письмо из треда, надо запомнить его состояние
						prevAttrs[thread.id] = _getAleterdAttrs(thread.get(attr), thread.get(attrLength));
					}
					else if (model instanceof Thread) {
						// Если это тред, то запоминаем состояния для вложенных в него писем
						model.get('messages').forEach(function (/** mail.Message */message) {
							// todo: Нужны вложенные модели
							message = Message.all.get(message.id);
							message && (prevAttrs[message.id] = _getAleterdAttrs(message.get(attr), 0));
						});
					}

					return true;
				}
			});

			// Сохраняем модели
			this.models = models;

			logger.add('prepare', {
				models: {
					before: params.models.length,
					after: models.length
				},
				counters: counters
			});


			/**
			 * Изменение состояния моделей
			 * @param {boolean} state
			 * @param {boolean} rollback
			 * @private
			 */
			var _applyChanges = function (state, rollback) {
				/* istanbul ignore else */
				if (flag == 'unread') {
					Object.keys(counters).forEach(function (/** number */folderId) {
						Folder.getSafe(folderId).increment('messages_unread', counters[folderId] * (state ? 1 : -1), cleanTrue);
					});
				}

				models.forEach(function (/** Model */model) {
					var thread = Thread.getByMessageId(model.id);

					model.set(rollback ? prevAttrs[model.id] : _getAleterdAttrs(state, +state), cleanTrue);

					if (thread) {
						if (rollback) {
							thread.set(prevAttrs[thread.id], cleanTrue);
						}
						else {
							// Меняем счетчик отвечающий за количество писем с нужным флагам
							thread.increment(attrLength, (state ? 1 : -1), cleanTrue);

							// Изменяем сам флаг, если `false`, то только если больше нет писем в треде с этим флагом
							thread.set(attr, (state ? true : thread.is(attrLength)), cleanTrue);
						}
					}
					else if (model instanceof Thread) {
						// Меняем состояние для внутренних писем
						model.get('messages').some(function (/** mail.Message */message) {
							// todo: Нужны вложенные модели
							message = Message.all.get(message.id);

							/* istanbul ignore else */
							if (message) {
								if (rollback) {
									message.set(prevAttrs[message.id], cleanTrue);
								}
								else if (state) {
									// Выставляем флаг только первому письму из папки в которой тред
									if (message.get('folder') == model.get('folder')) {
										message.set(attr, true, cleanTrue);
										return true; // выходим из `some`
									}
								}
								else {
									message.set(attr, false, cleanTrue);
								}
							}
						});
					}
				});
			};


			// Применяем изменения
			_applyChanges(state);


			// Определяем функцию отката изменений
			this.rollbackOperation = util.bindWithoutArgs(_applyChanges, [!state, true]);


			return models;
		},


		/**
		 * Логика действия «Пометить как..»
		 * @param  {Model.List}  models  список пимем/тредов
		 * @param  {MailMarkAs}  params  параметры
		 * @return {Promise}
		 * @protected
		 */
		operation: function (models, params) {
			return this._markAs(models, params.flag, params.state);
		},


		/**
		 * Обратная опереция действия «Пометить как..»
		 * @param  {Model.List}  models  список пимем/тредов
		 * @param  {MailMarkAs}  params  параметры
		 * @return {Promise}
		 * @protected
		 */
		undoOperation: function (models, params) {
			// Гатовим данные заного и заного изменяем счетчики
			models = this.prepare({
				flag: params.flag,
				state: !params.state,
				models: models
			});

			// todo: Надо думать о `rollback`
			return this._markAs(models, params.flag, !params.state);
		},


		/**
		 * «Пометить как...»
		 * @param  {Array}    models
		 * @param  {string}   flag
		 * @param  {boolean}  state
		 * @return {Promise}
		 * @private
		 */
		_markAs: function (models, flag, state) {
			var act = { name: flag };

			// todo: Возможно это не лучшее решение
			act[state ? 'set' : 'unset'] = Thread.List.fn.pluck.call(models, 'id');

			return models.length && RPC.call(models[0].markAsUrl, {marks: JSON.stringify([act])});
		}
	});


	// Региструем Действие
	Action.register('mail.MarkAs', MarkAs);


	// Export
	MarkAs.version = '0.1.0';
	return MarkAs;
});

define('mail/actions/MoveTo', [
	'logger',
	'utils/util',
	'RPC',
	'Promise',
	'Action',
	'mail/Folder',
	'mail/Message',
	'mail/Thread'
], function (
	/** logger */logger,
	/** util */util,
	/** RPC */RPC,
	/** Promise */Promise,
	/** Action */Action,
	/** mail.Folder */Folder,
	/** mail.Message */Message,
	/** mail.Thread */Thread
) {
	'use strict';

	/**
	 * Параметры при действии "Переместить в"
	 * @typedef   {Object}	MoveToParams
	 * @property  {Model[]}	models	список изменяемых моделей
	 * @property  {number}	targetFolder	id целевой папки для перемещения
	 */

	/**
	 * Описание
	 * @class mail.MoveTo
	 * @constructs mail.MoveTo
	 * @extends Action
	 */
	var MoveTo = Action.extend(/** @lends mail.MoveTo# */{
		/**
		 * Список моделей, которые аффектом
		 * @type {Model[]}
		 */
		models: [],

		/**
		 * Папка «откуда»
		 * @type {mail.Folder}
		 */
		folderTo: null,

		/**
		 * Папка «куда»
		 * @type {mail.Folder}
		 */
		folderFrom: null,

		/**
		 * Получить список моделей папок с запросом доступа
		 * @param   {Array}  ids
		 * @returns {Promise}
		 * @protected
		 */
		_findFolders: function (ids) {
			var queue = Promise.resolve(),
				folders = [];

			ids.forEach(function (id, i) {
				queue = queue.then(function () {
					return Folder.findOne(id).then(function (/** mail.Folder */folder) {
						// Проверяем доступ к папки и если что, запрашиваем доступ
						if (folder.isSecureOpen()) {
							folders[i] = folder;
						}
						else {
							return Action.waitFor('folderSecure', [folder]).then(function () {
								folders[i] = folder;
							});
						}
					});
				});
			});

			return queue.then(function () { return folders; });
		},


		/**
		 * @param  {MoveToParams} params
		 * @return {Model.List}
		 */
		prepare: function (params) {
			var folderTo = params.folderTo,
				models = (params.models || []).filter(function (model) {
					return model.get('folder') != folderTo;
				});

			if (models.length === 0) {
				return null; // exit(0);
			}


			/**
			 * id модели (письма/треда) => папка
			 * @type {Object}
			 * @private
			 */
			this._rollbackFolders = {};


			// Запрашиваем папку
			return this._findFolders([folderTo]).then(function (folders) {
				this.models = models;
				this.folderTo = folders[0];

				return models;
			}.bind(this));
		},

		/**
		 * Логика действия «Переместить в..»
		 * @param  {mail.Message[]|mail.Thread[]} models
		 * @param  {MoveToParams} params
		 * @return {Promise}
		 * @protected
		 */
		operation: function (models, params) {
			this._applyChanges(models, params.folderTo);

			return this._moveTo(models, params.folderTo);
		},


		/**
		 * Обратная операция действия «Переместить в..»
		 * @param  {mail.Message[]|mail.Thread[]} models
		 * @return {Promise}
		 * @protected
		 */
		undoOperation: function (models) {
			var toFolders = {};

			// Откатываем изменения счетчиков и id папки (!)
			this.rollbackOperation();

			// Собираем всем модели по группам
			models.forEach(function (model) {
				// id папки мы уже вернули, осталось только сложить всё в массив
				var folderId = model.get('folder');

				if (toFolders[folderId] === void 0) {
					toFolders[folderId] = [];
				}

				toFolders[folderId].push(model);
			});

			// А теперь сохраняем изменения
			return Promise.all(Object.keys(toFolders).map(function (folderTo) {
				return this._moveTo(toFolders[folderTo], folderTo, true);
			}, this));
		},


		/**
		 * Применить изменения к моделям и папкам
		 * @param {mail.Message[]|mail.Thread[]} models
		 * @param {number}  folderTo
		 * @param {boolean} [rollback]
		 * @protected
		 */
		_applyChanges: function (models, folderTo, rollback) {
			var	idx = models.length,
				cleanTrue = {clean: true},
				folderChanges = {},
				rollbackFolders = this._rollbackFolders,
				folderFrom,
				messages,
				model;

			// Сохранение "id папки" => "счетчик"
			function changeCounters(id, inc, unread) {
				if (folderChanges[id] === void 0) {
					folderChanges[id] = {
						total: 0,
						unread: 0
					};
				}

				folderChanges[id].total += inc;
				folderChanges[id].unread += inc * unread;
			}

			// Перенос модели «откуда -> куда»
			function moveTo(fromId, toId, model) {
				var unread = model.is('flags.unread');

				model.set('folder', toId, cleanTrue);
				!rollback && (rollbackFolders[model.id] = fromId);

				changeCounters(toId, +1, unread);
				changeCounters(fromId, -1, unread);
			}


			// Обработка моделей (вместе c волженными)
			while (idx--) {
				model = models[idx];
				folderFrom = model.get('folder');

				if (rollback) {
					folderTo = rollbackFolders[model.id];
				}

				if (model instanceof Thread) {
					model.set('folder', folderTo, cleanTrue);
					// todo: вложенные модели! Как сделаем, нужно убрать `Message.all.set`
					messages = model.get('messages');

					!rollback && (rollbackFolders[model.id] = folderFrom);

					/* jshint loopfunc:true */
					Message.all.set(messages, {clone: true}).forEach(function (message, i) {
						if ((!rollback && message.get('folder') === folderFrom) || rollbackFolders[message.id]) {
							messages[i].folder = folderTo; // todo: Вложенные!
							moveTo(folderFrom, folderTo, message);
						}
					});
				} else {
					moveTo(folderFrom, folderTo, model);
				}
			}


			this._applyChangesFolder(folderChanges, rollback);


			// Операция отката в случае ошибки
			this.rollbackOperation = util.bindWithoutArgs(this._applyChanges, [models, folderTo, true]);
		},


		/**
		 * @param {Object}  changes
		 * @param {boolean} rollback
		 * @protected
		 */
		_applyChangesFolder: function (changes, rollback) {
			// Изменяем счетчики (разом)
			Object.keys(changes).forEach(function (id) {
				var folder = Folder.get(id),
					conuters = changes[id];

				/* istanbul ignore else */
				if (folder) {
					folder.increment('messages_unread', conuters.unread, {clean: true});
					folder.increment('messages_total', conuters.total, {clean: true});
				}
			});
		},


		/**
		 * @param {Model[]}  models
		 * @param {number}   folderId
		 * @param {boolean}  [undo]
		 * @returns {Promise}
		 * @protected
		 */
		_moveTo: function (models, folderId, undo) {
			var Model = models[0].constructor;

			return RPC.call(Model.url('moveTo'), {
				ids: JSON.stringify(Model.List.fn.pluck.call(models, 'id')), // todo: fn.pluck может сделать их статическими? или в util?
				folder: folderId
			});
		}
	});


	// Региструем Действие
	Action.register('mail.MoveTo', MoveTo);


	// Export
	MoveTo.version = '0.1.0';
	return MoveTo;
});

define('mail/actions/Delete', [
	'RPC',
	'Action'
], function (
	/** RPC */RPC,
	/** Action */Action
	) {
	'use strict';

	/**
	 * Параметры при действии "Удаление"
	 * @typedef   {Object}	MailDeleteParams
	 * @property  {Model[]}	models	список удаляемых моделей
	 */


	/**
	 * Описание
	 * @class mail.Delete
	 * @constructs mail.Delete
	 * @extends Action
	 */
	var Delete = Action.extend(/** @lends mail.Delete# */{
		/**
		 * Список моделей
		 * @type {Model[]}
		 * @public
		 */
		models: [],

		/**
		 * @param  {MailDeleteParams} params
		 * @return {Model.List}
		 */
		prepare: function (params) {
			var models = params.models || [];

			this.models = models;

			return models.length ? models : null;
		},


		/**
		 * Логика действия «Удалить»
		 * @param  {Model.List} models
		 * @return {Promise}
		 * @protected
		 */
		operation: function (models) {
			var Model = models[0].constructor;

			return RPC.call(Model.url('delete'), {
				ids: JSON.stringify(Model.List.fn.pluck.call(models, 'id'))
			}).then(function () {
				models.destroy();
			});
		}
	});


	// Региструем Действие
	Action.register('mail.Delete', Delete);


	// Export
	Delete.version = '0.1.0';
	return Delete;
});

define('Pilot/src/match',[], function () {
	// Export
	return {
		cast: function (list) {
			var matches = {},
				match = list;

			if (typeof list !== 'function') {
				if (list === true || list === void 0) {
					match = function () {
						return true;
					};
				}
				else {
					list.forEach(function (key) {
						matches[key] = true;
					});

					match = function (key) {
						return matches[key];
					};
				}
			}

			return match;
		}
	};
});

define('Pilot/src/loader',['./match'], function (match) {
	'use strict';


	var _cast = function (name, model) {
		if (typeof model === 'function') {
			model = { fetch: model };
		}

		model.name = name;
		model.match = match.cast(model.match);

		return model;
	};



	/**
	 * @class Pilot.Loader
	 * @constructs Pilot.Loader
	 * @param {Object} models
	 * @constructor
	 */
	var Loader = function (models) {
		this.models = models = (models || {});
		this.names = Object.keys(models);

		this._index = {};
		this.names.forEach(function (name) {
			this._index[name] = _cast(name, models[name]);
		}, this);
	};


	Loader.prototype = /** @lends Pilot.Loader# */{
		consturctor: Loader,


		defaults: function () {
			var defaults = {};

			this.names.forEach(function (name) {
				defaults[name] = this._index[name].defaults;
			}, this);

			return defaults;
		},


		fetch: function (req) {
			var _index = this._index,

				names = this.names,
				models = {},
				promises = [],

				waitFor = function (name) {
					var idx = models[name],
						model = _index[name];

					if (idx === void 0) {
						idx = new Promise(function (resolve) {
							if (model.fetch && model.match(req.route.id, req)) {
								resolve(model.fetch(req, waitFor));
							}
							else {
								resolve(model.defaults);
							}
						});

						idx = promises.push(idx) - 1;
						models[name] = idx;
					}

					return promises[idx];
				};

			// Загружаем все модели
			names.forEach(waitFor);

			return Promise.all(promises).then(function (results) {
				names.forEach(function (name) {
					models[name] = results[models[name]];
				});

				return models;
			});
		},


		extend: function (models) {
			models = models || {};

			this.names.forEach(function (name) {
				models[name] = models[name] || this.models[name];
			}, this);

			return new Loader(models);
		},


		/**
		 * Достаем только принадлежание лоудеру свойства
		 * @param   {Object}  model
		 * @returns {Object}
		 */
		extract: function (model) {
			var data = {};

			this.names.forEach(function (name) {
				data[name] = model[name];
			});

			return data;
		}
	};


	// Export
	return Loader;
});

define('Pilot/src/querystring',[], function () {
	'use strict';

	var encodeURIComponent = window.encodeURIComponent;
	var decodeURIComponent = window.decodeURIComponent;


	function _stringifyParam(key, val, indexes) {
		/* jshint eqnull:true */
		if (val == null || val === '' || typeof val !== 'object') {
			return encodeURIComponent(key) +
				(indexes ? '[' + indexes.join('][') + ']' : '') +
				(val == null || val === '' ? '' : '=' + encodeURIComponent(val));
		}
		else {
			var pairs = [];

			for (var i in val) {
				if (val.hasOwnProperty(i)) {
					pairs.push(_stringifyParam(key, val[i], (indexes || []).concat(i >= 0 ? '' : encodeURIComponent(i))));
				}
			}

			return pairs.join('&');
		}
	}



	/**
	 * @module queryString
	 */
	var queryString = /** @lends queryString */{
		/**
		 * Parse query string
		 * @param   {string} search
		 * @returns {Object}
		 */
		parse: function (search) {
			var query = {};

			if (typeof search === 'string') {
				if (/^[?#]/.test(search)) {
					search = search.substr(1);
				}

				var pairs = search.trim().split('&'),
					i = 0,
					n = pairs.length,
					pair,
					name,
					val;

				for (; i < n; i++) {
					pair = pairs[i].split('=');
					name = pair.shift().replace('[]', '');
					val = pair.join('=');

					if (val === void 0){
						val = '';
					}
					else {
						try {
							val = decodeURIComponent(val);
						}
						catch (err) {
							val = unescape(val);
						}
					}

					if (name) {


						if (query[name] === void 0) {
							query[name] = val;
						}
						else if (query[name] instanceof Array) {
							query[name].push(val);
						}
						else {
							query[name] = [query[name], val];
						}
					}
				}
			}

			return query;
		},


		/**
		 * Stringify query object
		 * @param   {Object}  query
		 * @returns {string}
		 */
		stringify: function (query) {
			var str = [], key, val;

			if (query && query instanceof Object) {
				for (key in query) {
					if (query.hasOwnProperty(key)) {
						str.push(_stringifyParam(key, query[key]));
					}
				}
			}

			return str.join('&');
		}
	};


	// Export
	return queryString;
});

define('Pilot/src/request',['Pilot/src/querystring'], function (/** queryString */queryString) {
	var URL = window.URL;


	/**
	 * @class  Pilot.Request
	 * @constructs Pilot.Request
	 * @param  {string}  url
	 * @param  {string}  [referrer]
	 * @param  {Pilot}   [router]
	 */
	var Request = function (url, referrer, router) {
		url = new URL(url);

		this.href = url.href;
		this.protocol = url.protocol;
		this.host = url.host;
		this.hostname = url.hostname;
		this.port = url.port;

		this.path =
		this.pathname = url.pathname;

		this.search = url.search;
		this.query = queryString.parse(url.search);
		this.params = {};

		this.hash = url.hash;

		this.route = router && router.route || {};
		this.router = router;
		this.referrer = referrer;
	};


	Request.prototype = /** @lends Request# */{
		constructor: Request,

		clone: function () {
			var req = new Request(this.href, this.referrer, this.router);

			req.query = this.query;
			req.params = this.params;

			return req;
		},

		is: function (id) {
			return !!(this.router.route && (this.router.route.id == id));
		},

		toString: function () {
			return this.href;
		}
	};


	// Export
	return Request;
});

/**
 * URL module
 * Base on http://jsperf.com/url-parsing/26
 */

define('Pilot/src/url',['Pilot/src/querystring'], function (/** queryString */queryString) {
	'use strict';

	var parseQueryString = queryString.parse;
	var stringifyQueryString = queryString.stringify;
	var encodeURIComponent = window.encodeURIComponent;


	/**
	 * URL Parser
	 * @type {RegExp}
	 * @const
	 */
	var R_URL_PARSER = /^(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/;


	/**
	 * Protocol checker
	 * @type {RegExp}
	 * @const
	 */
	var R_PROTOCOL = /^[a-z]+:/;


	/**
	 * Protocol separator
	 * @type {string}
	 * @const
	 */
	var DOUBLE_SLASH = '//';


	/**
	 * @class Url
	 * @constructs Url
	 * @param {string}  url
	 * @param {string|Url|location}  [base]
	 */
	function Url(url, base) {
		if (base === void 0) {
			base = location;
		} else if (typeof base === 'string') {
			base = new Url(base);
		}


		/* jshint eqnull:true */
		if (url == null) {
			url = base.toString();
		}
		else  if (!R_PROTOCOL.test(url)) {
			var protocol = base.protocol,
				hostname = base.hostname,
				pathname = base.pathname;

			if (url.charAt(0) === '#') {
				url = base.toString().split('#')[0] + url;
			}
			else if (url.substr(0, 2) === DOUBLE_SLASH) {
				// without protocol
				url = protocol + url;
			}
			else  if (url.charAt(0) === '/') {
				// absolute path
				url = protocol + DOUBLE_SLASH + hostname + url;
			}
			else {
				// relative path
				url = protocol + DOUBLE_SLASH + hostname + pathname.substr(0, pathname.lastIndexOf('/') + 1) + url;
			}
		}

		// todo: support punycode
		var matches = R_URL_PARSER.exec(url);

		this.protocol = matches[4] || '';
		this.protocolSeparator = matches[5] || '';

		this.credhost = matches[6] || '';
		this.cred = matches[7] || '';

		this.username = matches[8] || '';
		this.password = matches[9] || '';

		this.host = matches[10] || '';
		this.hostname = matches[11] || '';
		this.port = matches[12] || '';
		this.origin = this.protocol + this.protocolSeparator + this.hostname;

		this.path =
		this.pathname = matches[13] || '/';

		this.segment1 = matches[14] || '';
		this.segment2 = matches[15] || '';

		this.search = matches[16] || '';
		this.query = parseQueryString(this.search);
		this.params = {};

		this.hash = matches[17] || '';

		this.update();
	}


	Url.fn = Url.prototype = /** @lends Url# */{
		constructor: Url,

		/**
		 * Set query params
		 * @param   {object}       query
		 * @param   {string|array} [remove]   if `true`, clear the current `query` and set new
		 * @returns {Url}
		 */
		setQuery: function (query, remove) {
			var query = this.query,
				key;

			query = parseQueryString(query);

			if (remove === true) {
				this.query = query;
			}
			else {
				if (query !== void 0) {
					for (key in query) {
						if (query[key] === null) {
							delete query[key];
						} else {
							query[key] = query[key];
						}
					}
				}

				if (remove) {
					if (typeof remove === 'string') {
						remove = remove.split('&');
					}

					remove.forEach(function (name) {
						delete query[name];
					});
				}
			}

			return this.update();
		},


		/**
		 * Add query params
		 * @param   {object} query
		 * @returns {Url}
		 */
		addQuery: function (query) {
			return this.setQuery(query);
		},


		/**
		 * Remove query params
		 * @param   {string|array}  query
		 * @returns {Url}
		 */
		removeQuery: function (query) {
			return this.setQuery(void 0, query);
		},


		/** @returns {Url} */
		update: function () {
			this.url = this.href = (
				this.protocol + this.protocolSeparator +
				(this.username ? encodeURIComponent(this.username) + (this.password ? ':' + encodeURIComponent(this.password) : '') + '@' : '') +
				this.host + this.pathname + this.search + this.hash
			);

			return this;
		},


		toString: function () {
			return this.url;
		}
	};


	/**
	 * Parse URL
	 * @static
	 * @param   {string} url
	 * @returns {Url}
	 */
	Url.parse = function (url) {
		return new Url(url);
	};


	/**
	 * Parse query string
	 * @method  Url.parseQueryString
	 * @param   {string} str
	 * @returns {Object}
	 */
	Url.parseQueryString = queryString.parse;


	/**
	 * Stringify query object
	 * @method  Url.parseQueryString
	 * @param   {Object} query
	 * @returns {string}
	 */
	Url.stringifyQueryString = stringifyQueryString;


	/**
	 * Конвертация описания пути в регулярное выражение
	 * @param  {string|RegExp}  pattern
	 * @return {RegExp}
	 */
	Url.toMatcher = function (pattern) {
		// https://github.com/visionmedia/express/blob/master/lib/utils.js#L248
		if (pattern instanceof RegExp) {
			return pattern;
		}

		if (Array.isArray(pattern)) {
			pattern = '(' + pattern.join('|') + ')';
		}

		var keys = [];

		pattern = pattern
			.concat('/*')
			.replace(/\/+/g, '/')
			//.replace(/(\/\(|\(\/)/g, '(?:/')
			.replace(/\(([^\?])/g, '(?:$1')
			.replace(/(\/)?(\.)?:(\w+)(?:(\([^)]+\)))?(\?)?(\*)?/g, function(_, slash, format, key, capture, optional, star){
				keys.push({
					name: key,
					optional: !!optional
				});

				slash = slash || '';

				return '' +
					(optional ? '' : slash) +
					'(?:' +
					(optional ? slash : '') +
					(format || '') + (capture || (format && '([^/.]+)' || '([^/]+)')).replace('(?:', '(') + ')' +
					(optional || '') +
					(star ? '(/*)?' : '')
				;
			})
			.replace(/([\/.])/g, '\\$1')
		;

		pattern = new RegExp('^' + pattern + '$', 'i');
		pattern.keys = keys;

		return pattern;
	};


	/**
	 * Вытащить параметры из url
	 * @param   {string}      pattern
	 * @param   {string|Url}  [url]
	 * @returns {Object|null}
	 */
	Url.match = function (pattern, url) {
		var i, n,
			value,
			params = {},
			matches;

		url = Url.parse(url);
		pattern = Url.toMatcher(pattern);
		matches = pattern.exec(url.path);

		if (matches) {
			for (i = 1, n = matches.length; i < n; i++) {
				value = matches[i];

				if (value !== void 0) {
					params[pattern.keys[i - 1].name] = value;
				}
			}

			return params;
		}

		return null;
	};


	// Export
	return Url;
});

define('Pilot/src/route',[
	'Emitter',
	'Pilot/src/match',
	'Pilot/src/url',
	'Pilot/src/querystring'
], function (
	/** Emitter */Emitter,
	/** Object */match,
	/** URL */Url,
	/** queryString */queryString
) {
	'use strict';


	/**
	 * Обработка параметров url согласно правилам
	 * @param   {Object}        rules   правила
	 * @param   {Object}        target  объект обработки
	 * @param   {Pilot.Request} req     оригинальный запрос
	 * @returns {boolean}
	 * @private
	 */
	var _urlProcessing = function (rules, target, req) {
		return Object.keys(rules).every(function (name) {
			var rule = rules[name],
				value = target[name];

			if (value === void 0) {
				target[name] = rule['default'];
				return true;
			}

			target[name] = value = (rule.decode ? rule.decode(value, req) : value);

			return !rule.validate || rule.validate(value, req);
		});
	};


	/**
	 * Преобразование образца маршрута в функцию генерации URL
	 * @param  {string}  pattern
	 * @return {Function}
	 * @private
	 */
	var _toUrlBuilder = function (pattern) {
		var code = 'var url = "',
			i = 0,
			chr,
			expr;

		// Чистим образец
		pattern = pattern.replace(/([?*]|(\[.*?))/g, '');

		function parseGroupStatement(prefix) {
			var str = 'url += "';

			while (chr = pattern[i++]) {
				if (chr === ':') { // Переменная
					expr = pattern.substr(i).match(/[a-z0-9_-]+/)[0];
					str += '" + params["' + expr + '"] + "';
					i += expr.length;
				}
				else if (chr === ')' || chr === '|') { // Группа или её закрытие
					code += prefix + 'if (params["' + expr + '"]) {' + str + '";}\n';
					(chr === '|') && parseGroupStatement('else ');
					break;
				}
				else {
					str += chr;
				}
			}
		}

		// Main loop
		while (chr = pattern[i++]) {
			if (chr === ':') { // Переменная
				expr = pattern.substr(i).match(/[a-z0-9_-]+/)[0];
				code += '" + params["' + expr + '"] + "';
				i += expr.length
			}
			else if (chr === '(') { // Открытие группы
				code += '";\n';
				parseGroupStatement('');
				code += 'url += "';
			} else {
				code += chr;
			}
		}

		/* jshint evil:true */
		return new Function('params', code += '"; return url;');
	};


	/**
	 * @class Route
	 * @memberof Pilot
	 * @extends Emitter
	 * @constructs Pilot.Route
	 * @param  {Object}  options
	 * @param  {Pilot}   router
	 */
	var Route = function (options, router) {
		/**
		 * Описание URL
		 * @type {Object}
		 * @private
		 */
		this.url = {};

		/**
		 * Регионы
		 * @type {Array}
		 * @public
		 */
		this.regions = [];

		/**
		 * Ссылка на роутер
		 * @type {Pilot}
		 */
		this.router = router;

		// Инит опций и свойств по ним
		this._initOptions(options);

		/**
		 * Зазгрузчик моделей
		 * @type {Pilot.Loader}
		 * @private
		 */
		this.__model__ = options.model;

		/**
		 * Модели
		 * @type {Object}
		 * @public
		 */
		this.model = options.model.defaults();

		this.url.regexp = Url.toMatcher(this.url.pattern + (options.__group__ ? '/:any([a-z0-9\\/-]*)' : ''));
		this._urlBuilder = _toUrlBuilder(this.url.pattern);

		// Родительский маршрут (группа)
		this.parentRoute = this.router[this.parentId];

		this._initMixins()
	};


	Route.prototype = /** @lends Route# */{
		constructor: Route,

		/**
		 * Внутряняя инициализация маршрута
		 * @private
		 */
		__init: function () {
			this.inited = true;

			this.trigger('before-init', this);
			this.init();
			this.trigger('init', this);
		},

		/**
		 * Пользовательская инициализация маршрута
		 * @protected
		 */
		init: function () {
		},

		/**
		 * @param {Object} options
		 * @protected
		 */
		_initOptions: function (options) {
			var _this = this;

			_this.options = options;

			Object.keys(options).forEach(function (key) {
				var value = options[key],
					act = key.match(/^(one?)[:-](\w+)/);

				if (key === '*') { // Регионы
					Object.keys(value).map(function (name) {
						var region = new Route.Region(name, value[name], _this);

						_this.regions.push(region);
						_this.regions[name] = region;

						_this.on('model', function () {
							region.model = _this.model;
						});
					});
				}
				else if (act) {
					if (act[1]) { // Биндинг событий
						_this[act[1]](act[2].replace(/-/g, ''), function (evt, req) {
							// Передаем только `req`
							_this[key](req);
						});
					}
				}

				_this[key] = value;
			});
		},


		/**
		 * Подмешиваем
		 * @protected
		 */
		_initMixins: function () {
			Array.isArray(this.mixins) && this.mixins.forEach(function (mix) {
				Object.keys(mix).forEach(function (name) {
					if (name != 'apply') {
						this[name] = this[name] || mix[name];
					}
				}, this);

				mix.apply && mix.apply.call(this, this);
			}, this);
		},


		/**
		 * Обработка маршрута
		 * @param  {URL}     url
		 * @param  {Request} req
		 * @param  {Route}   currentRoute
		 * @param  {Object}  model
		 */
		handling: function (url, req, currentRoute, model) {
			// Либо это «мы», либо группа (только так, никаких множественных маршрутов)
			if ((this === currentRoute) || (this.__group__ && this.match(url, req))) {
				this.model = this.__model__.extract(model);
				this.params = req.params;
				this.request = req;

				this.trigger('model', [this.model, req]);

				if (!this.active) {
					this.active = true;

					// Внутренняя инициализация
					!this.inited && this.__init();

					this.trigger('route-start', req);
				}
				else {
					this.trigger('route-change', req);
				}

				this.trigger('route', req);

				// Обработка регионов
				this.regions.forEach(function (/** Route.Region */region) {
					if (this.active && region.match(currentRoute.id)) {
						if (!region.active) {
							region.active = true;

							!region.inited && region.__init();

							region.trigger('route-start', req);
						}

						region.trigger('route', req);
					}
					else if (region.active) {
						region.active = false;
						region.trigger('route-end', req);
					}
				}, this);
			}
			else if (this.active) {
				this.active = false;
				this.model = this.__model__.defaults();

				// Это не копипаст!
				this.regions.forEach(function (/** Route.Region */region) {
					if (region.active) {
						region.active = false;
						region.trigger('route-end', req);
					}
				});

				this.trigger('route-end', req);
			}
		},


		/**
		 * Проверка маршрута
		 * @param   {URL}  url
		 * @param   {Pilot.Request}  req
		 * @returns {boolean}
		 */
		match: function (url, req) {
			var params = Url.match(this.url.regexp, url.pathname),
				query = queryString.parse(url.query),
				_paramsRules = this.url.params,
				_queryRules = this.url.query;

			return (
				params &&
				(!_paramsRules || _urlProcessing(_paramsRules, req.params = params, req)) &&
				(!_queryRules || _urlProcessing(_queryRules, req.query = query, req))
			);
		},

		/**
		 * Получить данные
		 * @param   {Pilot.Request} req
		 * @returns {Promise}
		 */
		fetch: function (req) {
			return this.__model__.fetch(req);
		},

		/**
		 * Получить URL
		 * @param {Object} [params]
		 */
		getUrl: function (params) {
			return this.url.toUrl ? this.url.toUrl(params, this._urlBuilder) : this._urlBuilder(params);
		}
	};


	Emitter.apply(Route.prototype);


	/**
	 * Регион маршрута
	 * @class Route.Region
	 * @extends Route
	 * @memberof Pilot
	 * @constructs Pilot.Route.Region
	 */
	Route.Region = function (name, options, route) {
		this.name = name;
		this.router = route.router;
		this.parentRoute = route;

		this._initOptions(options);
		this._initMixins();

		this.match = match.cast(options.match);
	};


	// Наследуем `Route`
	Route.Region.prototype = Object.create(Route.prototype);
	Route.Region.prototype.constructor = Route.Region;
	Route.Region.prototype.getUrl = function (params) {
		return this.parentRoute.getUrl(params);
	};


	// Export
	return Route;
});

define('Pilot/src/status',[], function () {
	/**
	 * @class Pilot.Status
	 * @constructs  Pilot.Status
	 * @param  {number} code
	 * @param  {*} details
	 */
	var Status = function (code, details) {
		this.code = code;
		this.details = details;
	};


	Status.prototype = /** @lends Pilot.Status */{
		constructor: Status,

		toJSON: function () {
			return {code: this.code, details: this.details};
		}
	};


	/**
	 * Преобразовать в статус
	 * @methodOf Pilot.Status
	 * @param {*} value
	 * @return {Pilot.Status}
	 */
	Status.from = function (value) {
		if (value.status) {
			value = new Status(value.status, value);
		}
		else if (!value || !value.code) {
			value = new Status(500, value);
		}

		return value;
	};


	// Export
	return Status;
});

define('pilot',[
	'Emitter',
	'Pilot/src/match',
	'Pilot/src/loader',
	'Pilot/src/request',
	'Pilot/src/route',
	'Pilot/src/status'
], function (
	/** Emitter */Emitter,
	/** Object */match,
	/** Pilot.Loader */Loader,
	/** Pilot.Request */Request,
	/** Pilot.Route */Route,
	/** Pilot.Status */Status
) {
	'use strict';

	var URL = window.URL;
	var resolvedPromise = Promise.resolve();


	function _normalizeRouteUrl(url, relative) {
		relative = relative || {};

		if (!url) {
			url = relative.pattern;
		}

		if (typeof url === 'string') {
			url = { pattern: url };
		}

		if (url.pattern.charAt(0) !== '/') {
			url.pattern = (relative.pattern + '/' + url.pattern.replace(/(^\.\/|^\.$)/, ''));
		}

		url.pattern = url.pattern.replace(/\/+/g, '/');
		url.params = url.params || relative.params || {};
		url.query = url.query || relative.query || {};
		url.toUrl = url.toUrl || relative.toUrl;

		return url;
	}



	/**
	 * @class Pilot
	 * @param {Object} map крата маршрутов
	 */
	var Pilot = function (map) {
		var routes = [];

		map.url = map.url || '/';
		map.access = map.access || function () {
			return resolvedPromise;
		};

		// Подготавливаем данные
		(function _prepareRoute(map) {
			map.__group__ = false;

			Object.keys(map).forEach(function (key) {
				var options = map[key];

				if (key.charAt(0) === '#') {
					// Это маршрут, следовательно `map` — группа
					map.__group__ = true;
					delete map[key];

					options.id = key;
					options.parentId = map.id;

					options.url = _normalizeRouteUrl(options.url, map.url);
					options.model = map.model.extend(options.model);
					options.access = options.access || map.access;

					routes.push(options);
					_prepareRoute(options);
				}
			});
		})({'#__root__': map, model: new Loader(map.model) });


		this.model = map.model.defaults();
		this.__model__ = map.model;


		/**
		 * Текущий реквест
		 * @type {Pilot.Request}
		 */
		this.request = new Request('about:blank', '', this);


		/**
		 * Активный URL
		 * @type {URL}
		 */
		this.activeUrl = new URL('about:blank');


		/**
		 * Массив маршрутов
		 * @type {Pilot.Route[]}
		 */
		this.routes = routes.map(function (route) {
			route = new Route(route, this);

			this[route.id] = route;

			return route;
		}, this);
	};


	Pilot.prototype = /** @lends Pilot# */{
		constructor: Pilot,

		/**
		 * Получить URL по id
		 * @param  {string} id
		 * @param  {Object} [params]
		 */
		getUrl: function (id, params) {
			return this[id].getUrl(params);
		},


		/**
		 * Перейти по id
		 * @param  {string} id
		 * @param  {Object} [params]
		 * @return {Promise}
		 */
		go: function (id, params) {
			return this.nav(this[id].getUrl(params));
		},


		/**
		 * Навигация по маршруту
		 * @param   {string|URL|Pilot.Request}  href
		 * @returns {Promise}
		 */
		nav: function (href) {
			var req,
				url = new URL(href.toString(), location),
				_this = this,
				routes = _this.routes,
				_promise = _this._promise,
				currentRoute;

			// URL должен отличаться от активного
			if (_this.activeUrl.href !== url.href) {
				// Создаем объект реквеста и дальше с ним работаем
				req = new Request(url, _this.request.href, _this);

				// Находим нужный нам маршрут
				currentRoute = routes.filter(function (/** Pilot.Route */item) {
					return !item.__group__ && item.match(url, req);
				})[0];


				_this.activeUrl = url;
				_this.activeRequest = req;

				_this.trigger('before-route', [req]);


				if (!_this._promise) {
					_this._promise = _promise = new Promise(function (resolve, reject) {
						// Только в целях оптимизации стека
						_this._resolve = resolve;
						_this._reject = reject;
					});

					_promise['catch'](function (err) {
						if (currentRoute) {
							// todo: Найти ближайшую 404
							currentRoute.trigger(err.code + '', [err, req]);
							currentRoute.trigger('error', [err, req]);
						}

						_this.trigger('route-fail', [err, req]);
						_this.trigger('route-end', [req]);
					});
				}


				if (!currentRoute) {
					// Если маршрут не найден, кидаем ошибку
					_this._reject(new Status(404));
				}
				else {
					req.route = currentRoute;

					// Запрашиваем доступ к маршруту
					currentRoute.access(req).then(function () {
						// Доступ есть, теперь собираем данные для маршрута
						return currentRoute.fetch(req).then(function (/** Object */model) {
							if (_this.activeUrl === url) {
								_this.url = url;
								_this.referrer = _this.request.href;

								_this.model = _this.__model__.extract(model);
								_this.route = currentRoute;
								_this.request = req;

								// Обходим всем маршруты и тегерим события
								routes.forEach(function (/** Route */route) {
									route.handling(url, req.clone(), currentRoute, model);
								});

								_this.trigger('route', [req, currentRoute]);
								_this.trigger('route-end', [req, currentRoute]);

								_this._promise = null;
								_this._resolve();
							}
						});
					})['catch'](function (err) {
						// todo: Редирект!
						// Обработка ошибки
						if (_this.activeUrl === url) {
							_this._promise = null;
							_this._reject(Status.from(err));

							return Promise.reject(err);
						}
					});
				}
			}

			return _promise || resolvedPromise;
		}
	};


	/**
	 * Создать роутер
	 * @param  {Object}  sitemap
	 * @return {Pilot}
	 */
	Pilot.create = function (sitemap) {
		return new Pilot(sitemap);
	};


	Emitter.apply(Pilot.prototype);


	// Export
	Pilot.version = '2.0.0';
	return Pilot;
});

define('fest',[], function () {
	'use strict';

	var _queue = [];
	var _active = false;
	var _addQueue = function (model) {
		_queue.push(model);

		if (!_active) {
			_active = true;
			setTimeout(_processingQueue, 1);
		}
	};
	var _processingQueue = function () {
		_active = false;
		while (_queue.length) {
			_queue.shift().$apply();
		}
	};


	/**
	 * Пустышка для помощи в создании произвольного куска html
	 * @type HTMLDivElement
	 * @private
	 */
	var _fragment = document.createElement('div');


	/**
	 * Создание DOM-куска на основе произвольной html-строки
	 * @param  {string}  html
	 * @return {DocumentFragment}
	 */
	function _createFragment(html) {
		if (/^(<!--.*?-->)?<option/i.test(html)) {
			_fragment.innerHTML = '<select>' + html + '</select>';
			_fragment = _fragment.firstChild;
		}
		else if (/^(<!--.*?-->)?<tr/.test(html)) {
			_fragment.innerHTML = '<table><tbody>' + html + '</tbody></table>';
			_fragment = _fragment.firstChild.firstChild;
		}
		else {
			_fragment.innerHTML = html;
		}

		if (_fragment.childNodes.length > 1) {
			var realFragment = document.createDocumentFragment();
			while (_fragment.firstChild) {
				realFragment.appendChild(_fragment.firstChild);
			}
			return realFragment;
		}

		return _fragment.firstChild;
	}


	/**
	 * Список препроцессоров
	 * @type {Array}
	 * @private
	 */
	var _preprocessors = [];


	function templatePreprocessing(fnTpl) {
		var bindIdx = 0,
			template = fnTpl.toString(),
			r_opts,
			r_expr,
			r_expr_g;

		r_expr = _preprocessors.map(function (desc) {
			return desc.id;
		});

		r_opts = new RegExp('\\/\\*\\$OPTS:([^\\*]+)\\*\\/');

		r_expr = new RegExp('\\/\\*\\$(' + r_expr.join('|') + ')\\*\\/([\\\s\\S]*?)\\/\\*(\\1)\\$\\*\\/');
		r_expr_g = new RegExp(r_expr.source, 'g');

		template = template
			.replace(/(var __xid)/g, 'var __xb = [], __bid, __xid')
			.replace(/\/\*M\$\*\/([^<]*?)\/\*\$M\*\//g, '$1') // сливам все модификаторы в один
		;



		// Биндим события
		template = template.replace(/<[a-z][^>]+>/g, function (entry) {
			var events = [],
				__xb = '__xb[__bid]';

			entry = entry.replace(/\son-([a-z]+)(-outside)?=\\"(.*?)\\"/g, function (_, event, outside, expr) {
				events.push(
					'{name:"' + event + '",' +
					'outside:' + !!outside + ',' +
					'fn:function (evt, el) {return (' + expr.trim().replace(/;+$/, '') + ');}}'
				);

				return '';
			});

			if (events.length) {
				entry += '<!--e" + (__xb.push([' + events.join(',') + ']) - 1) + "-->';
			}

			return entry;
		});


		do {
			template = template.replace(r_expr_g, function (_, name, expr) {
				var __xb = '__xb[__bid]',
					code = [],
					pre = _preprocessors[name],
					opts;

				if (pre) {
					code.push(
						'__bid = __xb.push({ parent: __bid }) - 1;',
						//__xb + ' = {};',
						__xb + '.id = __bid;',
						__xb + '.name = "' + name + '";'
					);

					// Опции
					opts = expr.match(r_opts);
					if (opts) {
						expr = expr.replace(opts[0], '');
						code.push(__xb + '.opts = ' + opts[1] + ';');
					}

					// Экспортируем свойства
					pre.props && Object.keys(pre.props).forEach(function (key) {
						var idx = expr.indexOf('/*$*/'),
							incut = __xb + '.' + key + '=' + pre.props[key] + ';';

						if (idx > -1) {
							idx += 5;
							expr = expr.substr(0, idx) + incut + expr.substr(idx);
						}
						else {
							code.push(incut);
						}
					});

					// Рендер функция
					if (pre.render) {
						code.push(
							__xb + '.$render = function () { var __fest_buf = "";',
							(pre.expr ? pre.expr(expr) : expr),
							'return __fest_buf;};'
						);
					}

					// Функция тест
					if (pre.$test) {
						code.push(__xb + '.$test = ' + pre.$test.toString().replace('this.getter();', expr.split('/*$*/')[0]) + ';');
					}

					// Применение изменений
					if (pre.$apply) {
						code.push(__xb + '.$apply = ' + pre.$apply.toString().replace('this.getter();', expr.split('/*$*/')[0]) + ';');
					}

					// Биндинг через коментарий
					if (pre.attr) {
						code.push('__fest_buf +=  " ' + pre.attr + '=" + __bid;');
					}

					// Обертка коментариями
					if (pre.dom === 'wrap') {
						code.push(
							'__fest_buf += "<!--"+__bid+"-->";',
							expr,
							'__fest_buf += "<!--/"+__bid+"-->";'
						);
					}
					else if (pre.dom === 'link') {
						code.push('__fest_buf += "<!--l"+__bid+"-->";', expr);
					}
					else {
						code.push(expr);
					}

					// Экспортируем свойства
					pre.afterProps && Object.keys(pre.afterProps).forEach(function (key) {
						code.push(__xb + '.' + key + '=' + pre.afterProps[key] + ';');
					});

					code.push('if (' + __xb + '.parent !== void 0) __bid = ' + __xb + '.parent;');
				}
				else {
					code.push(expr);
				}

				bindIdx++;

				return code.join('\n');
			});
		} while (r_expr.test(template));


		template = new Function('return ' + template)();

		// Инициализируем шиблон и экспортируем блоки
		template({});

		return template;
	}



	function ModelView(ctx) {
		var pid;

		ctx.__proto__ = this;
		ctx.$apply = function () {
			clearTimeout(pid);
			setTimeout(function () {
				ctx._$apply();
			}, 1);
		};

		return ctx;
	}

	ModelView.prototype = {
		constructor: ModelView,

		$: function () {
			return this.el || window[this.$id];
		},

		$init: function (el, endEl) {
			var $inited,
				chr,
				idx,
				nodeValue;

			if (el === true) {
				el = this.$();
				this.$inited = $inited = true;
			}

			if (el) {
				do {
					if (el.nodeType === 8) {
						nodeValue = el.nodeValue;
						idx = nodeValue|0;
						chr = nodeValue.charAt(0);

						if (!(chr > 0)) {
							idx = nodeValue.substr(1) | 0;
						}

						if (chr === 'l') { // простая связка
							this.$binds[idx].el = el;
						}
						else if (chr === 'e') { // события
							setTimeout(function (el, events) {
								events.el = el;
								this.$events.push(events);

								events.unbind = function () {
									events.forEach(function (desc) {
										(desc.outside ? document : el).removeEventListener(desc.name, desc.handle);
										desc.handle = null;
									});

									el = null;
									events.el = null;
									events.unbind = null;
								};

								events.forEach(function (desc) {
									(desc.outside ? document : el).addEventListener(desc.name, desc.handle = function (desc, evt) {
										if (desc.outside) {
											var check = evt.target;

											do {
												if (check === el) {
													return;
												}
											} while (check = check.parentNode);
										}

										desc.fn.call(el, evt, el);

										this.$apply();
									}.bind(this, desc));
								}, this);
							}.bind(this, el.previousSibling || el.parentNode, this.$binds[idx]));

							this.$binds[idx] = void 0;
						}
						else if (chr === '/') {
							this.$binds[idx]._el = el;
						}
						else {
							this.$binds[idx].el = el;
						}
					}
					else if (el.nodeType === 1 && ($inited || !el.attributes.scope)) {
						if (el.attributes.m) {
							this.$binds[el.attributes.m.value].el = el;
						}

						if (el.childNodes.length > 0) {
							this.$init(el.firstChild);
						}
					}

					if ($inited === true) {
						break;
					}
				} while ((el = el.nextSibling) && (el !== endEl));
			}
		},

		$mods: function (newValue, oldValue) {
			var el = this.$(),
				block = this.$name,
				className = ' ' + el.className + ' ';

			if (oldValue) {
				oldValue = block + '_' + (oldValue.join ? oldValue.join(' ' + block + '_') : oldValue);
				className = className.replace(' ' + oldValue + ' ', '')
			}

			if (newValue && newValue.length) {
				newValue = block + '_' + (newValue.join ? newValue.join(' ' + block + '_') : newValue);
				className += ' ' + newValue + ' ';
			}

			this._mods = className;
			el.className = className;

			this.$apply();
		},

		$set: function (key, value, silent) {
			if (this.$() === void 0) {
				return;
			}

			if (typeof key === 'object') {
				for (var i in key) {
					this.$set(i, key[i], true);
				}

				this.$apply();
			}
			else {
				var _value = this[key];

				if (_value !== value) {
					this[key] = value;

					if (this['$' + key] !== void 0) {
						this['$' + key](value, _value);
					}
					else if (silent !== true) {
						this.$apply();
					}
				}
			}

			return this;
		},

		$bind: function (id, name, tpl, binds, events) {
			this.$id = id;
			this.$name = name;
			this.$tpl = tpl;
			this.$binds = binds;
			this.$events = events;
			this.$inited = false;

			_addQueue(this);
		},

		$replaceBetween: function (startEl, endEl, html) {
			var parentEl = startEl.parentNode;

			while (startEl.nextSibling !== endEl) {
				parentEl.removeChild(startEl.nextSibling);
			}

			if (html !== '') {
				parentEl.insertBefore(_createFragment(html), endEl);
				this.$init(startEl, endEl);

				return true;
			}

			return false;
		},

		_$apply: function () {
			if (this.$inited !== true) {
				this.$init(true);
			}

			var i = 0,
				el = this.$(),
				bind,
				bindEl,
				html,
				binds = this.$binds,
				length = binds.length,
				$events = this.$events;

			for (; i < length; i++) {
				bind = binds[i];

				if (bind === void 0 || isDetached(el, bind.el)) {
					if (bind !== void 0) {
						binds.unbind && binds.unbind();
						bind.el = bind._el = null;
					}

					binds.splice(i, 1);
					i--;
					length--;
					continue;
				}
				else if ((bind.$test !== void 0) && !bind.$test()) {
					continue;
				}

				bindEl = bind.el;

				if (bind.$apply !== void 0) {
					bind.$apply(el, bindEl);
				}

				if (bind.$render !== void 0) {
					html = bind.$render();

					if (bind.name === 'IF') {
						this.$replaceBetween(bind.el, bind._el, html);

						$events.forEach(function (evt, i) {
							evt.el && !evt.el.parentNode && evt.unbind();
							$events.splice(i, 1);
						});
					}
					else if (bind.name === 'V' && bind.opts === 'raw') {
						this.$replaceBetween(bind.el, bind._el, html);
					}
					else {
						bindEl = bindEl.nextSibling;

						if (bindEl === bind._el) {
							bindEl.parentNode.insertBefore(document.createTextNode(html), bind._el);
						} else {
							bindEl.nodeValue = html;
						}
					}
				}
			}
		}
	};


	function isDetached(rootEl, el) {
		while (rootEl !== el) {
			el = el.parentNode;

			if (el === null) {
				return true;
			}
		}

		return false;
	}


	/**
	 * Добавить препроцессор
	 * @param  {Object} desc описание препроцессора
	 * @return {templatePreprocessing}
	 */
	templatePreprocessing.add = function (desc) {
		_preprocessors.push(desc);
		_preprocessors[desc.id] = desc;

		return this;
	};


	// Добавляем препроцессоры
	templatePreprocessing
		.add({
			id: 'V', // fest:value
			dom: 'wrap', // связь с DOM (добавить html-комментарии)
			render: true, // можно рендерить
			expr: function (value) { return value.replace(/\b__fest_escape[^(]+/g, ''); }
		})
		.add({
			id: 'IF', // fest:if
			dom: 'wrap',
			render: true,
			props: {
				last: '!!__fest_if' // запомнить последнее значение биндинга
			},
			$test: function () { // функция проверки изменений
				var __fest_if;

				this.getter();

				if (this.last !== !!__fest_if) {
					this.last = !!__fest_if;
					return true;
				}
			}
		})
		.add({
			id: 'B', // <bem:___/>
			dom: 'link',
			afterProps: {
				model: '__fest_params'
			},
			$apply: function () {
				var __fest_params;
				this.getter();
				this.model.$set(__fest_params);
			}
		})
		.add({
			id: 'M',
			attr: 'm', // биндинг через аттрибут
			props: {
				name: '__bem_x',
				mods: '__bem_mods'
			},
			$apply: function (el, bindEl) {
				if (el) {
					var __bem_mods = this.mods,
						__bem_x = this.name,
						__bem_block_mods = el.className;

					this.getter();

					(bindEl || el).className = __bem_mods;
				}
			}
		})
	;


	// Export
	return {
		ModelView: ModelView,
		applyBindingPatch: templatePreprocessing
	};
});

define('ui/lego',[],function(){return function __template__(__fest_context){"use strict";var __fest_self=this,__gid=1,__fest_buf="",__fest_chunks=[],__fest_chunk,__fest_attrs=[],__fest_select,__fest_if,__fest_iterator,__fest_to,__fest_fn,__fest_html="",__fest_blocks={},__fest_params,__fest_element,__fest_debug_file="",__fest_debug_line="",__fest_debug_block="",__fest_htmlchars=/[&<>"]/g,__fest_htmlchars_test=/[&<>"]/,__fest_short_tags = {"area":true,"base":true,"br":true,"col":true,"command":true,"embed":true,"hr":true,"img":true,"input":true,"keygen":true,"link":true,"meta":true,"param":true,"source":true,"wbr":true},__fest_element_stack = [],__fest_htmlhash={"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"},__fest_jschars=/[\\'"\/\n\r\t\b\f<>]/g,__fest_jschars_test=/[\\'"\/\n\r\t\b\f<>]/,__fest_jshash={"\"":"\\\"","\\":"\\\\","/":"\\/","\n":"\\n","\r":"\\r","\t":"\\t","\b":"\\b","\f":"\\f","'":"\\'","<":"\\u003C",">":"\\u003E"},___fest_log_error;if(typeof __fest_error === "undefined"){___fest_log_error = (typeof console !== "undefined" && console.error) ? function(){return Function.prototype.apply.call(console.error, console, arguments)} : function(){};}else{___fest_log_error=__fest_error};function __fest_log_error(msg){___fest_log_error(msg+"\nin block \""+__fest_debug_block+"\" at line: "+__fest_debug_line+"\nfile: "+__fest_debug_file)}function __fest_replaceHTML(chr){return __fest_htmlhash[chr]}function __fest_replaceJS(chr){return __fest_jshash[chr]}function __fest_extend(dest, src){for(var i in src)if(src.hasOwnProperty(i))dest[i]=src[i];}function __fest_param(fn){fn.param=true;return fn}function __fest_call(fn, params,cp){if(cp)for(var i in params)if(typeof params[i]=="function"&&params[i].param)params[i]=params[i]();return fn.call(__fest_self,params)}function __fest_escapeJS(s){if (typeof s==="string") {if (__fest_jschars_test.test(s))return s.replace(__fest_jschars,__fest_replaceJS);} else if (typeof s==="undefined")return "";return s;}function __fest_escapeHTML(s){if (typeof s==="string") {if (__fest_htmlchars_test.test(s))return s.replace(__fest_htmlchars,__fest_replaceHTML);} else if (typeof s==="undefined")return "";return s;}var __bem_layout = __template__["layout"] = function (ctx) {var __xid = "-" + __gid++,__xevents = [],__fest_buf = "",__bem_block = "layout",__bem_x = __bem_block,__bem_mods = __bem_block + " ",__bem_block_mods;
				if (ctx.mods !== void 0) {
					__bem_mods += __bem_block + '_' + (ctx.mods.join ? ctx.mods.join(' ' + __bem_block + '_') : ctx.mods);
				}
		__fest_buf+=("<div id=\"" + __xid + "\" scope=\"" + true + "\" class=\"" + (__bem_block_mods = " " + __bem_mods + " ") + "\"><div class=\"layout__1\"><div data-view-id=\"folders\"></div></div><div class=\"layout__2\"><div data-view-id=\"messages\"></div></div><div class=\"layout__3\"><div data-view-id=\"message\"></div></div><div class=\"clear\"></div></div>");
			if (ctx && ctx.$bind) {
				ctx.$bind(__xid, __bem_block, __template__[__bem_block], __xb, __xevents);
			}
	return __fest_buf; };var __bem_btn = __template__["btn"] = function (ctx) {var __xid = "-" + __gid++,__xevents = [],__fest_buf = "",__bem_block = "btn",__bem_x = __bem_block,__bem_mods = __bem_block + " ",__bem_block_mods;
				if (ctx.mods !== void 0) {
					__bem_mods += __bem_block + '_' + (ctx.mods.join ? ctx.mods.join(' ' + __bem_block + '_') : ctx.mods);
				}
		__fest_buf+=("<button on-click=\"ctx.onclick()\" id=\"" + __xid + "\" scope=\"" + true + "\" class=\"" + (__bem_block_mods = " " + __bem_mods + " ") + "\">");/*$IF*/try{__fest_if=ctx.icon}catch(e){ __fest_if=false;__fest_log_error(e.message);}/*$*/if(__fest_if){__fest_buf+=("{ mods: ctx.icon }");}/*IF$*/var __bem_elem = __bem_block + "__text";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<span");/*$M*/try{__fest_if=ctx.icon}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_pad";/*M$*/__fest_buf+=(" class=\"" + __bem_mods + "\">");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(ctx.text))}catch(e){__fest_log_error(e.message + "12");}/*V$*/__fest_buf+=("</span></button>");
			if (ctx && ctx.$bind) {
				ctx.$bind(__xid, __bem_block, __template__[__bem_block], __xb, __xevents);
			}
	return __fest_buf; };var __bem_nav = __template__["nav"] = function (ctx) {var __xid = "-" + __gid++,__xevents = [],__fest_buf = "",__bem_block = "nav",__bem_x = __bem_block,__bem_mods = __bem_block + " ",__bem_block_mods;
				if (ctx.mods !== void 0) {
					__bem_mods += __bem_block + '_' + (ctx.mods.join ? ctx.mods.join(' ' + __bem_block + '_') : ctx.mods);
				}
		__fest_buf+=("<div id=\"" + __xid + "\" scope=\"" + true + "\" class=\"" + (__bem_block_mods = " " + __bem_mods + " ") + "\">");try{__fest_iterator=ctx.items}catch(e){ __fest_iterator=false;__fest_log_error(e.message);}if(__fest_iterator && __fest_iterator.length)__fest_iterator.forEach(function (item) {__fest_buf+=("<div>");var __bem_elem = __bem_block + "__item";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;try{__fest_attrs[0]=__fest_escapeHTML(item.url)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<a href=\"#!" + __fest_attrs[0] + "\" on-click=\"ctx.active = item.id\"");/*$M*/try{__fest_if=ctx.active == item.id}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_active";/*M$*/__fest_buf+=(" class=\"" + __bem_mods + "\">");try{__fest_attrs[0]=__fest_escapeHTML(item.icon)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<i class=\"fa fa-" + __fest_attrs[0] + "\"></i><span>");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(item.text))}catch(e){__fest_log_error(e.message + "11");}/*V$*/__fest_buf+=("</span>");/*$IF*/try{__fest_if=item.badge}catch(e){ __fest_if=false;__fest_log_error(e.message);}/*$*/if(__fest_if){var __bem_elem = __bem_block + "__badge";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<span class=\"" + __bem_mods + "\">");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(item.badge))}catch(e){__fest_log_error(e.message + "14");}/*V$*/__fest_buf+=("</span>");}/*IF$*/__fest_buf+=("</a>");var __bem_elem = __bem_block + "__subitems";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<div");/*$M*/try{__fest_if=!item.expanded}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_close";/*M$*/__fest_buf+=(" class=\"" + __bem_mods + "\">");try{__fest_iterator=item.items}catch(e){ __fest_iterator=false;__fest_log_error(e.message);}if(__fest_iterator && __fest_iterator.length)__fest_iterator.forEach(function (item) {var __bem_elem = __bem_block + "__item";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;try{__fest_attrs[0]=__fest_escapeHTML(item.url)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<a href=\"#!" + __fest_attrs[0] + "\" on-click=\"ctx.active = item.id\"");/*$M*/try{__fest_if=ctx.active == item.id}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_active";/*M$*/__fest_buf+=(" class=\"" + __bem_mods + "\">");try{__fest_attrs[0]=__fest_escapeHTML(item.icon)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<i class=\"fa fa-" + __fest_attrs[0] + "\"></i><span>");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(item.text))}catch(e){__fest_log_error(e.message + "26");}/*V$*/__fest_buf+=("</span>");/*$IF*/try{__fest_if=item.badge}catch(e){ __fest_if=false;__fest_log_error(e.message);}/*$*/if(__fest_if){var __bem_elem = __bem_block + "__badge";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<span class=\"" + __bem_mods + "\">");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(item.badge))}catch(e){__fest_log_error(e.message + "29");}/*V$*/__fest_buf+=("</span>");}/*IF$*/__fest_buf+=("</a>");});__fest_buf+=("</div></div>");});__fest_buf+=("</div>");
			if (ctx && ctx.$bind) {
				ctx.$bind(__xid, __bem_block, __template__[__bem_block], __xb, __xevents);
			}
	return __fest_buf; };var __bem_caption = __template__["caption"] = function (ctx) {var __xid = "-" + __gid++,__xevents = [],__fest_buf = "",__bem_block = "caption",__bem_x = __bem_block,__bem_mods = __bem_block + " ",__bem_block_mods;
				if (ctx.mods !== void 0) {
					__bem_mods += __bem_block + '_' + (ctx.mods.join ? ctx.mods.join(' ' + __bem_block + '_') : ctx.mods);
				}
		__fest_buf+=("<div id=\"" + __xid + "\" scope=\"" + true + "\" class=\"" + (__bem_block_mods = " " + __bem_mods + " ") + "\">");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(ctx.text || ''))}catch(e){__fest_log_error(e.message + "4");}/*V$*/__fest_buf+=("&nbsp;</div>");
			if (ctx && ctx.$bind) {
				ctx.$bind(__xid, __bem_block, __template__[__bem_block], __xb, __xevents);
			}
	return __fest_buf; };var __bem_datalist = __template__["datalist"] = function (ctx) {var __xid = "-" + __gid++,__xevents = [],__fest_buf = "",__bem_block = "datalist",__bem_x = __bem_block,__bem_mods = __bem_block + " ",__bem_block_mods;
				if (ctx.mods !== void 0) {
					__bem_mods += __bem_block + '_' + (ctx.mods.join ? ctx.mods.join(' ' + __bem_block + '_') : ctx.mods);
				}
		__fest_buf+=("<div id=\"" + __xid + "\" scope=\"" + true + "\" class=\"" + (__bem_block_mods = " " + __bem_mods + " ") + "\">");try{__fest_iterator=ctx.items}catch(e){ __fest_iterator=false;__fest_log_error(e.message);}if(__fest_iterator && __fest_iterator.length)__fest_iterator.forEach(function (item) {var __bem_elem = __bem_block + "__item";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<div");/*$M*/try{__fest_if=item.active}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_active";/*M$*//*$M*/try{__fest_if=item.selected}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_selected";/*M$*/__fest_buf+=(" class=\"" + __bem_mods + "\">");var __bem_elem = __bem_block + "__unread";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<span on-click=\"ctx.onunread(item)\"");/*$M*/try{__fest_if=item.unread}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_yes";/*M$*/__fest_buf+=(" class=\"" + __bem_mods + "\"></span>");var __bem_elem = __bem_block + "__ava";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;try{__fest_attrs[0]=__fest_escapeHTML(item.avatar)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<span on-click=\"ctx.onselect(item);\" style=\"background-image: url(\'" + __fest_attrs[0] + "\')\" class=\"" + __bem_mods + "\"><i class=\"fa fa-check-circle\"></i></span>");var __bem_elem = __bem_block + "__user";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;try{__fest_attrs[0]=__fest_escapeHTML(item.url)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<a href=\"#!" + __fest_attrs[0] + "\" class=\"" + __bem_mods + "\">");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(item.email))}catch(e){__fest_log_error(e.message + "17");}/*V$*/__fest_buf+=("</a>");var __bem_elem = __bem_block + "__subj";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;try{__fest_attrs[0]=__fest_escapeHTML(item.url)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<a href=\"#!" + __fest_attrs[0] + "\" class=\"" + __bem_mods + "\">");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(item.subject))}catch(e){__fest_log_error(e.message + "18");}/*V$*/__fest_buf+=("</a><i on-click=\"ctx.ondelete(item)\" class=\"datalist__ctrl fa fa-trash-o\"></i></div>");});__fest_buf+=("</div>");
			if (ctx && ctx.$bind) {
				ctx.$bind(__xid, __bem_block, __template__[__bem_block], __xb, __xevents);
			}
	return __fest_buf; };var __bem_letter = __template__["letter"] = function (ctx) {var __xid = "-" + __gid++,__xevents = [],__fest_buf = "",__bem_block = "letter",__bem_x = __bem_block,__bem_mods = __bem_block + " ",__bem_block_mods;
				if (ctx.mods !== void 0) {
					__bem_mods += __bem_block + '_' + (ctx.mods.join ? ctx.mods.join(' ' + __bem_block + '_') : ctx.mods);
				}
		__fest_buf+=("<div id=\"" + __xid + "\" scope=\"" + true + "\" class=\"" + (__bem_block_mods = " " + __bem_mods + " ") + "\">");/*$B*/try{__fest_params={text: ctx.model.get("subject")}}catch(e){__fest_log_error(e.message)}/*$*/__fest_params = new fest.ModelView(__fest_params);/*B$*/__fest_buf+=(__bem_caption(__fest_params));var __bem_elem = __bem_block + "__info";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<div class=\"" + __bem_mods + "\">от&nbsp;");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(ctx.model.get('correspondents.from.0.name') || ctx.model.get('correspondents.from.0.email')))}catch(e){__fest_log_error(e.message + "8");}/*V$*/__fest_buf+=("</div>");var __bem_elem = __bem_block + "__body";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<div class=\"" + __bem_mods + "\">");/*$V*/try{/*$OPTS:"raw"*/__fest_buf+=(ctx.html())}catch(e){__fest_log_error(e.message + "12");}/*V$*/__fest_buf+=("</div></div>");
			if (ctx && ctx.$bind) {
				ctx.$bind(__xid, __bem_block, __template__[__bem_block], __xb, __xevents);
			}
	return __fest_buf; };var __bem_toolbar = __template__["toolbar"] = function (ctx) {var __xid = "-" + __gid++,__xevents = [],__fest_buf = "",__bem_block = "toolbar",__bem_x = __bem_block,__bem_mods = __bem_block + " ",__bem_block_mods;
				if (ctx.mods !== void 0) {
					__bem_mods += __bem_block + '_' + (ctx.mods.join ? ctx.mods.join(' ' + __bem_block + '_') : ctx.mods);
				}
		__fest_buf+=("<div");/*$M*/try{__fest_if=ctx.hidden}catch(e){ __fest_if=false;__fest_log_error(e.message);}if (__fest_if)__bem_mods += " " + __bem_x + "_hidden";/*M$*/__fest_buf+=(" id=\"" + __xid + "\" scope=\"" + true + "\" class=\"" + (__bem_block_mods = " " + __bem_mods + " ") + "\">");try{__fest_iterator=ctx.items}catch(e){ __fest_iterator=false;__fest_log_error(e.message);}if(__fest_iterator && __fest_iterator.length)__fest_iterator.forEach(function (item) {var __bem_elem = __bem_block + "__item";__bem_mods = __bem_elem + " "; __bem_x = __bem_elem;__fest_buf+=("<div on-click=\"item.onclick(item)\" class=\"" + __bem_mods + "\">");try{__fest_attrs[0]=__fest_escapeHTML(item.icon)}catch(e){__fest_attrs[0]=""; __fest_log_error(e.message);}__fest_buf+=("<i class=\"fa fa-" + __fest_attrs[0] + "\"></i>");/*$V*/try{/*$OPTS:"html"*/__fest_buf+=(__fest_escapeHTML(item.text))}catch(e){__fest_log_error(e.message + "9");}/*V$*/__fest_buf+=("</div>");});__fest_buf+=("</div>");
			if (ctx && ctx.$bind) {
				ctx.$bind(__xid, __bem_block, __template__[__bem_block], __xb, __xevents);
			}
	return __fest_buf; };__fest_to=__fest_chunks.length;if (__fest_to) {__fest_iterator = 0;for (;__fest_iterator<__fest_to;__fest_iterator++) {__fest_chunk=__fest_chunks[__fest_iterator];if (typeof __fest_chunk==="string") {__fest_html+=__fest_chunk;} else {__fest_fn=__fest_blocks[__fest_chunk.name];if (__fest_fn) __fest_html+=__fest_call(__fest_fn,__fest_chunk.params,__fest_chunk.cp);}}return __fest_html+__fest_buf;} else {return __fest_buf;}}});

define('ui/block',['fest', 'ui/lego', 'utils/util'], function (fest, lego, util) {
	window.fest = fest;

	// Накладываем патч с поддержкой data-binding
	lego = fest.applyBindingPatch(lego);


	// Export
	return {
		render: function (name, data) {
			return lego[name](data || {});
		},

		create: function (name, spec) {
			var template = lego[name];

			spec = spec || {};

			return function (data) {
				data = data || spec.mock;

				var _el,
					html,
					model = new fest.ModelView(data),
					_render;

				spec.init && spec.init(model);

				model.bind = function (el) {
					console.time(name + '.transform');
					spec.transform && spec.transform(data);
					console.timeEnd(name + '.transform');

					_el = el || _el;

					console.time(name + '.template');
					html = template(model);
					console.timeEnd(name + '.template');

					console.time(name + '.inenrHTML');
					_el.innerHTML = html;
					console.timeEnd(name + '.inenrHTML');

					return model;
				};


				_render = util.debounce(util.bindWithoutArgs(model.bind), 0);
				model.setModels = function (models, soft) {
					model.models && models.off('add remove reset', _render);
					model.models = models;

					models.on('add remove reset', _render);
					!soft && _render();
				};

				data.models && model.setModels(data.models, true);

				return model;
			};
		}
	};
});

define('ui/nav/nav',['ui/block'], function (block) {
	var ICON_MAP = {
		inbox: 'inbox',
		spam: 'thumbs-o-down',
		sent: 'paper-plane-o',
		trash: 'trash-o',
		def: 'folder-o'
	};

	return block.create('nav', {
		init: function (data) {
			data.models.on('change', function (evt, folder) {
				var item = data.index[folder.id];

				item.text = folder.get('name');
				item.badge = folder.get('unread');

				data.$apply();
			});
		},

		transform: function (data) {
			data.items = [];
			data.index = {};

			(function _next(items, parentId) {
				data.models.forEach(function (folder) {
					if (folder.get('parent') == parentId) {
						var subitems = [];
						var item = {
							id: folder.id,
							url: data.route.getUrl(folder),
							icon: ICON_MAP[folder.get('type')] || ICON_MAP.def,
							text: folder.get('name'),
							badge: folder.get('unread'),
							items: subitems
						};

						items.push(item);
						data.index[folder.id] = item;

						_next(subitems, folder.id);
					}
				});
			})(data.items, -1);
		}
	});
});

define('ui/caption/caption',['ui/block'], function (block) {
	return block.create('caption');
});

define('ui/toolbar/toolbar',['ui/block'], function (block) {
	return block.create('toolbar');
});

define('ui/datalist/datalist',['ui/block', 'mail/Message'], function (block, Message) {
	return block.create('datalist', {
		init: function (data) {
			Message.all.on('change', function (evt, message) {
				var item = data.index[message.id];

				if (item) {
					item.unread = message.get('flags.unread');
					item.flagged = message.get('flags.flagged');
				}
			});
		},

		transform: function (data) {
			var items = data.items = [],
				isMessages = data.route.router.request.is('#message');

			data.index = {};

			data.models && data.models.forEach(function (message) {
				var item = {
					id: message.id,
					active: isMessages && data.route.router['#message'].params.message == message.id,
					url: data.route.router.getUrl('#message', message),
					email: message.get('correspondents.from.0.name') || message.get('correspondents.from.0.email'),
					avatar: message.get('correspondents.from.0.avatars.default'),
					unread: message.is('flags.unread'),
					flagged: message.is('flags.flagged'),
					subject: message.get('subject'),
					snippet: message.get('snippet')
				};

				items.push(item);
				data.index[message.id] = item;
			});
		}
	});
});

define('ui/letter/letter',['ui/block'], function (block) {
	return block.create('letter');
});

define('mediator/action',['Emitter', 'Action', 'mail/Folder'], function (Emitter, Action, Folder) {
	var _this = {
		setSource: function (source) {
			_this.source = source;
		},

		/** @return {mail.Message} */
		getModel: function (id) {
			return _this.source.getModel(id);
		},

		getModels: function () {
			return _this.source.getModels();
		},

		getSelected: function () {
			return _this.source.getSelected();
		},

		_execute: function (name, params) {
			_this.emit('execution');
			return Action.execute(name, params);
		},

		_markAs: function (models, flag, state) {
			_this._execute('mail.MarkAs', {models: models, flag: flag, state: state});
		},

		toggleUnread: function (item) {
			var model = _this.getModel(item.id);
			_this._markAs([model], 'unread', !model.is('flags.unread'));
		},

		markAsReadedSelected: function () {
			_this._markAs(_this.getSelected(), 'unread', false);
		},

		_delete: function (models) {
			var _list = _this.getModels();

			_this._execute('mail.MoveTo', {models: models, folderTo: Folder.TRASH}).then(function () {
				models.forEach(function (model) {
					_list.remove(model);
				});
			});
		},

		'delete': function (item) {
			_this._delete([_this.getModel(item.id)]);
		},

		deleteSelected: function () {
			_this._delete(_this.getSelected());
		}
	};


	// Export
	return Emitter.apply(_this);
});

define('mediator/selection',['Emitter'], function (Emitter) {
	var _this = {
		source: null,

		setSource: function (source) {
			_this.source = source;
		},

		getModel: function (id) {
			return _this.source.models.get(id);
		},

		getModels: function () {
			return _this.source.models;
		},

		getSelected: function () {
			return _this.source.items
				.filter(function (item) {
					return item.selected;
				})
				.map(function (item) {
					return _this.source.models.get(item.id);
				});
		},

		clear: function () {
			_this._selectAll('none');
		},

		_selectAll: function (mode) {
			_this.source.items.forEach(function (item) {
				item.selected = mode != 'none';
			});
			_this.emit('change', {selected: mode == 'none' ? 0 : _this.source.items.length });
		},

		selectAllOnPerPage: function () {
			_this._selectAll('per-page');
		},

		deselectAllOnPerPage: function () {
			_this._selectAll('none');
		},

		onSelect: function (item) {
			item.selected = !item.selected;
			_this.emit('change', {selected: _this.getSelected().length });
		}
	};


	Object.keys(_this).forEach(function (name) {
		var fn = _this[name];

		if (typeof fn === 'function' && name != 'setSource' && !/^(_|get|set)/.test(name)) {
			_this[name] = function () {
				fn.apply(_this, arguments);
				_this.source.$apply();
			};
		}
	});

	return Emitter.apply(_this);
});

define('pilot/mixin/view',['jquery'], function ($) {
	/** @type {window} */
	var win = window;

	/** @type {HTMLDocument} */
	var document = win.document;


	/** @type {HTMLElement} */
	var helper = document.createElement('div');


	// Export
	return {
		/** @type {string} */
		el: '',

		/** @type {jQuery} */
		$el: null,

		/** @type {string} */
		dom: '',

		/** @type {HTMLElement} */
		parentEl: null,

		// Применение примиси
		apply: function () {
			if (this.dom) { // Строим DOM из строки
				helper.innerHTML = this.dom;
				this.el = helper.firstElementChild || helper.firstChild;

				helper.removeChild(this.el);
			}
			else if (typeof this.el == 'string') {
				this.el = document.getElementById(this.el.replace(/^#/, ''));
			}

			this.$el = $(this.el);

			// А теперь добавляем в DOM, если это не так
			if (this.el.nodeType > 0) {
				this._toggleView(false);

				this.one('before-init', function () {
					// Поиск родителя
					if (this.parentEl === null) {
						var parentRoute = this.parentRoute;

						if (parentRoute) {
							do {
								this.parentEl = (
									parentRoute.el &&
									parentRoute.$el.find('[data-view-id="' + (this.name || this.id).replace(/^#/, '') + '"]')[0] ||
									0 && parentRoute.el
								);
							}
							while (!this.parentEl && (parentRoute = parentRoute.parentRoute));
						} else {
							this.parentEl = document.body;
						}
					}

					if (this.parentEl) {
						this.parentEl.appendChild(this.el);
					}
				}.bind(this));
			}

			this.on('route-start route-end', function (evt) {
				this._toggleView(evt.type == 'routestart');
			}.bind(this));
		},

		_toggleView: function (state) {
			if (this.router) {
				this.el && this.el.style && (this.el.style.display = state ? '' : 'none');
			}
		},

		$: function (selector) {
			return this.$el.find(selector);
		}
	};
});

/**
 * @author   RubaXa  <trash@rubaxa.org>
 * @licence  MIT
 * Обязательно нужен JSON и Promise
 */

/*global require, define, window*/
(function(factory ) {
	'use strict';

	/* istanbul ignore next */
	if (typeof define === 'function' && define.amd) {
		define('Ply',factory);
	}
	else {
		window['Ply'] = factory();
	}
})(function()  {
	'use strict';


	var gid = 1,
		noop = function()  {},

		env = window,
		document = env.document,
		setTimeout = env.setTimeout,

		lang = /**
 * @desc Языковые константы
 */

{
	ok: 'OK',
	cancel: 'Cancel',
	cross: '✖'
},
		support = /**
 * @desc Что поддерживает браузер
 */


/*global _buildDOM*/
(function()  {
	var props = {},
		style = document.createElement('div').style,
		names = 'opacity transition transform perspective transformStyle transformOrigin backfaceVisibility'.split(' '),
		prefix = ['Webkit', 'Moz', 'O', 'MS']
	;

	_each(names, function(name, i)  {
		props[name] = (name in style) && /* istanbul ignore next */ name;

		/* istanbul ignore else */
		if (!props[name]) {
			for (i = 0; i < 4; i++) {
				var pname = prefix[i] + name.charAt(0).toUpperCase() + name.substr(1);
				/* istanbul ignore else */
				if (props[name] = (pname in style) && pname) {
					break;
				}
			}
		}
	});

	return props;
})(),

		/**
		 * Коды кнопок
		 * @type {Object}
		 */
		keys = /**
 * Коды кнопок
 * @type {Object}
 */
{
	esc: 27
},


		_plyAttr = 'data-ply'
	;


	//
	// $-like object
	//
	var $ = /**
 * @desc $-like adapter
 */
window.jQuery
	|| /* istanbul ignore next */ window.Zepto
	|| /* istanbul ignore next */ window.ender
	|| /* istanbul ignore next */ window.$



	//
	//       Настройки по умолчанию
	//
	var _defaults = /**
 * @desc Настройки по умолчанию
 */

{
	clone: true,
	zIndex: 10000,
	rootTag: 'form',
	baseHtml: true,

	layer: {}, // css
	wrapper: {}, // css

	overlay: {
		opacity: .6,
		backgroundColor: 'rgb(0, 0, 0)'
	},

	flags: {
		closeBtn: true,
		bodyScroll: false,
		closeByEsc: true,
		closeByOverlay: true,
		hideLayerInStack: true,
		visibleOverlayInStack: false
	},

	// Callbacks
	oninit: noop,
	onopen: noop,
	onclose: noop,
	ondestroy: noop,
	onaction: noop
}


	//
	//       Обещания, Утилиты, CSS, DOM
	//
	/**
 * @desc «Обещания»
 */

var NativePromise = window.Promise,
	Promise = window.Deferred || NativePromise
;


/**
 * Создать «Обещание»
 * @param   {Function}  executor
 * @returns {Promise}
 * @private
 */
function _promise(executor) {
	/* istanbul ignore if */
	if (Promise) {
		return new Promise(executor);
	} else {
		var dfd = $.Deferred();
		executor(dfd.resolve, dfd.reject);
		return dfd;
	}
}


/**
 * Дождаться разрешения всех «Обещаний»
 * @param   {Promise[]}  iterable
 * @returns {Promise}
 * @private
 */
function _promiseAll(iterable) {
	return Promise
		? /* istanbul ignore next */ Promise.all(iterable)
		: $.when.apply($, iterable);
}


/**
 * Вернуть разрешенное «Обещание»
 * @param   {*} [value]
 * @returns {Promise}
 * @private
 */
function _resolvePromise(value) {
	return _promise(function(resolve ) {return resolve(value)});
}


/**
 * Привести значение к «Обещанию»
 * @param   {*} value
 * @returns {Promise}
 * @private
 */
function _cast(value) {
	/* istanbul ignore next */
	return value && value.then ? value : _resolvePromise(value);
}



//
// Проверяем поддержку методы: done, fail, always
//
var __promise__ = _resolvePromise();

/* istanbul ignore next */
if (NativePromise && !__promise__.always) {
	Promise = function (executor) {
		var promise = new NativePromise(executor);
		promise.__proto__ = this.__proto__;
		return promise;
	};

	Promise.prototype = Object.create(NativePromise.prototype);
	Promise.prototype.constructor = Promise;

	Promise.prototype.then = function (doneFn, failFn) {
		var promise = NativePromise.prototype.then.call(this, doneFn, failFn);
		promise.__proto__ = this.__proto__; // for FireFox
		return promise;
	};

	Promise.prototype.done = function (callback) {
		this.then(callback);
		return this;
	};

	Promise.prototype.fail = function (callback) {
		this['catch'](callback);
		return this;
	};

	Promise.prototype.always = function (callback) {
		this.then(callback, callback);
		return this;
	};

	['all', 'cast', 'reject', 'resolve'].forEach(function(name ) {
		Promise[name] = NativePromise[name];
	});
}
	/**
 * @desc Вспомогательные методы
 */


/**
 * Функция?
 * @param   {*}  fn
 * @returns {Boolean}
 */
function isFn(fn) {
	return typeof fn === 'function';
}


/**
 * Object iterator
 * @param  {Object|Array}  obj
 * @param  {Function}      iterator
 * @private
 */
function _each(obj, iterator) {
	if (obj) {
		for (var key in obj) {
			/* istanbul ignore else */
			if (obj.hasOwnProperty(key)) {
				iterator(obj[key], key, obj);
			}
		}
	}
}


/**
 * Глубокое клонирование
 * @param   {*} obj
 * @returns {*}
 * @private
 */
function _deepClone(obj) {
	var result = {};

	_each(obj, function(val, key)  {
		if (isFn(val)) {
			result[key] = val;
		}
		else if (val instanceof Object) {
			result[key] = _deepClone(val);
		}
		else {
			result[key] = val;
		}
	});

	return result;
}


/**
 * Перенос свойств одного объект к другому
 * @param   {Object}     dst
 * @param   {...Object}  src
 * @returns {Object}
 * @private
 */
function _extend(dst) {var SLICE$0 = Array.prototype.slice;var src = SLICE$0.call(arguments, 1);
	var i = 0, n = src.length;
	for (; i < n; i++) {
		_each(src[i], function(val, key)  {
			dst[key] = val;
		});
	}

	return dst;
}
	/**
 * @desc Работа с DOM
 */


/**
 * Разбор строки "tag#id.foo.bar"
 * @const {RegExp}
 */
var R_SELECTOR = /^(\w+)?(#\w+)?((?:\.[\w_-]+)*)/i;



/**
 * Выбрать элементы по заданному селектору
 * @param   {String}       selector
 * @param   {HTMLElement}  [ctx]
 * @returns {HTMLElement}
 */
function _querySelector(selector, ctx) {
	try {
		return (ctx || document).querySelector(selector);
	} catch (err) {
		/* istanbul ignore next */
		return $(selector, ctx)[0];
	}
}


/**
 * Найти элементы по имени
 * @param   {HTMLElement}  el
 * @param   {String}       name
 * @returns {NodeList}
 */
function _getElementsByTagName(el, name) {
	return el.getElementsByTagName(name);
}


/**
 * Присоединить элемент
 * @param  {HTMLElement}  parent
 * @param  {HTMLElement}  el
 * @private
 */
function _appendChild(parent, el) {
	try {
		parent && el && parent.appendChild(el);
	} catch (e) {}
}


/**
 * Удалить элемент
 * @param  {HTMLElement}  el
 * @private
 */
function _removeElement(el) {
	/* istanbul ignore else */
	if (el && el.parentNode) {
		el.parentNode.removeChild(el);
	}
}


/**
 * Добавить слуашетеля
 * @param    {HTMLElement}  el
 * @param    {String}   name
 * @param    {Function} fn
 * @private
 */
function _addEvent(el, name, fn) {
	var handle = fn.handle = fn.handle || (function(evt)  {
		/* istanbul ignore if */
		if (!evt.target) {
			evt.target = evt.srcElement || document;
		}

		/* istanbul ignore if */
		if (evt.target.nodeType === 3) {
			evt.target = evt.target.parentNode;
		}

		/* istanbul ignore if */
		if (!evt.preventDefault) {
			evt.preventDefault = function()  {
				evt.returnValue = false;
			};
		}

		/* istanbul ignore if */
		if (!evt.stopPropagation) {
			evt.stopPropagation = function()  {
				evt.cancelBubble = true;
			};
		}

		fn.call(el, evt);
	});

	/* istanbul ignore else */
	if (el.addEventListener) {
		el.addEventListener(name, handle, false);
	} else {
		el.attachEvent('on' + name, handle);
	}
}


/**
 * Удалить слуашетеля
 * @param    {HTMLElement}  el
 * @param    {String}   name
 * @param    {Function} fn
 * @private
 */
function _removeEvent(el, name, fn) {
	var handle = fn.handle;
	if (handle) {
		/* istanbul ignore else */
		if (el.removeEventListener) {
			el.removeEventListener(name, handle, false);
		} else {
			el.detachEvent('on' + name, handle);
		}
	}
}



/**
 * Создание DOM структуры по спецификации
 * @param   {String|Object|HTMLElement}  [spec]
 * @returns {HTMLElement}
 * @private
 */
function _buildDOM(spec) {
	if (spec == null) {
		spec = 'div';
	}

	if (spec.appendChild) {
		return spec;
	}
	else if (spec.skip) {
		return document.createDocumentFragment();
	}

	if (typeof spec === 'string') { // selector
		spec = { tag: spec };
	}

	var el,
		children = spec.children,
		selector = R_SELECTOR.exec(spec.tag || '')
	;

	// Это нам больше не нужно
	delete spec.children;

	// Разбираем селектор
	spec.tag = selector[1] || 'div';
	spec.id = spec.id || (selector[2] || '').substr(1);

	// Собираем className
	selector = (selector[3] || '').split('.');
	selector[0] = (spec.className || '');
	spec.className = selector.join(' ');

	// Создаем элемент, теперь можно
	el  = document.createElement(spec.tag);
	delete spec.tag;

	// Определяем свойсва
	_each(spec, function(value, name)  {
		if (value) {
			if (name === 'css') {
				// Определяем CSS свойства
				_css(el, spec.css);
			}
			else if (name === 'text') {
				(value != null) && _appendChild(el, document.createTextNode(value));
			}
			else if (name === 'html') {
				(value != null) && (el.innerHTML = value);
			}
			else if (name === 'ply') {
				// Ply-аттрибут
				el.setAttribute(_plyAttr, value);
			}
			else if (name in el) {
				try {
					el[name] = value;
				} catch (e) {
					el.setAttribute(name, value);
				}
			}
			else if (/^data-/.test(name)) {
				el.setAttribute(name, value);
			}
		}
	});

	// Детишки
	if (children && children.appendChild) {
		_appendChild(el, children);
	}
	else {
		_each(children, function(spec, selector)  {
			if (spec) {
				if (typeof spec === 'string') {
					spec = { text: spec };
				}
				else if (typeof spec !== 'object') {
					spec = {};
				}

				/* istanbul ignore else */
				if (typeof selector === 'string') {
					spec.tag = spec.tag || selector;
				}

				_appendChild(el, _buildDOM(spec));
			}
		});
	}

	return el;
}


/**
 * Выбрать первый не заполненый элемент
 * @param   {HTMLElement}  parentNode
 * @private
 */
function _autoFocus(parentNode) {
	var items = _getElementsByTagName(parentNode, 'input'),
		i = 0,
		n = items.length,
		el,
		element
	;

	for (; i < n; i++) {
		el = items[i];

		/* istanbul ignore else */
		if (el.type === 'submit') {
			!element && (element = el);
		}
		else if (!/hidden|check|radio/.test(el.type) && el.value == '') {
			element = el;
			break;
		}
	}

	if (!element) {
		element = _getElementsByTagName(parentNode, 'button')[0];
	}

	try { element.focus(); } catch (err) { }
}


/**
 * Предзагрузить все изображения
 * @param   {HTMLElement}  parentNode
 * @returns {Promise}
 * @private
 */
function _preloadImage(parentNode) {
	_loading(true);

	return _promise(function(resolve)  {
		var items = _getElementsByTagName(parentNode, 'img'),
			i = items.length,
			queue = i,
			img,
			complete = function()  {
				/* istanbul ignore else */
				if (--queue <= 0) {
					i = items.length;
					while (i--) {
						img = items[i];
						_removeEvent(img, 'load', complete);
						_removeEvent(img, 'error', complete);
					}
					_loading(false);
					resolve();
				}
			}
		;

		while (i--) {
			img = items[i];
			if (img.complete) {
				queue--;
			} else {
				_addEvent(img, 'load', complete);
				_addEvent(img, 'error', complete);
			}
		}

		!queue && complete();
	});
}
	/**
 * @desc Функция для работы с style
 */

/*global support, document*/


/**
 * Хуки для css
 * @type {Object}
 */
var _cssHooks = {
	opacity: !support.opacity && function (style, value) {
		style.zoom = 1;
		style.filter = 'alpha(opacity=' + (value * 100) + ')';
	}
};



/**
 * Установка или получение css свойства
 * @param   {HTMLElement}    el
 * @param   {Object|String}  prop
 * @param   {String}         [val]
 * @returns {*}
 * @private
 */
function _css(el, prop, val) {
	if (el && el.style && prop) {
		if (prop instanceof Object) {
			for (var name in prop) {
				_css(el, name, prop[name]);
			}
		}
		else if (val === void 0) {
			/* istanbul ignore else */
			if (document.defaultView && document.defaultView.getComputedStyle) {
				val = document.defaultView.getComputedStyle(el, '');
			}
			else if (el.currentStyle) {
				val = el.currentStyle;
			}

			return prop === void 0 ? val : val[prop];
		} else if (_cssHooks[prop]) {
			_cssHooks[prop](el.style, val);
		} else {
			el.style[support[prop] || prop] = val;
		}
	}
}



	/**
	 * «Загрузка»
	 * @param  {Boolean}  state
	 * @private
	 */
	function _loading(state) {
		var el = _loading.get();

		clearTimeout(_loading.pid);
		if (state) {
			_loading.pid = setTimeout(function()  {
				_appendChild(document.body, el);
			}, 100);
		} else {
			_loading.pid = setTimeout(function()  {
				_removeElement(el);
			}, 100);
		}
	}


	/**
	 * Получить ссылку на элемент loading
	 * @returns {HTMLElement}
	 */
	_loading.get = function()  {
		return _loading.el || (_loading.el = _buildDOM({ tag: '.ply-global-loading', children: { '.ply-loading-spinner': true } }));
	};



	/**
	 * Создать слой с контентом
	 * @param   {HTMLElement} contentEl
	 * @param   {Object}      options
	 * @returns {HTMLElement}
	 * @private
	 */
	function _createLayer(contentEl, options) {
		return _buildDOM({
			css: _extend({
				padding: '20px 20px 40px', // Сницу в два раза больше, так лучше
				display: 'inline-block',
				position: 'relative',
				textAlign: 'left',
				whiteSpace: 'normal',
				verticalAlign: 'middle',
				transform: 'translate3d(0, 0, 0)'
			}, options.wrapper),
			children: options.baseHtml ? [{
				ply: ':layer',
				tag: '.ply-layer',
				className: options.mod,
				css: _extend({
					overflow: 'hidden',
					position: 'relative',
					backfaceVisibility: 'hidden'
				}, options.layer),
				children: [options.flags.closeBtn && {
					ply: ':close',
					tag: '.ply-x',
					text: lang.cross
				}, {
					tag: '.ply-inside',
					children: contentEl
				}]
			}] : contentEl
		});
	}


	/**
	 * Создать затемнение
	 * @param   {Object}   style
	 * @returns {HTMLElement}
	 * @private
	 */
	function _createOverlay(style) {
		return _buildDOM({
			ply: ':overlay',
			tag: '.ply-overlay',
			css: {
				top: 0,
				left: 0,
				right: 0,
				bottom: 0,
				position: 'fixed'
			},
			children: [{ tag: 'div', css: _extend({ width: '100%', height: '100%' }, style) }]
		});
	}


	/**
	 * Создать ply—объвязку
	 * @param   {Object}   target
	 * @param   {Object}   options
	 * @param   {Boolean}  [onlyLayer]
	 * @returns {Object}
	 * @private
	 */
	function _createPly(target, options, onlyLayer) {
		// Корневой слой
		target.wrapEl = _buildDOM({
			tag: options.rootTag,
			css: { whiteSpace: 'nowrap', zIndex: options.zIndex },
			method: 'post',
			action: '/'
		});


		// Затемнение
		if (!onlyLayer) {
			target.overlayEl = _createOverlay(options.overlay);
			target.overlayBoxEl = target.overlayEl.firstChild;
			_appendChild(target.wrapEl, target.overlayEl);
		}


		// Пустышка для центрирования по вертикали
		var dummyEl = _buildDOM();
		_css(dummyEl, {
			height: '100%',
			display: 'inline-block',
			verticalAlign: 'middle'
		});
		_appendChild(target.wrapEl, dummyEl);


		// Контент
		var el = options.el;
		target.el = (el && el.cloneNode) ? (options.clone ? el.cloneNode(true) : el) : _buildDOM({ html: el || '' });


		// Содержит контент
		target.layerEl = _createLayer(target.el, options);
		target.contentEl = _getContentEl(target.layerEl);
		target.context = new Context(target.layerEl);

		_appendChild(target.wrapEl, target.layerEl);


		// Родительский элемент
		target.bodyEl = options.body && _querySelector(options.body) || document.body;


		target.wrapEl.tabIndex = -1; // для фокуса
		_css(target.wrapEl, {
			top: 0,
			left: 0,
			right: 0,
			bottom: 0,
			position: 'fixed',
			textAlign: 'center',
			overflow: 'auto',
			outline: 0
		});

		return target;
	}


	/**
	 * Получить ссылку на контент
	 * @param   {HTMLElement}  layerEl
	 * @returns {HTMLElement}
	 * @private
	 */
	function _getContentEl(layerEl) {
		return layerEl.firstChild.lastChild.firstChild;
	}



	//
	//       Основной код
	//




	/**
	 * @class   Ply
	 * @param   {HTMLElement|Object}   el  слой или опции
	 * @param   {Object}               [options]   опции слоя
	 */
	function Ply(el, options) {
		options = (el instanceof Object) ? el : (options || {});
		options.el = options.el || el;


		var _this = this;

		// Локальный идентификатор
		_this.cid = 'c' + gid++;


		// Увеличиваем глобальный zIndex
		_defaults.zIndex++;


		// Опции
		_this.options = options = _extend({}, _defaults, options);


		// Флаги
		options.flags = _extend({}, _defaults.flags, options.flags);


		// Создаем Ply-элементы
		_createPly(_this, options);


		// Установим эффекты
		_this.setEffect(options.effect);


		// Очередь эффектов
		_this.fx = function(executor)  {
			/* jshint boss:true */
			return !(_this.fx.queue = _this.fx.queue.then(executor, executor).then(function()  {
				return _this;
			}));
		};
		_this.fx.queue = _resolvePromise();


		// Клик по затемнению
		_this.on('click', ':overlay', function()  {
			_this.hasFlag('closeByOverlay') && _this.closeBy('overlay');
		});


		// Подписываемся кнопку «отмена» и «крестик»
		_this.on('click', ':close', function(evt, el)  {
			evt.preventDefault();
			_this.closeBy(el.nodeName === 'BUTTON' ? 'cancel' : 'x');
		});


		// Событие инициализации
		_this.options.oninit(this);
	}


	// Методы
	Ply.fn = Ply.prototype = /** @lends Ply.prototype */ {
		constructor: Ply,


		/** @private */
		_activate: function () {
			if (!this.hasFlag('bodyScroll')) {
				var bodyEl = this.bodyEl,
					dummyEl = _buildDOM({
						css: { overflow: 'auto', visibility: 'hidden', height: '5px' },
						children: [{ tag: 'div', css: { height: '100px' } }]
					})
				;

				// @todo: Покрыть тестами
				// Сохраняем оригинальные значения
				this.__overflow = _css(bodyEl, 'overflow');
				this.__paddingRight = _css(bodyEl, 'paddingRight');

				_appendChild(bodyEl, dummyEl);
				_css(bodyEl, {
					overflow: 'hidden',
					paddingRight: (dummyEl.offsetWidth - dummyEl.firstChild.offsetWidth) + 'px'
				});
				_removeElement(dummyEl);
			}

			_addEvent(this.wrapEl, 'submit', this._getHandleEvent('submit'));
		},


		/** @private */
		_deactivate: function () {
			if (!this.hasFlag('bodyScroll')) {
				_css(this.bodyEl, {
					overflow: this.__overflow,
					paddingRight: this.__paddingRight
				});
			}

			_removeEvent(this.layerEl, 'submit', this._getHandleEvent('submit'));
		},


		/**
		 * Получить обработчик события
		 * @param   {String}  name  событие
		 * @returns {*}
		 * @private
		 */
		_getHandleEvent: function (name) {
			var _this = this,
				handleEvent = _this.__handleEvent || (_this.__handleEvent = {})
			;

			if (!handleEvent[name]) {
				handleEvent[name] = function(evt)  {
					_this._handleEvent(name, evt);
				};
			}

			return handleEvent[name];
		},


		/**
		 * Центральный обработчик события
		 * @param   {String}  name
		 * @param   {Event}   evt
		 * @private
		 */
		_handleEvent: function (name, evt) {
			evt.preventDefault();
			this.closeBy(name);
		},


		/**
		 * jQuery выборка из слоя
		 * @param   {String}  selector
		 * @returns {jQuery}
		 */
		$: function (selector) {
			return $(selector, this.layerEl);
		},


		/**
		 * Найти элемент внутри слоя
		 * @param   {String}  selector
		 * @returns {HTMLElement}
		 */
		find: function (selector) {
			return _querySelector(selector, this.layerEl);
		},


		/**
		 * Применить эффект к элементу
		 * @param   {HTMLElement}    el
		 * @param   {String}         name
		 * @param   {String|Object}  [effects]
		 * @returns {Promise}
		 */
		applyEffect: function (el, name, effects) {
			el = this[el] || el;

			if (!el.nodeType) {
				effects = name;
				name = el;
				el = this.layerEl;
			}

			effects = Ply.effects.get(effects || this.effects);
			return Ply.effects.apply.call(effects, el, name);
		},


		/**
		 * Закрыть «по»
		 * @param  {String}  name  прчина закрытия
		 */
		closeBy: function (name) {var this$0 = this;
			var ui = {
					by: name,
					state: name === 'submit',
					data: this.context.toJSON(),
					widget: this,
					context: this.context
				},
				el = this.el,
				result = this.options.onaction(ui)
			;

			if (!this.__lock) {
				this.__lock = true;
				this.el.className += ' ply-loading';

				_cast(result)
					.done(function(state ) {
						if (state !== false) {
							this$0.result = ui;
							this$0.close();
						}
					})
					.always(function()  {
						this$0.__lock = false;
						this$0.el.className = this$0.el.className.replace(/\s?ply-loading/, '');
					})
				;
			}
		},


		/**
		 * Подписаться на ply-событие
		 * @param   {String}    event   событие
		 * @param   {String}    target  ply-selector
		 * @param   {Function}  handle
		 * @returns {Ply}
		 */
		on: function (event, target, handle) {
			var _this = this;

			if (!handle) {
				handle = target;
				target = ':layer';
			}

			handle['_' + target] = function(evt)  {
				var el = evt.target;

				do {
					if (el.nodeType === 1) {
						if (el.getAttribute(_plyAttr) === target) {
							return handle.call(_this, evt, el);
						}
					}
				}
				while ((el !== _this.wrapEl) && (el = el.parentNode));
			};

			_addEvent(_this.wrapEl, event, handle['_' + target]);
			return _this;
		},


		/**
		 * Отписаться от ply-событие
		 * @param   {String}    event   событие
		 * @param   {String}    target  ply-selector
		 * @param   {Function}  handle
		 * @returns {Ply}
		 */
		off: function (event, target, handle) {
			if (!handle) {
				handle = target;
				target = 'layer';
			}

			_removeEvent(this.wrapEl, event, handle['_' + target] || noop);
			return this;
		},


		/**
		 * Проверить наличие флага
		 * @param   {String}  name  имя флага
		 * @returns {Boolean}
		 */
		hasFlag: function (name) {
			return !!this.options.flags[name];
		},


		/**
		 * Установить effect
		 * @param   {String|Object}  name
		 * @returns {Ply}
		 */
		setEffect: function (name) {
			this.effects = Ply.effects.get(name);
			return this;
		},


		/**
		 * Открыть/закрыть слой
		 * @param   {Boolean}  state
		 * @param   {*}  effect
		 * @returns {Promise}
		 * @private
		 */
		_toggleState: function (state, effect) {
			var _this = this,
				mode = state ? 'open' : 'close',
				prevLayer = Ply.stack.last
			;

			/* istanbul ignore else */
			if (_this.visible != state) {
				_this.visible = state;
				_this[state ? '_activate' : '_deactivate']();

				// Добавить или удалить слой из стека
				Ply.stack[state ? 'add' : 'remove'](_this);

				// Очередь эффектов
				_this.fx(function()  {
					return _preloadImage(_this.wrapEl).then(function()  {
						var isFirst = Ply.stack.length === (state ? 1 : 0),
							hideLayer = prevLayer && prevLayer.hasFlag('hideLayerInStack'),
							hasOverlay = isFirst || _this.hasFlag('visibleOverlayInStack');

						if (state) {
							// Убрать «затемнение» если мы не первые в стеке
							!hasOverlay && _removeElement(_this.overlayBoxEl);

							_appendChild(_this.bodyEl, _this.wrapEl);
							_this.wrapEl.focus();
							_autoFocus(_this.layerEl);

							if (hideLayer) {
								// Скрыть слой «под»
								prevLayer.applyEffect('close.layer', effect).then(function()  {
									_removeElement(prevLayer.layerEl);
								});
							}
						} else if (prevLayer = Ply.stack.last) {
							// Слой мог быть скрыт, нужно вернуть его
							_appendChild(prevLayer.wrapEl, prevLayer.layerEl);
							prevLayer.hasFlag('hideLayerInStack') && prevLayer.applyEffect('open.layer', effect).then(function()  {
								_autoFocus(prevLayer.el); // todo: нужен метод layer.autoFocus();
							});
						}

						// Применяем основные эффекты
						return _promiseAll([
							_this.applyEffect(mode + '.layer', effect),
							hasOverlay && _this.applyEffect('overlayEl', mode + '.overlay', effect)
						]).then(function()  {
							if (!state) {
								_removeElement(_this.wrapEl);
								_appendChild(_this.overlayEl, _this.overlayBoxEl);
							}
							// «Событие» open или close
							_this.options['on' + mode](_this);
						});
					});
				});
			}

			return _this.fx.queue;
		},


		/**
		 * Открыть слой
		 * @param   {*}  [effect]
		 * @returns {Promise}
		 */
		open: function (effect) {
			this.result = null;
			return this._toggleState(true, effect);
		},


		/**
		 * Закрыть слой
		 * @param   {*}  [effect]
		 * @returns {Promise}
		 */
		close: function (effect) {
			return this._toggleState(false, effect);
		},


		/**
		 * @param   {HTMLElement}  closeEl
		 * @param   {HTMLElement}  openEl
		 * @param   {Object}    effects
		 * @param   {Function}  prepare
		 * @param   {Function}  [complete]
		 * @returns {*}
		 * @private
		 */
		_swap: function (closeEl, openEl, effects, prepare, complete) {
			var _this = this;

			if (_this.visible) {
				_this.fx(function()  {
					return _preloadImage(openEl).then(function()  {
						prepare();

						return _promiseAll([
							_this.applyEffect(closeEl, 'close.layer', effects),
							_this.applyEffect(openEl, 'open.layer', effects)
						]).then(function()  {
							_removeElement(closeEl);
							complete();
							_this.wrapEl.focus();
							_autoFocus(openEl);
						});
					});
				});
			} else {
				complete();
			}

			return _this.fx.queue;
		},


		/**
		 * Заменить слой
		 * @param   {Object}  options
		 * @param   {Object}  [effect]  эффект замены
		 * @returns {Promise}
		 */
		swap: function (options, effect) {
			options = _extend({}, this.options, options);

			var _this = this,
				ply = _createPly({}, options, true),
				effects = (effect || options.effect) ? Ply.effects.get(effect || options.effect) : _this.effects,
				closeEl = _this.layerEl,
				openEl = ply.layerEl
			;

			return _this._swap(closeEl, openEl, effects,
				function()  {
					_appendChild(_this.bodyEl, _this.wrapEl);
					_appendChild(_this.bodyEl, ply.wrapEl);
				},
				function()  {
					_removeElement(ply.wrapEl);
					_appendChild(_this.wrapEl, openEl);

					_this.el = ply.el;
					_this.layerEl = openEl;
					_this.contentEl = _getContentEl(openEl);
					_this.context.el = openEl;
				})
			;
		},


		/**
		 * Заменить внутренности слоя
		 * @param   {Object}  options
		 * @param   {Object}  [effect]  эффект замены
		 * @returns {Promise}
		 */
		innerSwap: function (options, effect) {
			options = _extend({}, this.options, options);

			var _this = this,
				ply = _createPly({}, options, true),
				effects = (effect || options.effect) ? Ply.effects.get(effect || options.effect) : _this.effects,

				inEl = _querySelector('.ply-inside', ply.layerEl),
				outEl = _querySelector('.ply-inside', _this.layerEl)
			;

			return _this._swap(outEl, inEl, effects, function()  {
				_css(outEl, { width: outEl.offsetWidth + 'px', position: 'absolute' });
				_appendChild(outEl.parentNode, inEl);
			}, noop);
		},


		/**
		 * Уничтожить слой
		 */
		destroy: function () {
			_removeElement(this.wrapEl);

			this._deactivate();
			Ply.stack.remove(this);

			this.visible = false;
			this.options.ondestroy(this);
		}
	};


	//
	// Ply-стек
	//
	/**
 * @desc Работы со стеком
 */

var array_core = [],
	array_push = array_core.push,
	array_splice = array_core.splice
;


Ply.stack = {
	_idx: {},


	/**
	 * Последний Ply в стеке
	 * @type {Ply}
	 */
	last: null,


	/**
	 * Длинна стека
	 * @type {Number}
	 */
	length: 0,


	/**
	 * Удаить последний ply-слой из стека
	 * @param  {Event}  evt
	 * @private
	 */
	_pop: function (evt) {
		var layer = Ply.stack.last;

		if (evt.keyCode === keys.esc && layer.hasFlag('closeByEsc')) {
			layer.closeBy('esc');
		}
	},


	/**
	 * Добавить ply в стек
	 * @param  {Ply}  layer
	 */
	add: function (layer) {
		var idx = array_push.call(this, layer);

		this.last = layer;
		this._idx[layer.cid] = idx - 1;

		if (idx === 1) {
			_addEvent(document, 'keyup', this._pop);
		}
	},


	/**
	 * Удалить ply из стека
	 * @param  {Ply}  layer
	 */
	remove: function (layer) {
		var idx = this._idx[layer.cid];

		if (idx >= 0) {
			array_splice.call(this, idx, 1);

			delete this._idx[layer.cid];
			this.last = this[this.length-1];

			if (!this.last) {
				_removeEvent(document, 'keyup', this._pop);
			}
		}
	}
};



	//
	// Эффекты
	//
	Ply.effects = /**
 * @desc Объект для работы с эффектами
 */

{
	// Установки по умолчанию
	defaults: {
		duration: 300,

		open: {
			layer: null,
			overlay: null
		},

		close: {
			layer: null,
			overlay: null
		}
	},


	/**
	 * Настройти эффекты по умолчанию
	 * @static
	 * @param  {Object}  options
	 */
	setup: function (options) {
		this.defaults = this.get(options);
	},


	set: function (desc) {
		_extend(this, desc);
	},


	/**
	 * Получить опции на основе переданных и по умолчанию
	 * @static
	 * @param   {Object}  options  опции
	 * @returns {Object}
	 */
	get: function (options) {
		var defaults = _deepClone(this.defaults);

		// Функция разбора выражения `name:duration[args]`
		function parseKey(key) {
			var match = /^([\w_-]+)(?::(\d+%?))?(\[[^\]]+\])?/.exec(key) || [];
			return {
				name: match[1] || key,
				duration: match[2] || null,
				args: JSON.parse(match[3] || 'null') || {}
			};
		}


		function toObj(obj, key, def) {
			var fx = parseKey(key),
				val = (obj[fx.name] || def || {}),
				duration = (fx.duration || val.duration || obj.duration || options.duration)
			;

			if (typeof val === 'string') {
				val = parseKey(val);
				delete val.args;
			}

			if (/%/.test(val.duration)) {
				val.duration = parseInt(val.duration, 10) / 100 * duration;
			}

			val.duration = (val.duration || duration) | 0;

			return val;
		}


		if (typeof options === 'string') {
			var fx = parseKey(options);
			options = _deepClone(this[fx.name] || { open: {}, close: {} });
			options.duration = fx.duration || options.duration;
			options.open.args = fx.args[0];
			options.close.args = fx.args[1];
		}
		else if (options instanceof Array) {
			var openFx = parseKey(options[0]),
				closeFx = parseKey(options[1]),
				open = this[openFx.name],
				close = this[closeFx.name]
			;

			options = {
				open: _deepClone(open && open.open || { layer: options[0], overlay: options[0] }),
				close: _deepClone(close && close.close || { layer: options[1], overlay: options[1] })
			};

			options.open.args = openFx.args[0];
			options.close.args = closeFx.args[0];
		}
		else if (!(options instanceof Object)) {
			options = {};
		}

		options.duration = (options.duration || defaults.duration) | 0;

		for (var key in {open: 0, close: 0}) {
			var val = options[key] || defaults[key] || {};
			if (typeof val === 'string') {
				// если это строка, то только layer
				val = { layer: val };
			}
			val.layer = toObj(val, 'layer', defaults[key].layer);
			val.overlay = toObj(val, 'overlay', defaults[key].overlay);

			if(val.args === void 0){
				// clean
				delete val.args;
			}

			options[key] = val;
		}

		return options;
	},


	/**
	 * Применить эффекты
	 * @static
	 * @param   {HTMLElement}  el    элемент, к которому нужно применить эффект
	 * @param   {String}       name  название эффекта
	 * @returns {Promise|undefined}
	 */
	apply: function (el, name) {
		name = name.split('.');

		var effects = this[name[0]], // эффекты open/close
			firstEl = el.firstChild,
			oldStyle = [el.getAttribute('style'), firstEl && firstEl.getAttribute('style')],
			fx,
			effect
		;


		if (support.transition && effects && (effect = effects[name[1]]) && (fx = Ply.effects[effect.name])) {
			if (fx['to'] || fx['from']) {
				// Клонируем
				fx = _deepClone(fx);

				// Выключаем анимацию
				_css(el, 'transition', 'none');
				_css(firstEl, 'transition', 'none');

				// Определяем текущее css-значения
				_each(fx['to'], function(val, key, target)  {
					if (val === '&') {
						target[key] = _css(el, key);
					}
				});

				// Выставляем initied значения
				if (isFn(fx['from'])) {
					fx['from'](el, effects.args);
				} else if (fx['from']) {
					_css(el, fx['from']);
				}

				return _promise(function(resolve)  {
					// Принудительный repaint/reflow
					fx.width = el.offsetWidth;

					// Включаем анимацию
					_css(el, 'transition', 'all ' + effect.duration + 'ms');
					_css(firstEl, 'transition', 'all ' + effect.duration + 'ms');

					// Изменяем css
					if (isFn(fx['to'])) {
						fx['to'](el, effects.args);
					}
					else {
						_css(el, fx['to']);
					}

					// Ждем завершения анимации
					setTimeout(resolve, effect.duration);
				}).then(function()  {
					el.setAttribute('style', oldStyle[0]);
					firstEl && firstEl.setAttribute('style', oldStyle[1]);
				});
			}
		}

		return _resolvePromise();
	}
}
	Ply.effects.set(/**
 * @desc Предустановленные эффекты
 */

{
	//
	// Комбинированный эффекты
	//

	'fade': {
		open:  { layer: 'fade-in:80%', overlay: 'fade-in:100%' },
		close: { layer: 'fade-out:60%', overlay: 'fade-out:60%' }
	},

	'scale': {
		open:  { layer: 'scale-in', overlay: 'fade-in' },
		close: { layer: 'scale-out', overlay: 'fade-out' }
	},

	'fall': {
		open:  { layer: 'fall-in', overlay: 'fade-in' },
		close: { layer: 'fall-out', overlay: 'fade-out' }
	},

	'slide': {
		open:  { layer: 'slide-in', overlay: 'fade-in' },
		close: { layer: 'slide-out', overlay: 'fade-out' }
	},

	'3d-flip': {
		open:  { layer: '3d-flip-in', overlay: 'fade-in' },
		close: { layer: '3d-flip-out', overlay: 'fade-out' }
	},

	'3d-sign': {
		open:  { layer: '3d-sign-in', overlay: 'fade-in' },
		close: { layer: '3d-sign-out', overlay: 'fade-out' }
	},

	'inner': {
		open:  { layer: 'inner-in' },
		close: { layer: 'inner-out' }
	},


	//
	// Описание эффекта
	//

	'fade-in': {
		'from': { opacity: 0 },
		'to':   { opacity: '&' }
	},

	'fade-out': {
		'to': { opacity: 0 }
	},

	'slide-in': {
		'from': { opacity: 0, transform: 'translateY(20%)' },
		'to':   { opacity: '&', transform: 'translateY(0)' }
	},

	'slide-out': {
		'to': { opacity: 0, transform: 'translateY(20%)' }
	},

	'fall-in': {
		'from': { opacity: 0, transform: 'scale(1.3)' },
		'to':   { opacity: '&', transform: 'scale(1)' }
	},

	'fall-out': {
		'to': { opacity: 0, transform: 'scale(1.3)' }
	},

	'scale-in': {
		'from': { opacity: 0, transform: 'scale(0.7)' },
		'to':   { opacity: '&', transform: 'scale(1)' }
	},

	'scale-out': {
		'to': { opacity: 0, 'transform': 'scale(0.7)' }
	},

	'rotate3d': function(el, opacity, axis, deg, origin)  {
		_css(el, { perspective: '1300px' });
		_css(el.firstChild, {
			opacity: opacity,
			transform: 'rotate' + axis + '(' + deg + 'deg)',
			transformStyle: 'preserve-3d',
			transformOrigin: origin ? '50% 0' : '50%'
		});
	},

	'3d-sign-in': {
		'from': function(el)  {
			Ply.effects.rotate3d(el, 0, 'X', -60, '50% 0');
		},
		'to': function(el)  {
			_css(el.firstChild, { opacity: 1, transform: 'rotateX(0)' });
		}
	},

	'3d-sign-out': {
		'from': function(el)  {
			Ply.effects.rotate3d(el, 1, 'X', 0, '50% 0');
		},
		'to': function(el)  {
			_css(el.firstChild, { opacity: 0, transform: 'rotateX(-60deg)' });
		}
	},

	'3d-flip-in': {
		'from': function(el, deg)  {
			Ply.effects.rotate3d(el, 0, 'Y', deg || -70);
		},
		'to': function(el)  {
			_css(el.firstChild, { opacity: 1, transform: 'rotateY(0)' });
		}
	},

	'3d-flip-out': {
		'from': function(el)  {
			Ply.effects.rotate3d(el, 1, 'Y', 0);
		},
		'to': function(el, deg)  {
			_css(el.firstChild, { opacity: 0, transform: 'rotateY(' + (deg || 70) + 'deg)' });
		}
	},

	'inner-in': {
		'from': function(el)  { _css(el, 'transform', 'translateX(100%)'); },
		'to': function(el)  { _css(el, 'transform', 'translateX(0%)'); }
	},

	'inner-out': {
		'from': function(el)  { _css(el, 'transform', 'translateX(0%)'); },
		'to': function(el)  { _css(el, 'transform', 'translateX(-100%)'); }
	}
});



	//
	// Ply.Context
	//
	/**
 * @desc Ply-контекст
 */


/**
 * @class  Ply.Context
 * @param  {HTMLElement}  el
 */
function Context(el) {
	/**
	 * Корневой элемент
	 * @type {HTMLElement}
	 */
	this.el = el;
}

Context.fn = Context.prototype = /** @lends Ply.Context */{
	constructor: Context,


	/**
	 * Получить элемент по имени
	 * @param   {String}  name
	 * @returns {HTMLElement|undefined}
	 */
	getEl: function (name) {
		if (this.el) {
			return _querySelector('[' + _plyAttr + '-name="' + name + '"]', this.el);
		}
	},


	/**
	 * Получить или установить значение по имени
	 * @param   {String}  name
	 * @param   {String}  [value]
	 * @returns {String}
	 */
	val: function (name, value) {
		var el = typeof name === 'string' ? this.getEl(name) : name;

		if (el && (el.value == null)) {
			el = _getElementsByTagName(el, 'input')[0]
			  || _getElementsByTagName(el, 'textarea')[0]
			  || _getElementsByTagName(el, 'select')[0]
			;
		}

		if (el && value != null) {
			el.value = value;
		}

		return el && el.value || "";
	},


	/**
	 * Получить JSON
	 * @returns {Object}
	 */
	toJSON: function () {
		var items = this.el.querySelectorAll('[' + _plyAttr + '-name]'),
			json = {},
			el,
			i = items.length
		;
		while (i--) {
			el = items[i];
			json[el.getAttribute(_plyAttr + '-name')] = this.val(el);
		}
		return json;
	}
};


	//
	// Ply.ui
	//
	/**
 * @desc Диалоги
 */

/*global Ply */

	'use strict';

	function _isNode(el) {
		return el && el.appendChild;
	}

	function _toBlock(block, name) {
		if (block == null) {
			return { skip: true };
		}

		if (typeof block === 'string') {
			block = { text: block };
		}

		if (typeof block === 'object') {
			block.name = block.name || name;
		}

		return block;
	}



	/**
	 * Управление рендером UI
	 * @param  {String}  name
	 * @param  {Object}  [data]
	 * @param  {String}  [path]
	 * @returns {HTMLElement}
	 */
	function ui(name, data, path) {
		var fn = ui[name], el;

		if (!fn) {
			name = name.split(/\s+/).slice(0, -1).join(' ');
			fn = data && (
					   ui[name + ' [name=' + data.name + ']']
					|| ui[name + ' [type=' + data.type + ']']
				)
				|| ui[name + ' *']
				|| ui[':default'];
		}

		el = _buildDOM(fn(data, path));
		if (data && data.name) {
			el.setAttribute(_plyAttr + '-name', data.name);
		}
		el.className += ' ply-ui';

		return el;
	}


	/**
	 * Назначение визуализатор
	 * @param {String}    name  имя фабрики
	 * @param {Function}  renderer
	 * @param {Boolean}  [simpleMode]
	 */
	ui.factory = function (name, renderer, simpleMode) {
		ui[name.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ')] = function (data, path) {
			var fragment = document.createDocumentFragment(), result;

			if ((data != null) || name === ':root') {
				data = simpleMode ? data : _toBlock(data);

				_each(simpleMode ? data : data.children, function (block, key) {
					var abs = ((path || name) + ' ' + key).replace(/^:\w+\s+/, ''),
						el = _isNode(block) ? block : ui(abs, _toBlock(block, key), abs)
					;

					_appendChild(fragment, el);
				});

				if (!simpleMode) {
					delete data.children;
				}

				result = renderer(data, fragment);

				/* istanbul ignore else */
				if (!_isNode(result)) {
					_extend(result, data);
				}

				return result;
			}

			return fragment;
		};
	};


	// Элемент по умолчанию
	ui.factory(':default', function(data, children)  {
		data.children = children;
		return data;
	});


	// Ply-слой - корневой элемент
	ui.factory(':root', function (data) {
		return {
			tag: '.ply-form',
			className: data.mod,
			children: [
				ui(':header', data.header),
				ui(':content', data.content),
				data.ctrls && ui(':default', {
					tag: 'div.ply-footer',
					children: data.ctrls
				})
			]
		};
	});


	// «Заголовк» слоя
	ui.factory(':header', function (data, children) {
		return { tag: '.ply-header', text: data.text, children: children };
	});


	// «Содержимое» слоя
	ui.factory(':content', function (data, children) {
		return { tag: '.ply-content', children: children };
	}, true);


	// Кнопка «ОК»
	ui.factory('ok', function (data) {
		return {
			ply: ':ok',
			tag: 'button.ply-ctrl.ply-ok',
			text: data === true ? lang.ok : data
		};
	});


	// Кнопка «Отмена»
	ui.factory('cancel', function (data) {
		return {
			ply: ':close',
			tag: 'button.ply-ctrl.ply-cancel',
			type: 'reset',
			text: data === true ? lang.cancel : data
		};
	});


	/**
	 * Фабрика слоев
	 * @param {String}   name
	 * @param {Function} renderer
	 */
	function factory(name, renderer) {
		factory['_' + name] = renderer;

		factory[name] = function(options, data)  {
			return _promise(function(resolve, reject)  {
				renderer(options, data, resolve, reject);
			}).then(function(el)  {
				/* istanbul ignore else */
				if (!_isNode(el)) {
					el = ui(':root', el);
				}

				return el;
			});
		};
	}


	/**
	 * Использовать фабрику
	 * @param {String}   name
	 * @param {Object}   options
	 * @param {Object}   data
	 * @param {Function} resolve
	 * @param {Function} [reject]
	 */
	factory.use = function(name, options, data, resolve, reject)  {
		factory['_' + name](options, data, resolve, reject);
	};


	/**
	 * Абстрактный диалог
	 * @param   {String}  mod  модификатор
	 * @param   {Object}  options
	 * @param   {Object}  data
	 * @param   {Object}  defaults
	 * @returns {Object}
	 * @private
	 */
	function _dialogFactory(mod, options, data, defaults) {
		options.mod = mod;
		options.effect = options.effect || 'slide';
		options.flags = _extend({ closeBtn: false }, options.flags);

		return {
			header: data.title,
			content: data.form
				? { 'dialog-form': { children: data.form } }
				: { el: data.text || data },
			ctrls: {
				ok: data.ok || defaults.ok,
				cancel: data.cancel === false ? null : (data.cancel || defaults.cancel)
			}
		};
	}


	// Фабрика по умолчанию
	factory('default', function(options, data, resolve)  {
		resolve(data || /* istanbul ignore next */ {});
	});


	// Базовый жиалог
	factory('base', function(options, data, resolve)  {
		resolve(_dialogFactory('base', options, data));
	});


	// Диалог: «Предупреждение»
	factory('alert', function(options, data, resolve)  {
		resolve(_dialogFactory('alert', options, data, { ok: true }));
	});


	// Диалог: «Подтверждение»
	factory('confirm', function(options, data, resolve)  {
		resolve(_dialogFactory('confirm', options, data, {
			ok: true,
			cancel: true
		}));
	});


	// Диалог: «Запросить данные»
	factory('prompt', function(options, data, resolve)  {
		resolve(_dialogFactory('prompt', options, data, {
			ok: true,
			cancel: true
		}));
	});


	// Элемент формы
	ui.factory('dialog-form *', function(data)  {
		return {
			tag: 'input.ply-input',
			type: data.type || 'text',
			name: data.name,
			value: data.value,
			required: true,
			placeholder: data.hint || data.text
		};
	});


	/**
	 * Создать Ply-слой на основе фабрики
	 * @param   {String}  name       название фабрики
	 * @param   {Object}  [options]  опции
	 * @param   {Object}  [data]     данные для фабрики
	 * @returns {Promise}
	 */
	Ply.create = function(name, options, data)  {
		if (_isNode(name)) {
			return _resolvePromise(new Ply(_extend(options || {}, { el: name })));
		}

		if (!data) {
			data = options;
			options = {};
		}

		var renderer = (factory[name] || factory['default']);
		return renderer(options, data).then(function(el)  {
			return new Ply(_extend(options, { el: el }));
		});
	};


	/**
	 * Открыть Ply-слой
	 * @param   {String}  name
	 * @param   {Object}  [options]
	 * @param   {Object}  [data]
	 * @returns {Promise}
	 */
	Ply.open = function(name, options, data)  {
		return Ply.create(name, options, data).then(function(layer)  {
			return layer.open();
		});
	};


	/**
	 * Создать диалог или систему диалогов
	 * @param   {String|Object}  name
	 * @param   {Object}         [options]
	 * @param   {Object}         [data]
	 * @returns {Promise}
	 */
	Ply.dialog = function(name, options, data)  {
		if ((name instanceof Object) && !_isNode(name)) {
			options = options || /* istanbul ignore next */ {};

			return _promise(function(resolve, reject)  {
				var first = options.initState,
					current,
					rootLayer,
					interactive,
					stack = name,
					dialogs = {},

					_progress = function(ui, layer)  {
						(options.progress || /* istanbul ignore next */ noop)(_extend({
							name:		current.$name,
							index:		current.$index,
							length:		length,
							stack:		stack,
							current:	current,
							widget:		layer
						}, ui), dialogs);
					},

					changeLayer = function(spec, effect, callback)  {
						// Клонирование данных
						var data = JSON.parse(JSON.stringify(spec.data));

						current = spec; // текущий диалог
						interactive = true; // идет анимация
						(spec.prepare || noop)(data, dialogs);

						Ply.create(spec.ui || 'alert', spec.options || {}, data).then(function(layer)  {
							var promise;

							if (rootLayer) {
								promise = rootLayer[/^inner/.test(effect) ? 'innerSwap' : 'swap'](layer, effect);
							} else {
								rootLayer = layer;
								promise = rootLayer.open();
							}

							promise.then(function()  {
								dialogs[spec.$name].el = rootLayer.layerEl;
								interactive = false;
							});

							callback(rootLayer);
						});
					}
				;


				var length = 0;
				_each(stack, function(spec, key)  {
					first = first || key;
					spec.effects = spec.effects || {};
					spec.$name   = key;
					spec.$index  = length++;
					dialogs[key] = new Ply.Context();
				});
				stack.$length = length;


				changeLayer(stack[first], null, function(layer)  {
					_progress({}, layer);

					//noinspection FunctionWithInconsistentReturnsJS
					rootLayer.options.onaction = function(ui)  {
						if (interactive) {
							return false;
						}

						var isNext = ui.state || (current.back === 'next'),
							swap = stack[current[isNext ? 'next' : 'back']]
						;

//						console.log(current.$name, stack[current[isNext ? 'next' : 'back']]);

						if (swap) {
							changeLayer(swap, current[isNext ? 'nextEffect' : 'backEffect'], function(layer)  {
								_progress(ui, layer);
							});

							return false;
						} else {
							(ui.state ? resolve : /* istanbul ignore next */ reject)(ui, dialogs);
						}
					};
				});
			});
		}
		else {
			if (!data && !_isNode(name)) {
				data = options || {};
				options = {};
			}

			return Ply.open(name, options, data).then(function(layer)  {
				return _promise(function(resolve, reject)  {
					layer.options.onclose = function()  {
						(layer.result.state ? resolve : reject)(layer.result);
					};
				});
			});
		}
	};


	// Export
	Ply.ui = ui;
	Ply.factory = factory;



	//
	// Export
	//
	Ply.lang = lang;
	Ply.css = _css;
	Ply.cssHooks = _cssHooks;

	Ply.keys = keys;
	Ply.noop = noop;
	Ply.each = _each;
	Ply.extend = _extend;
	Ply.promise = _promise;
	Ply.Promise = Promise;
	Ply.support = support;
	Ply.defaults = _defaults;
	Ply.attrName = _plyAttr;
	Ply.Context = Context;

	Ply.dom = {
		build: _buildDOM,
		append: _appendChild,
		remove: _removeElement,
		addEvent: _addEvent,
		removeEvent: _removeEvent
	};


	Ply.version = '0.6.1';

	return Ply;
});

define('service/auth',['uuid', 'RPC', 'Ply'], function (uuid, RPC, Ply) {
	var ACCESS_TOKEN = 'app-access-token';
	var ACCESS_EMAIL = 'app-access-email';
	var accessToken = localStorage.getItem(ACCESS_TOKEN);
	var authPromise;
	var loginPromise;


	if (!accessToken) {
		accessToken = uuid();
		localStorage.setItem(ACCESS_TOKEN, accessToken);
	}


	RPC.setup('token', accessToken);
	RPC.setup('email', localStorage.getItem(ACCESS_EMAIL));


	RPC.errorHandler.push({
		status: 'denied:user',
		process: function (xhr) {
			if (!loginPromise) {
				loginPromise = Ply.dialog('prompt', {
					onaction: function (ui) {
						var layerEl = ui.widget.layerEl;

						layerEl.classList.remove('shake');

						return RPC.call('user/login', ui.data).then(function () {
							var email = ui.data.email;

							xhr.data.email = email;
							RPC.setup('email', email);

							localStorage.setItem(ACCESS_EMAIL, email);

							loginPromise = null;
						}, function () {
							layerEl.classList.add('animated');
							layerEl.classList.add('shake');

							return Promise.reject();
						});
					}
				},{
					title: 'Log in',
					form: {
						email: 'Email',
						password: {
							hint: 'Password',
							type: 'password'
						}
					},
					ok: 'Yarrr!',
					cancel: false
				});
			}

			return loginPromise;
		}
	});

	// Export
	return function () {
		if (!authPromise) {
			authPromise = RPC.call('user');
		}

		return authPromise;
	};
});

define('pilot/mixin/fest',['pilot/mixin/view'], function (view) {
	// Export
	return Object.keys(view).reduce(function (target, name) {
		target[name] = target[name] || view[name];
		return target;
	}, {
		// Fest mixin

		components: {},

		apply: function () {
			var pid,
				_this = this;

			_this.dom = '<div></div>';

			// Родительская DOM-примись
			view.apply.apply(this, arguments);

			// todo: нужно переделывать
			document.body.appendChild(_this.el);

			// Биндинг компонентов к DOM
			Object.keys(_this.components).forEach(function (name) {
				var el = document.createElement('span');

				_this[name] = _this.components[name];

				_this[name].route = _this;
				_this[name].bind(el);

				_this.el.appendChild(el);
			});

			_this.on('route', function () {
				clearTimeout(pid);
				pid = setTimeout(function () {
					Object.keys(_this.components).forEach(function (name) {
						_this[name].$apply();
					});
				}, 1);
			});
		},


		$: function (selector) {
			return this.components[selector] || view.$.call(this, selector);
		}
	});
});

define('sitemap',['require','ui/nav/nav','ui/caption/caption','ui/toolbar/toolbar','ui/datalist/datalist','ui/letter/letter','Action','mail/Folder','mail/Message','mediator/action','mediator/selection','ui/block','pilot/mixin/view','service/auth','pilot/mixin/fest','pilot/mixin/fest','pilot/mixin/fest'],function (require) {
	'use strict';


	// Всякие ui-блоки (хелпер)
	var ui = {
		nav: require('ui/nav/nav'),
		caption: require('ui/caption/caption'),
		toolbar: require('ui/toolbar/toolbar'),
		datalist: require('ui/datalist/datalist'),
		letter: require('ui/letter/letter')
	};


	{
		// Модельки
		var Action = require('Action');
		var Folder = require('mail/Folder');
		var Message = require('mail/Message');

		// Медиаторы
		var action = require('mediator/action');
		var selection = require('mediator/selection');
	}


	var _toUrl = function (params, builder) {
		if (params instanceof Folder) {
			params = {folder: params.id};
		}
		else if (params instanceof Message) {
			params = {folder: params.get('folder'), message: params.id};
		}

		var folder = Folder.get(params.folder);

		if (folder.is('system')) {
			params.folder = folder.get('type');
		}

		 return builder(params);
	};



	// Структура приложеньки
	return {
		dom: require('ui/block').render('layout'),
		mixins: [require('pilot/mixin/view')],
		access: require('service/auth'),

		'on:route': function () {
			this.el.classList.toggle('layout_3', this.request.is('#message'));
		},

		// Глобальные модели
		model: {
			// Список папок
			folders: function () {
				return Folder.all.length ? Folder.all : Folder.find();
			},

			// Папка
			folder: function (req, waitFor) {
				return waitFor('folders').then(function (folders) {
					return folders.get(req.params.folder);
				});
			}
		},

		// Регионы
		'*': {
			'folders': {
				mixins: [require('pilot/mixin/fest')],
				components: {
					nav: ui.nav({models: Folder.all})
				},
				'on:route': function () {
					this.nav.active = this.model.folder.id;
				}
			}
		},


		// Список писем
		'#messages': {
			url: {
				pattern: '/:folder?',
				params: {
					folder: {
						default: 0,
						decode: function (value) {
							var id = Folder[value.toUpperCase()];
							return id === void 0 ? parseInt(value, 10) : id;
						}
					}
				},
				toUrl: _toUrl
			},

			model: {
				messages: function (req) {
					var folderId = req.params.folder;

					return this[folderId] || Message.find({folder: folderId, last_modified: 1}).then(function (folders) {
						this[folderId] = folders;
						return folders;
					}.bind(this));
				}
			},
			mixins: [require('pilot/mixin/fest')],
			components: {
				caption: ui.caption({}),
				datalist: ui.datalist({
					onselect: selection.onSelect,
					onunread: action.toggleUnread,
					ondelete: action.delete
				}),
				toolbar: ui.toolbar({
					hidden: true,
					items: [{
						icon: 'check',
						text: 'Прочитать',
						onclick: action.markAsReadedSelected
					}, {
						icon: 'trash-o',
						text: 'Удалить',
						onclick: action.deleteSelected
					}]
				})
			},
			init: function () {
				action.setSource(selection);
				selection.setSource(this.datalist);

				selection.on('change', function (evt) {
					this.toolbar.$set('hidden', !evt.selected);
				}.bind(this));

				action.on('execution', function () {
					selection.clear();
				});
			},
			'on:route': function () {
				this.caption.$set('text', this.model.folder.get('name'));
				this.datalist.setModels(this.model.messages);
			},


			'#inbox': {
				// да ничего не нужно
			},

			'#message': {
				url: '/:folder/:message',
				model: {
					message: function (req, waitFor) {
						return Message.findOne(req.params.message);
					}
				},
				mixins: [require('pilot/mixin/fest')],
				components: {
					letter: ui.letter({
						model: new Message,
						html: function () {
							return (this.model.get('body.html') || '').replace(/<base.*?>/g, '');
						}
					})
				},
				'on:route': function () {
					this.letter.model = this.model.message;
					Action.execute('mail.MarkAs', {models: [this.model.message], flag: 'unread', state: false});
				}
			}
		}
	};
});

define('app',[
	'RPC',
	'pilot',
	'sitemap'
], function (
	/** RPC */RPC,
	/** Pilot */Pilot,
	/** Object */sitemap
) {
	RPC.setup({
		'baseUrl': /local\.git/.test(location) ? 'http://127.0.0.1:5000/' : 'https://dump-api-proxy.herokuapp.com/'
	});

	var app = Pilot.create(sitemap);
	var navChanged = function () {
		app.nav(location.hash.split('!').pop() || '/');
	};

	window.addEventListener('hashchange', function () {
		navChanged();
	});

	// Init
	navChanged();

	return (window.app = app);
});

if (!Array.prototype.indexOf) {
// Array.prototype.indexOf
Array.prototype.indexOf = function indexOf(searchElement) {
	for (var array = this, index = 0, length = array.length; index < length; ++index) {
		if (array[index] === searchElement) {
			return index;
		}
	}

	return -1;
};

}
if (!Array.prototype.filter) {
// Array.prototype.filter
Array.prototype.filter = function filter(callback, scope) {
	for (var array = this, arrayB = [], index = 0, length = array.length, element; index < length; ++index) {
		element = array[index];

		if (callback.call(scope || window, element, index, array)) {
			arrayB.push(element);
		}
	}

	return arrayB;
};

}
if (!Array.prototype.reduce) {
// Array.prototype.reduce
Array.prototype.reduce = function reduce(callback, initialValue) {
	var array = this, previousValue = initialValue || 0;

	for (var index = 0, length = array.length; index < length; ++index) {
		previousValue = callback.call(window, previousValue, array[index], index, array);
	}

	return previousValue;
};

}
if (!Array.prototype.map) {
// Array.prototype.map
Array.prototype.map = function map(callback, scope) {
	for (var array = this, arrayB = [], index = 0, length = array.length, element; index < length; ++index) {
		element = array[index];

		arrayB.push(callback.call(scope || window, array[index], index, array));
	}

	return arrayB;
};

}
if (!Function.prototype.bind) {
// Function.prototype.bind
Function.prototype.bind = function bind(thisArg) {
	var callback = this,
		args = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : [];

	return function () {
		return args.length === 0 && arguments.length === 0
			? callback.call(thisArg)
			: callback.apply(thisArg, args.concat(Array.prototype.slice.call(arguments, 0)));
	};
};

}
if (!Array.prototype.forEach) {
// Array.prototype.forEach
Array.prototype.forEach = function forEach(callback, scope) {
	for (var array = this, index = 0, length = array.length; index < length; ++index) {
		callback.call(scope || window, array[index], index, array);
	}
};

}
if (typeof window.JSON === "undefined") {
/** @license MIT Asen Bozhilov JSON.parse (https://github.com/abozhilov/json) */
(function () {
	var
	toString = Object.prototype.toString,
	hasOwnProperty = Object.prototype.hasOwnProperty,
	LEFT_CURLY = '{',
	RIGHT_CURLY = '}',
	COLON = ':',
	LEFT_BRACE = '[',
	RIGHT_BRACE = ']',
	COMMA = ',',
	tokenType = {
		PUNCTUATOR: 1,
		STRING: 2,
		NUMBER: 3,
		BOOLEAN: 4,
		NULL: 5
	},
	tokenMap = {
		'{': 1, '}': 1, '[': 1, ']': 1, ',': 1, ':': 1,
		'"': 2,
		't': 4, 'f': 4,
		'n': 5
	},
	escChars = {
		'b': '\b',
		'f': '\f',
		'n': '\n',
		'r': '\r',
		't': '\t',
		'"': '"',
		'\\': '\\',
		'/': '/'
	},
	tokenizer = /^(?:[{}:,\[\]]|true|false|null|"(?:[^"\\\u0000-\u001F]|\\["\\\/bfnrt]|\\u[0-9A-F]{4})*"|-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)/,
	whiteSpace = /^[\t ]+/,
	lineTerminator = /^\r?\n/;

	function JSONLexer(JSONStr) {
		this.line = 1;
		this.col = 1;
		this._tokLen = 0;
		this._str = JSONStr;
	}

	JSONLexer.prototype = {
		getNextToken: function () {
			var
			str = this._str,
			token, type;

			this.col += this._tokLen;

			if (!str.length) {
				return 'END';
			}

			token = tokenizer.exec(str);

			if (token) {
				type = tokenMap[token[0].charAt(0)] || tokenType.NUMBER;
			} else if ((token = whiteSpace.exec(str))) {
				this._tokLen = token[0].length;
				this._str = str.slice(this._tokLen);
				return this.getNextToken();
			} else if ((token = lineTerminator.exec(str))) {
				this._tokLen = 0;
				this._str = str.slice(token[0].length);
				this.line++;
				this.col = 1;
				return this.getNextToken();
			} else {
				this.error('Invalid token');
			}

			this._tokLen = token[0].length;
			this._str = str.slice(this._tokLen);

			return {
				type: type,
				value: token[0]
			};
		},

		error: function (message, line, col) {
			var err = new SyntaxError(message);

			err.line = line || this.line;
			err.col = col || this.col;

			throw err;
		}
	};

	function JSONParser(lexer) {
		this.lex = lexer;
	}

	JSONParser.prototype = {
		parse: function () {
			var lex = this.lex, jsValue = this.getValue();

			if (lex.getNextToken() !== 'END') {
				lex.error('Illegal token');
			}

			return jsValue;
		},
		getObject: function () {
			var
			jsObj = {},
			lex = this.lex,
			token, tval, prop,
			line, col,
			pairs = false;

			while (true) {
				token = lex.getNextToken();
				tval = token.value;

				if (tval === RIGHT_CURLY) {
					return jsObj;
				}

				if (pairs) {
					if (tval === COMMA) {
						line = lex.line;
						col = lex.col - 1;
						token = lex.getNextToken();
						tval = token.value;
						if (tval === RIGHT_CURLY) {
							lex.error('Invalid trailing comma', line, col);
						}
					}
					else {
						lex.error('Illegal token where expect comma or right curly bracket');
					}
				}
				else if (tval === COMMA) {
					lex.error('Invalid leading comma');
				}

				if (token.type != tokenType.STRING) {
					lex.error('Illegal token where expect string property name');
				}

				prop = this.getString(tval);

				token = lex.getNextToken();
				tval = token.value;

				if (tval != COLON) {
					lex.error('Illegal token where expect colon');
				}

				jsObj[prop] = this.getValue();
				pairs = true;
			}
		},
		getArray: function () {
			var
			jsArr = [],
			lex = this.lex,
			token, tval,
			line, col,
			values = false;

			while (true) {
				token = lex.getNextToken();
				tval = token.value;

				if (tval === RIGHT_BRACE) {
					return jsArr;
				}

				if (values) {
					if (tval === COMMA) {
						line = lex.line;
						col = lex.col - 1;
						token = lex.getNextToken();
						tval = token.value;

						if (tval === RIGHT_BRACE) {
							lex.error('Invalid trailing comma', line, col);
						}
					} else {
						lex.error('Illegal token where expect comma or right square bracket');
					}
				} else if (tval === COMMA) {
					lex.error('Invalid leading comma');
				}

				jsArr.push(this.getValue(token));
				values = true;
			}
		},
		getString: function (strVal) {
			return strVal.slice(1, -1).replace(/\\u?([0-9A-F]{4}|["\\\/bfnrt])/g, function (match, escVal) {
				return escChars[escVal] || String.fromCharCode(parseInt(escVal, 16));
			});
		},
		getValue: function(fromToken) {
			var lex = this.lex,
				token = fromToken || lex.getNextToken(),
				tval = token.value;
			switch (token.type) {
				case tokenType.PUNCTUATOR:
					if (tval === LEFT_CURLY) {
						return this.getObject();
					} else if (tval === LEFT_BRACE) {
						return this.getArray();
					}

					lex.error('Illegal punctoator');

					break;
				case tokenType.STRING:
					return this.getString(tval);
				case tokenType.NUMBER:
					return Number(tval);
				case tokenType.BOOLEAN:
					return tval === 'true';
				case tokenType.NULL:
					return null;
				default:
					lex.error('Invalid value');
			}
		}
	};

	function filter(base, prop, value) {
		if (typeof value === 'undefined') {
			delete base[prop];
			return;
		}
		base[prop] = value;
	}

	function walk(holder, name, rev) {
		var val = holder[name], i, len;

		if (toString.call(val).slice(8, -1) === 'Array') {
			for (i = 0, len = val.length; i < len; i++) {
				filter(val, i, walk(val, i, rev));
			}
		} else if (typeof val === 'object') {
			for (i in val) {
				if (hasOwnProperty.call(val, i)) {
					filter(val, i, walk(val, i, rev));
				}
			}
		}

		return rev.call(holder, name, val);
	}

	function pad(value, length) {
		value = String(value);

		return value.length >= length ? value : new Array(length - value.length + 1).join('0') + value;
	}

	Window.prototype.JSON = {
		parse: function (JSONStr, reviver) {
			var jsVal = new JSONParser(new JSONLexer(JSONStr)).parse();

			if (typeof reviver === 'function') {
				return walk({
					'': jsVal
				}, '', reviver);
			}

			return jsVal;
		},
		stringify: function () {
			var
			value = arguments[0],
			replacer = typeof arguments[1] === 'function' ? arguments[1] : null,
			space = arguments[2] || '',
			spaceSpace = space ? ' ' : '',
			spaceReturn = space ? '\n' : '',
			className = toString.call(value).slice(8, -1),
			array, key, hasKey, index, length, eachValue;

			if (value === null || className === 'Boolean' || className === 'Number') {
				return value;
			}

			if (className === 'Array') {
				array = [];

				for (length = value.length, index = 0, eachValue; index < length; ++index) {
					eachValue = replacer ? replacer(index, value[index]) : value[index];
					eachValue = this.stringify(eachValue, replacer, space);

					if (eachValue === undefined || eachValue === null) {
						eachValue = 'null';
					}

					array.push(eachValue);
				}

				return '[' + spaceReturn + array.join(',' + spaceReturn).replace(/^/mg, space) + spaceReturn + ']';
			}

			if (className === 'Date') {
				return '"' + value.getUTCFullYear() + '-' +
				pad(value.getUTCMonth() + 1, 2)     + '-' +
				pad(value.getUTCDate(), 2)          + 'T' +
				pad(value.getUTCHours(), 2)         + ':' +
				pad(value.getUTCMinutes(), 2)       + ':' +
				pad(value.getUTCSeconds(), 2)       + '.' +
				pad(value.getUTCMilliseconds(), 3)  + 'Z' + '"';
			}

			if (className === 'String') {
				return '"' + value.replace(/"/g, '\\"') + '"';
			}

			if (typeof value === 'object') {
				array = [];
				hasKey = false;

				for (key in value) {
					if (hasOwnProperty.call(value, key)) {
						eachValue = replacer ? replacer(key, value[key]) : value[key];
						eachValue = this.stringify(eachValue, replacer, space);

						if (eachValue !== undefined) {
							hasKey = true;

							array.push('"' + key + '":' + spaceSpace + eachValue);
						}
					}
				}

				if (!hasKey) {
					return '{}';
				} else {
					return '{' + spaceReturn + array.join(',' + spaceReturn).replace(/^/mg, space) + spaceReturn + '}';
				}
			}
		}
	};
})();

}
if (typeof Object !== "undefined" && !Object.keys) {
// Object.keys
Object.keys = function keys(object) {
	var buffer = [], key;

	for (key in object) {
		if (Object.prototype.hasOwnProperty.call(object, key)) {
			buffer.push(key);
		}
	}

	return buffer;
};

}
if (!String.prototype.trim) {
// String.prototype.trim
String.prototype.trim = function trim() {
	return this.replace(/^\s+|\s+$/g, '');
};

}
if (!Array.prototype.some) {
// Array.prototype.some
Array.prototype.some = function some(callback, scope) {
	for (var array = this, index = 0, length = array.length; index < length; ++index) {
		if (callback.call(scope || window, array[index], index, array)) {
			return true;
		}
	}

	return false;
};

}
if (typeof Array !== "undefined" && !Array.isArray) {
// Array.isArray
Array.isArray = function isArray(array) {
	return array && Object.prototype.toString.call(array) === '[object Array]';
};

}
if (Date.now === void 0) {
	Date.now = function () {
		return new Date().getTime();
	};
}

Number.isNaN = Number.isNaN || function(value) {
  return typeof value === 'number' && isNaN(value);
};

if (typeof Object.create != 'function') {
	Object.create = (function () {
		var result,
			Temp = function () {};

		return function (prototype, propertiesObject) {
			if (typeof prototype != 'object') {
				throw TypeError('Argument must be an object');
			}

			Temp.prototype = prototype;
			result = new Temp();
			Temp.prototype = null;

			if (propertiesObject) {
				Object.keys(propertiesObject).forEach(function (key) {
					result[key] = propertiesObject[key].value;
				});
			}

			return result;
		};
	})();
}
;
define("autopolyfiller", function(){});

(function (factory) {
	'use strict';

	if (typeof window == 'object' && window.wallaby) {
		wallaby.delayStart();
		factory('./', require, wallaby);
	}
	else if (typeof define === 'function' && define.amd) {
		define('jssdk', [],function () {
			return factory(require.toUrl('jssdk').split('/').slice(0, -1).join('/'), require);
		});
	} else {
		var cfg = factory(__dirname, { config: function () {} });

		delete cfg.tests;
		delete cfg.bench;
		delete cfg.modules;

		module.exports = {
			cfg: cfg,

			extend: function (cfg) {
				Object.keys(this.cfg).forEach(function (key) {
					var value = cfg[key],
						extValue = this[key];

					if (cfg[key]) {
						if (value instanceof Array) {
							cfg[key] = value.concat(extValue);
						} else {
							Object.keys(extValue).forEach(function (key) {
								value[key] = extValue[key];
							});
						}
					} else {
						cfg[key] = extValue;
					}
				}, this.cfg);

				return cfg;
			}
		};
	}
})(function (rootPath, require, wallaby) {
	'use strict';

	// Описание бута
	var cfg = {},
		_cfg;

	if (!Array.prototype.forEach) {
		// Array.prototype.forEach
		Array.prototype.forEach = function forEach(callback, scope) {
			for (var array = this, index = 0, length = array.length; index < length; ++index) {
				callback.call(scope || window, array[index], index, array);
			}
		};

	}

	if (typeof Object !== "undefined" && !Object.keys) {
		// Object.keys
		Object.keys = function keys(object) {
			var buffer = [], key;

			for (key in object) {
				if (Object.prototype.hasOwnProperty.call(object, key)) {
					buffer.push(key);
				}
			}

			return buffer;
		};
	}

	// Конфигурация JSSDK
	require.config(_cfg = {
		deps: ['autopolyfiller'].concat(wallaby ? wallaby.tests : []),
		callback: wallaby && wallaby.start,

		shim: {
			'jquery.mockjax': { deps: ['jquery'] }
		},

		paths: (function (cfg) {
			cfg.tests = [];
			cfg.bench = [];
			cfg.paths = {};


			// Модули системы
			cfg.modules = [
				'config',
				'logger',
				'Emitter',
				'Promise',
				'request',
				'RPC',
				'RPC/statuses/sdc',
				'RPC/statuses/token',
				'Storage',
				'Model',
				'Model.List',
				'RPCModel',
				'cloud/Entry',
				'utils/util',
				'utils/extension',
				'mail/Folder',
				'mail/Contact',
				'mail/User',
				'mail/Phone',
				'Action',
				'mail/actions/MarkAs',
				'mail/actions/MarkAsAll',
				'mail/actions/MoveTo',
				'mail/actions/MoveToAll',
				'mail/actions/Delete',
				'mail/actions/DeleteAll',
				'mail/actions/Spam',
				'mail/actions/Archive',
				'mail/actions/ArchiveAll',
				'mail/Message',
				'mail/Thread',
				'calendar/Event',
				'calendar/actions/EventAction'
				/* module */
			];


			// Собираем реальные пути до модулей
			cfg.modules.forEach(function (name) {
				var fullname = name.split('/');

				fullname.push(fullname.slice().pop());
				fullname = fullname.join('/');

				cfg.tests.push(name + '.test');
				cfg.bench.push(name + '.bench');

				cfg.paths[name + '.test'] = fullname + '.test';
				cfg.paths[name + '.bench'] = fullname + '.bench';

				cfg.paths[name] = fullname;
			});


			// todo: не забыть удалить
			cfg.paths['mail/Spam/old-api-adapter'] = 'mail/actions/Spam/old-api-adapter';


			// Поставщики разных полезностей
			var vendors = {
				'uuid': 'vendor/uuid',
				'filter': 'vendor/filter',
				'jquery': 'vendor/jquery',
				'jquery.mockjax': 'vendor/jquery.mockjax',
				'benchmark': 'vendor/benchmark',
				'canjs': '//cdnjs.cloudflare.com/ajax/libs/can.js/1.1.7/can.jquery.min',
				'exojs': 'https://dl.dropboxusercontent.com/s/9mw2uyevis1ue2d/exoskeleton.js?dl=0',
				'backbone': '//cdnjs.cloudflare.com/ajax/libs/backbone.js/1.1.2/backbone-min',
				'underscore': '//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min',
				'inherit': 'vendor/inherit',
				'performance': 'vendor/performance',
				'autopolyfiller': 'vendor/autopolyfiller',
				'apidoc': 'tests/apidoc',
			};


			// Добавляем путь до jssdk
			function _paths() {
				var paths = cfg.paths;

				[].forEach.call(arguments, function (arg) {
					Object.keys(arg).forEach(function (name, value) {
						value = arg[name];
						paths[name] = (/^(\/\/|http)/.test(value) ? '' : rootPath + '/') + value;
					});
				});

				return paths;
			}


			return _paths(cfg.paths, vendors);
		})(typeof cfg === 'undefined' ? {} : cfg)
	});


	Object.keys(_cfg).forEach(function (key) {
		cfg[key] = _cfg[key];
	});


	// Export
	return cfg;
});

